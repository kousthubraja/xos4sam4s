
ILI93XX_EXAMPLE2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003900  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000850  20000000  00403900  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004b0  20000850  00404150  00010850  2**2
                  ALLOC
  3 .stack        00003000  20000d00  00404600  00010850  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00010850  2**0
                  CONTENTS, READONLY
  5 .comment      00000071  00000000  00000000  0001087a  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001a4c2  00000000  00000000  000108eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004a67  00000000  00000000  0002adad  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000754e  00000000  00000000  0002f814  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000d38  00000000  00000000  00036d62  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000d18  00000000  00000000  00037a9a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00013a2d  00000000  00000000  000387b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000fc64  00000000  00000000  0004c1df  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00055ca0  00000000  00000000  0005be43  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001bf8  00000000  00000000  000b1ae4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20003d00 	.word	0x20003d00
  400004:	00401bb9 	.word	0x00401bb9
  400008:	00401bb5 	.word	0x00401bb5
  40000c:	00401bb5 	.word	0x00401bb5
  400010:	00401bb5 	.word	0x00401bb5
  400014:	00401bb5 	.word	0x00401bb5
  400018:	00401bb5 	.word	0x00401bb5
	...
  40002c:	00401bb5 	.word	0x00401bb5
  400030:	00401bb5 	.word	0x00401bb5
  400034:	00000000 	.word	0x00000000
  400038:	00401bb5 	.word	0x00401bb5
  40003c:	00401bb5 	.word	0x00401bb5
  400040:	00401bb5 	.word	0x00401bb5
  400044:	00401bb5 	.word	0x00401bb5
  400048:	00401bb5 	.word	0x00401bb5
  40004c:	00401bb5 	.word	0x00401bb5
  400050:	00401bb5 	.word	0x00401bb5
  400054:	00401bb5 	.word	0x00401bb5
  400058:	00401bb5 	.word	0x00401bb5
  40005c:	00401bb5 	.word	0x00401bb5
  400060:	00401bb5 	.word	0x00401bb5
  400064:	00401bb5 	.word	0x00401bb5
  400068:	00000000 	.word	0x00000000
  40006c:	004018e9 	.word	0x004018e9
  400070:	00401905 	.word	0x00401905
  400074:	00401921 	.word	0x00401921
  400078:	00401bb5 	.word	0x00401bb5
  40007c:	00401bb5 	.word	0x00401bb5
	...
  400088:	00401bb5 	.word	0x00401bb5
  40008c:	00401bb5 	.word	0x00401bb5
  400090:	00401bb5 	.word	0x00401bb5
  400094:	00401bb5 	.word	0x00401bb5
  400098:	00401bb5 	.word	0x00401bb5
  40009c:	00401bb5 	.word	0x00401bb5
  4000a0:	00401bb5 	.word	0x00401bb5
  4000a4:	00401bb5 	.word	0x00401bb5
  4000a8:	00401bb5 	.word	0x00401bb5
  4000ac:	00401bb5 	.word	0x00401bb5
  4000b0:	00401bb5 	.word	0x00401bb5
  4000b4:	00401bb5 	.word	0x00401bb5
  4000b8:	00401bb5 	.word	0x00401bb5
  4000bc:	00401bb5 	.word	0x00401bb5
  4000c0:	00401bb5 	.word	0x00401bb5
  4000c4:	00401bb5 	.word	0x00401bb5
  4000c8:	00401bb5 	.word	0x00401bb5

004000cc <deregister_tm_clones>:
  4000cc:	b508      	push	{r3, lr}
  4000ce:	4805      	ldr	r0, [pc, #20]	; (4000e4 <deregister_tm_clones+0x18>)
  4000d0:	4b05      	ldr	r3, [pc, #20]	; (4000e8 <deregister_tm_clones+0x1c>)
  4000d2:	1a19      	subs	r1, r3, r0
  4000d4:	2906      	cmp	r1, #6
  4000d6:	d800      	bhi.n	4000da <deregister_tm_clones+0xe>
  4000d8:	bd08      	pop	{r3, pc}
  4000da:	4a04      	ldr	r2, [pc, #16]	; (4000ec <deregister_tm_clones+0x20>)
  4000dc:	2a00      	cmp	r2, #0
  4000de:	d0fb      	beq.n	4000d8 <deregister_tm_clones+0xc>
  4000e0:	4790      	blx	r2
  4000e2:	e7f9      	b.n	4000d8 <deregister_tm_clones+0xc>
  4000e4:	00403900 	.word	0x00403900
  4000e8:	00403903 	.word	0x00403903
  4000ec:	00000000 	.word	0x00000000

004000f0 <register_tm_clones>:
  4000f0:	b508      	push	{r3, lr}
  4000f2:	4807      	ldr	r0, [pc, #28]	; (400110 <register_tm_clones+0x20>)
  4000f4:	4b07      	ldr	r3, [pc, #28]	; (400114 <register_tm_clones+0x24>)
  4000f6:	1a19      	subs	r1, r3, r0
  4000f8:	108a      	asrs	r2, r1, #2
  4000fa:	eb02 73d2 	add.w	r3, r2, r2, lsr #31
  4000fe:	1059      	asrs	r1, r3, #1
  400100:	d100      	bne.n	400104 <register_tm_clones+0x14>
  400102:	bd08      	pop	{r3, pc}
  400104:	4a04      	ldr	r2, [pc, #16]	; (400118 <register_tm_clones+0x28>)
  400106:	2a00      	cmp	r2, #0
  400108:	d0fb      	beq.n	400102 <register_tm_clones+0x12>
  40010a:	4790      	blx	r2
  40010c:	e7f9      	b.n	400102 <register_tm_clones+0x12>
  40010e:	bf00      	nop
  400110:	00403900 	.word	0x00403900
  400114:	00403900 	.word	0x00403900
  400118:	00000000 	.word	0x00000000

0040011c <__do_global_dtors_aux>:
  40011c:	b510      	push	{r4, lr}
  40011e:	4c06      	ldr	r4, [pc, #24]	; (400138 <__do_global_dtors_aux+0x1c>)
  400120:	7823      	ldrb	r3, [r4, #0]
  400122:	b943      	cbnz	r3, 400136 <__do_global_dtors_aux+0x1a>
  400124:	f7ff ffd2 	bl	4000cc <deregister_tm_clones>
  400128:	4804      	ldr	r0, [pc, #16]	; (40013c <__do_global_dtors_aux+0x20>)
  40012a:	b110      	cbz	r0, 400132 <__do_global_dtors_aux+0x16>
  40012c:	4804      	ldr	r0, [pc, #16]	; (400140 <__do_global_dtors_aux+0x24>)
  40012e:	f3af 8000 	nop.w
  400132:	2101      	movs	r1, #1
  400134:	7021      	strb	r1, [r4, #0]
  400136:	bd10      	pop	{r4, pc}
  400138:	20000850 	.word	0x20000850
  40013c:	00000000 	.word	0x00000000
  400140:	00403900 	.word	0x00403900

00400144 <frame_dummy>:
  400144:	b508      	push	{r3, lr}
  400146:	4b08      	ldr	r3, [pc, #32]	; (400168 <frame_dummy+0x24>)
  400148:	b11b      	cbz	r3, 400152 <frame_dummy+0xe>
  40014a:	4808      	ldr	r0, [pc, #32]	; (40016c <frame_dummy+0x28>)
  40014c:	4908      	ldr	r1, [pc, #32]	; (400170 <frame_dummy+0x2c>)
  40014e:	f3af 8000 	nop.w
  400152:	4808      	ldr	r0, [pc, #32]	; (400174 <frame_dummy+0x30>)
  400154:	6801      	ldr	r1, [r0, #0]
  400156:	b111      	cbz	r1, 40015e <frame_dummy+0x1a>
  400158:	4a07      	ldr	r2, [pc, #28]	; (400178 <frame_dummy+0x34>)
  40015a:	b102      	cbz	r2, 40015e <frame_dummy+0x1a>
  40015c:	4790      	blx	r2
  40015e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400162:	f7ff bfc5 	b.w	4000f0 <register_tm_clones>
  400166:	bf00      	nop
  400168:	00000000 	.word	0x00000000
  40016c:	00403900 	.word	0x00403900
  400170:	20000854 	.word	0x20000854
  400174:	00403900 	.word	0x00403900
  400178:	00000000 	.word	0x00000000

0040017c <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  40017c:	b510      	push	{r4, lr}
	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40017e:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  400182:	f2c0 7027 	movt	r0, #1831	; 0x727
  400186:	f641 63d5 	movw	r3, #7893	; 0x1ed5
  40018a:	f2c0 0340 	movt	r3, #64	; 0x40
  40018e:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  400190:	f04f 0000 	mov.w	r0, #0
  400194:	f04f 013e 	mov.w	r1, #62	; 0x3e
  400198:	f641 12dd 	movw	r2, #6621	; 0x19dd
  40019c:	f2c0 0240 	movt	r2, #64	; 0x40
  4001a0:	4790      	blx	r2
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  4001a2:	f641 244d 	movw	r4, #6733	; 0x1a4d
  4001a6:	f2c0 0440 	movt	r4, #64	; 0x40
  4001aa:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4001ac:	2800      	cmp	r0, #0
  4001ae:	d0fc      	beq.n	4001aa <sysclk_init+0x2e>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4001b0:	f641 205d 	movw	r0, #6749	; 0x1a5d
  4001b4:	f2c0 0040 	movt	r0, #64	; 0x40
  4001b8:	4780      	blx	r0
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4001ba:	f44f 6180 	mov.w	r1, #1024	; 0x400
  4001be:	f2c4 010e 	movt	r1, #16398	; 0x400e
  4001c2:	f643 7301 	movw	r3, #16129	; 0x3f01
  4001c6:	f2c2 0313 	movt	r3, #8211	; 0x2013
  4001ca:	628b      	str	r3, [r1, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  4001cc:	f641 246d 	movw	r4, #6765	; 0x1a6d
  4001d0:	f2c0 0440 	movt	r4, #64	; 0x40
  4001d4:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  4001d6:	2800      	cmp	r0, #0
  4001d8:	d0fc      	beq.n	4001d4 <sysclk_init+0x58>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  4001da:	f04f 0010 	mov.w	r0, #16
  4001de:	f641 123d 	movw	r2, #6461	; 0x193d
  4001e2:	f2c0 0240 	movt	r2, #64	; 0x40
  4001e6:	4790      	blx	r2
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  4001e8:	f641 501d 	movw	r0, #7453	; 0x1d1d
  4001ec:	f2c0 0040 	movt	r0, #64	; 0x40
  4001f0:	4780      	blx	r0
  4001f2:	bd10      	pop	{r4, pc}

004001f4 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
  4001f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4001f8:	460c      	mov	r4, r1
  4001fa:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
  4001fc:	bb48      	cbnz	r0, 400252 <_read+0x5e>
		return -1;
	}

	for (; len > 0; --len) {
  4001fe:	2a00      	cmp	r2, #0
  400200:	dd2b      	ble.n	40025a <_read+0x66>

int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
  400202:	188f      	adds	r7, r1, r2
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  400204:	f640 46e4 	movw	r6, #3300	; 0xce4
  400208:	f2c2 0600 	movt	r6, #8192	; 0x2000
  40020c:	f640 45dc 	movw	r5, #3292	; 0xcdc
  400210:	f2c2 0500 	movt	r5, #8192	; 0x2000
  400214:	ea6f 0901 	mvn.w	r9, r1
  400218:	eb07 0009 	add.w	r0, r7, r9
  40021c:	f000 0901 	and.w	r9, r0, #1
  400220:	6830      	ldr	r0, [r6, #0]
  400222:	682b      	ldr	r3, [r5, #0]
  400224:	4798      	blx	r3
		ptr++;
  400226:	f104 0401 	add.w	r4, r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  40022a:	42bc      	cmp	r4, r7
  40022c:	d119      	bne.n	400262 <_read+0x6e>
  40022e:	e00d      	b.n	40024c <_read+0x58>
		ptr_get(stdio_base, ptr);
  400230:	6830      	ldr	r0, [r6, #0]
  400232:	682b      	ldr	r3, [r5, #0]
  400234:	4621      	mov	r1, r4
  400236:	4798      	blx	r3
		ptr++;
  400238:	f104 0401 	add.w	r4, r4, #1
  40023c:	4621      	mov	r1, r4
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  40023e:	6830      	ldr	r0, [r6, #0]
  400240:	682a      	ldr	r2, [r5, #0]
  400242:	4790      	blx	r2
		ptr++;
  400244:	f104 0401 	add.w	r4, r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  400248:	42bc      	cmp	r4, r7
  40024a:	d1f1      	bne.n	400230 <_read+0x3c>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
  40024c:	4640      	mov	r0, r8
  40024e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
  400252:	f04f 30ff 	mov.w	r0, #4294967295
  400256:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	}

	for (; len > 0; --len) {
  40025a:	f04f 0000 	mov.w	r0, #0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
  40025e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  400262:	f1b9 0f00 	cmp.w	r9, #0
  400266:	d0e3      	beq.n	400230 <_read+0x3c>
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  400268:	6830      	ldr	r0, [r6, #0]
  40026a:	682a      	ldr	r2, [r5, #0]
  40026c:	4621      	mov	r1, r4
  40026e:	4790      	blx	r2
		ptr++;
  400270:	f104 0401 	add.w	r4, r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  400274:	42bc      	cmp	r4, r7
  400276:	d1db      	bne.n	400230 <_read+0x3c>
  400278:	e7e8      	b.n	40024c <_read+0x58>
  40027a:	bf00      	nop

0040027c <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len);

int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
  40027c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  400280:	460d      	mov	r5, r1
  400282:	4690      	mov	r8, r2
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
  400284:	f100 30ff 	add.w	r0, r0, #4294967295
  400288:	2802      	cmp	r0, #2
  40028a:	d824      	bhi.n	4002d6 <_write+0x5a>
		return -1;
	}

	for (; len != 0; --len) {
  40028c:	b332      	cbz	r2, 4002dc <_write+0x60>
		if (ptr_put(stdio_base, *ptr++) < 0) {
  40028e:	f640 46e4 	movw	r6, #3300	; 0xce4
  400292:	f2c2 0600 	movt	r6, #8192	; 0x2000
  400296:	f640 47e0 	movw	r7, #3296	; 0xce0
  40029a:	f2c2 0700 	movt	r7, #8192	; 0x2000
  40029e:	f04f 0400 	mov.w	r4, #0
  4002a2:	f102 39ff 	add.w	r9, r2, #4294967295
  4002a6:	f009 0901 	and.w	r9, r9, #1
  4002aa:	6830      	ldr	r0, [r6, #0]
  4002ac:	683b      	ldr	r3, [r7, #0]
  4002ae:	5d09      	ldrb	r1, [r1, r4]
  4002b0:	4798      	blx	r3
  4002b2:	42a0      	cmp	r0, r4
  4002b4:	da1a      	bge.n	4002ec <_write+0x70>
  4002b6:	e014      	b.n	4002e2 <_write+0x66>
  4002b8:	6830      	ldr	r0, [r6, #0]
  4002ba:	683b      	ldr	r3, [r7, #0]
  4002bc:	5d29      	ldrb	r1, [r5, r4]
  4002be:	4798      	blx	r3
  4002c0:	2800      	cmp	r0, #0
  4002c2:	db0e      	blt.n	4002e2 <_write+0x66>
			return -1;
		}
		++nChars;
  4002c4:	f104 0401 	add.w	r4, r4, #1
	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
  4002c8:	6830      	ldr	r0, [r6, #0]
  4002ca:	683a      	ldr	r2, [r7, #0]
  4002cc:	5d29      	ldrb	r1, [r5, r4]
  4002ce:	4790      	blx	r2
  4002d0:	2800      	cmp	r0, #0
  4002d2:	da1d      	bge.n	400310 <_write+0x94>
  4002d4:	e005      	b.n	4002e2 <_write+0x66>
_write (int file, const char *ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
  4002d6:	f04f 34ff 	mov.w	r4, #4294967295
  4002da:	e004      	b.n	4002e6 <_write+0x6a>
	}

	for (; len != 0; --len) {
  4002dc:	f04f 0400 	mov.w	r4, #0
  4002e0:	e001      	b.n	4002e6 <_write+0x6a>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
  4002e2:	f04f 34ff 	mov.w	r4, #4294967295
		}
		++nChars;
	}
	return nChars;
}
  4002e6:	4620      	mov	r0, r4
  4002e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
  4002ec:	f104 0401 	add.w	r4, r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  4002f0:	45a0      	cmp	r8, r4
  4002f2:	d0f8      	beq.n	4002e6 <_write+0x6a>
  4002f4:	f1b9 0f00 	cmp.w	r9, #0
  4002f8:	d0de      	beq.n	4002b8 <_write+0x3c>
		if (ptr_put(stdio_base, *ptr++) < 0) {
  4002fa:	6830      	ldr	r0, [r6, #0]
  4002fc:	683a      	ldr	r2, [r7, #0]
  4002fe:	5d29      	ldrb	r1, [r5, r4]
  400300:	4790      	blx	r2
  400302:	2800      	cmp	r0, #0
  400304:	dbed      	blt.n	4002e2 <_write+0x66>
			return -1;
		}
		++nChars;
  400306:	f104 0401 	add.w	r4, r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  40030a:	45a0      	cmp	r8, r4
  40030c:	d1d4      	bne.n	4002b8 <_write+0x3c>
  40030e:	e7ea      	b.n	4002e6 <_write+0x6a>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
  400310:	f104 0401 	add.w	r4, r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  400314:	45a0      	cmp	r8, r4
  400316:	d1cf      	bne.n	4002b8 <_write+0x3c>
  400318:	e7e5      	b.n	4002e6 <_write+0x6a>
  40031a:	bf00      	nop

0040031c <board_init>:
#include "conf_board.h"
#include "gpio.h"
#include "ioport.h"

void board_init(void)
{
  40031c:	b538      	push	{r3, r4, r5, lr}
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  40031e:	f241 4350 	movw	r3, #5200	; 0x1450
  400322:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400326:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40032a:	605a      	str	r2, [r3, #4]
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  40032c:	f04f 000b 	mov.w	r0, #11
  400330:	f641 247d 	movw	r4, #6781	; 0x1a7d
  400334:	f2c0 0440 	movt	r4, #64	; 0x40
  400338:	47a0      	blx	r4
  40033a:	f04f 000c 	mov.w	r0, #12
  40033e:	47a0      	blx	r4
  400340:	f04f 000d 	mov.w	r0, #13
  400344:	47a0      	blx	r4
	 * Here IOPORT must be initialized for others to use before setting up IO.
	 */
	ioport_init();

	/* Configure LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
  400346:	f04f 0013 	mov.w	r0, #19
  40034a:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  40034e:	f241 54d9 	movw	r4, #5593	; 0x15d9
  400352:	f2c0 0440 	movt	r4, #64	; 0x40
  400356:	47a0      	blx	r4
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
  400358:	f04f 0014 	mov.w	r0, #20
  40035c:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  400360:	47a0      	blx	r4

	/* Configure Push Button pins */
	gpio_configure_pin(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS);
  400362:	f04f 0023 	mov.w	r0, #35	; 0x23
  400366:	f04f 0179 	mov.w	r1, #121	; 0x79
  40036a:	f6c2 0100 	movt	r1, #10240	; 0x2800
  40036e:	47a0      	blx	r4
	gpio_configure_pin(GPIO_PUSH_BUTTON_2, GPIO_PUSH_BUTTON_2_FLAGS);
  400370:	f04f 004c 	mov.w	r0, #76	; 0x4c
  400374:	f04f 0159 	mov.w	r1, #89	; 0x59
  400378:	f6c2 0100 	movt	r1, #10240	; 0x2800
  40037c:	47a0      	blx	r4

#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART0_PIO, PINS_UART0, PINS_UART0_FLAGS);
  40037e:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  400382:	f2c4 000e 	movt	r0, #16398	; 0x400e
  400386:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  40038a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  40038e:	f241 7551 	movw	r5, #5969	; 0x1751
  400392:	f2c0 0540 	movt	r5, #64	; 0x40
  400396:	47a8      	blx	r5
	gpio_set_pin_low(PIN_RE_IDX);
#endif

#if defined(CONF_BOARD_ILI9325) || defined(CONF_BOARD_ILI93XX)
	/* Configure LCD EBI pins */
	gpio_configure_pin(PIN_EBI_DATA_BUS_D0, PIN_EBI_DATA_BUS_FLAGS);
  400398:	f04f 0501 	mov.w	r5, #1
  40039c:	f6c0 0500 	movt	r5, #2048	; 0x800
  4003a0:	f04f 0040 	mov.w	r0, #64	; 0x40
  4003a4:	4629      	mov	r1, r5
  4003a6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D1, PIN_EBI_DATA_BUS_FLAGS);
  4003a8:	f04f 0041 	mov.w	r0, #65	; 0x41
  4003ac:	4629      	mov	r1, r5
  4003ae:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D2, PIN_EBI_DATA_BUS_FLAGS);
  4003b0:	f04f 0042 	mov.w	r0, #66	; 0x42
  4003b4:	4629      	mov	r1, r5
  4003b6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D3, PIN_EBI_DATA_BUS_FLAGS);
  4003b8:	f04f 0043 	mov.w	r0, #67	; 0x43
  4003bc:	4629      	mov	r1, r5
  4003be:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D4, PIN_EBI_DATA_BUS_FLAGS);
  4003c0:	f04f 0044 	mov.w	r0, #68	; 0x44
  4003c4:	4629      	mov	r1, r5
  4003c6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D5, PIN_EBI_DATA_BUS_FLAGS);
  4003c8:	f04f 0045 	mov.w	r0, #69	; 0x45
  4003cc:	4629      	mov	r1, r5
  4003ce:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D6, PIN_EBI_DATA_BUS_FLAGS);
  4003d0:	f04f 0046 	mov.w	r0, #70	; 0x46
  4003d4:	4629      	mov	r1, r5
  4003d6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D7, PIN_EBI_DATA_BUS_FLAGS);
  4003d8:	f04f 0047 	mov.w	r0, #71	; 0x47
  4003dc:	4629      	mov	r1, r5
  4003de:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_NRD, PIN_EBI_NRD_FLAGS);
  4003e0:	f04f 004b 	mov.w	r0, #75	; 0x4b
  4003e4:	4629      	mov	r1, r5
  4003e6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_NWE, PIN_EBI_NWE_FLAGS);
  4003e8:	f04f 0048 	mov.w	r0, #72	; 0x48
  4003ec:	4629      	mov	r1, r5
  4003ee:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_NCS1, PIN_EBI_NCS1_FLAGS);
  4003f0:	f04f 004f 	mov.w	r0, #79	; 0x4f
  4003f4:	4629      	mov	r1, r5
  4003f6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_LCD_RS, PIN_EBI_LCD_RS_FLAGS);
  4003f8:	f04f 0053 	mov.w	r0, #83	; 0x53
  4003fc:	4629      	mov	r1, r5
  4003fe:	47a0      	blx	r4
#endif

#ifdef CONF_BOARD_AAT3155
	/* Configure Backlight control pin */
	gpio_configure_pin(BOARD_AAT31XX_SET_GPIO, BOARD_AAT31XX_SET_FLAGS);
  400400:	f04f 004d 	mov.w	r0, #77	; 0x4d
  400404:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400408:	47a0      	blx	r4
  40040a:	bd38      	pop	{r3, r4, r5, pc}

0040040c <aat31xx_set_backlight>:
 * \param ul_level backlight level.
 *
 * \note pin BOARD_AAT31XX_SET_GPIO must be configured before calling aat31xx_set_backlight.
 */
void aat31xx_set_backlight(uint32_t ul_level)
{
  40040c:	b470      	push	{r4, r5, r6}
  40040e:	b083      	sub	sp, #12
	volatile uint32_t ul_delay;
	uint32_t i;

#ifdef CONF_BOARD_AAT3155
	ul_level = AAT31XX_MAX_BACKLIGHT_LEVEL - ul_level + 1;
  400410:	f1c0 0011 	rsb	r0, r0, #17
#ifdef CONF_BOARD_AAT3193
	ul_level = AAT31XX_MAX_BACKLIGHT_LEVEL - ul_level + 1;
#endif

	/* Ensure valid level */
	ul_level = (ul_level > AAT31XX_MAX_BACKLIGHT_LEVEL) ? AAT31XX_MAX_BACKLIGHT_LEVEL : ul_level;
  400414:	2810      	cmp	r0, #16
  400416:	bf34      	ite	cc
  400418:	4606      	movcc	r6, r0
  40041a:	2610      	movcs	r6, #16
	ul_level = (ul_level < AAT31XX_MIN_BACKLIGHT_LEVEL) ? AAT31XX_MIN_BACKLIGHT_LEVEL : ul_level;
  40041c:	2e00      	cmp	r6, #0
  40041e:	bf08      	it	eq
  400420:	2601      	moveq	r6, #1

	/* Set new backlight level */
	for (i = 0; i < ul_level; i++) {
  400422:	f04f 0100 	mov.w	r1, #0
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  400426:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  40042a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40042e:	f44f 5500 	mov.w	r5, #8192	; 0x2000
		ioport_set_pin_level(BOARD_AAT31XX_SET_GPIO, IOPORT_PIN_LEVEL_LOW);
		ul_delay = DELAY_PULSE;
  400432:	f04f 0418 	mov.w	r4, #24
  400436:	6345      	str	r5, [r0, #52]	; 0x34
  400438:	9401      	str	r4, [sp, #4]
		while (ul_delay--) {
  40043a:	9b01      	ldr	r3, [sp, #4]
  40043c:	f103 32ff 	add.w	r2, r3, #4294967295
  400440:	9201      	str	r2, [sp, #4]
  400442:	2b00      	cmp	r3, #0
  400444:	d1f9      	bne.n	40043a <aat31xx_set_backlight+0x2e>
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  400446:	6305      	str	r5, [r0, #48]	; 0x30
		}

		ioport_set_pin_level(BOARD_AAT31XX_SET_GPIO, IOPORT_PIN_LEVEL_HIGH);

		ul_delay = DELAY_PULSE;
  400448:	9401      	str	r4, [sp, #4]
		while (ul_delay--) {
  40044a:	9b01      	ldr	r3, [sp, #4]
  40044c:	f103 32ff 	add.w	r2, r3, #4294967295
  400450:	9201      	str	r2, [sp, #4]
  400452:	2b00      	cmp	r3, #0
  400454:	d1f9      	bne.n	40044a <aat31xx_set_backlight+0x3e>
	/* Ensure valid level */
	ul_level = (ul_level > AAT31XX_MAX_BACKLIGHT_LEVEL) ? AAT31XX_MAX_BACKLIGHT_LEVEL : ul_level;
	ul_level = (ul_level < AAT31XX_MIN_BACKLIGHT_LEVEL) ? AAT31XX_MIN_BACKLIGHT_LEVEL : ul_level;

	/* Set new backlight level */
	for (i = 0; i < ul_level; i++) {
  400456:	f101 0101 	add.w	r1, r1, #1
  40045a:	42b1      	cmp	r1, r6
  40045c:	d3eb      	bcc.n	400436 <aat31xx_set_backlight+0x2a>
		ul_delay = DELAY_PULSE;
		while (ul_delay--) {
		}
	}

	ul_delay = DELAY_ENABLE;
  40045e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  400462:	9101      	str	r1, [sp, #4]
	while (ul_delay--) {
  400464:	9801      	ldr	r0, [sp, #4]
  400466:	f100 33ff 	add.w	r3, r0, #4294967295
  40046a:	9301      	str	r3, [sp, #4]
  40046c:	2800      	cmp	r0, #0
  40046e:	d1f9      	bne.n	400464 <aat31xx_set_backlight+0x58>
	}
}
  400470:	b003      	add	sp, #12
  400472:	bc70      	pop	{r4, r5, r6}
  400474:	4770      	bx	lr
  400476:	bf00      	nop

00400478 <aat31xx_disable_backlight>:

/**
 * \brief Switch off backlight.
 */
void aat31xx_disable_backlight(void)
{
  400478:	b082      	sub	sp, #8
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40047a:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  40047e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400482:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  400486:	635a      	str	r2, [r3, #52]	; 0x34
	volatile uint32_t ul_delay;

	ioport_set_pin_level(BOARD_AAT31XX_SET_GPIO, IOPORT_PIN_LEVEL_LOW);

	ul_delay = DELAY_DISABLE;
  400488:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  40048c:	9001      	str	r0, [sp, #4]
	while (ul_delay--) {
  40048e:	9901      	ldr	r1, [sp, #4]
  400490:	f101 33ff 	add.w	r3, r1, #4294967295
  400494:	9301      	str	r3, [sp, #4]
  400496:	2900      	cmp	r1, #0
  400498:	d1f9      	bne.n	40048e <aat31xx_disable_backlight+0x16>
	}
}
  40049a:	b002      	add	sp, #8
  40049c:	4770      	bx	lr
  40049e:	bf00      	nop

004004a0 <ili93xx_write_ram_prepare>:
/**
 * \brief Prepare to write GRAM data for ili93xx.
 */
static void ili93xx_write_ram_prepare(void)
{
	if (g_uc_device_type == DEVICE_TYPE_ILI9325) {
  4004a0:	f640 432c 	movw	r3, #3116	; 0xc2c
  4004a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4004a8:	7818      	ldrb	r0, [r3, #0]
  4004aa:	2801      	cmp	r0, #1
  4004ac:	d108      	bne.n	4004c0 <ili93xx_write_ram_prepare+0x20>
/** Define EBI access for ILI93xx 8-bit System Interface.*/
#if defined(BOARD_ILI93XX_ADDR) && defined (BOARD_ILI93XX_RS)
static inline void LCD_IR(uint8_t lcd_index)
{
	/** ILI9325 index register address */
	*((volatile uint8_t *)(BOARD_ILI93XX_ADDR)) = lcd_index;
  4004ae:	f04f 41c2 	mov.w	r1, #1627389952	; 0x61000000
  4004b2:	f04f 0200 	mov.w	r2, #0
  4004b6:	700a      	strb	r2, [r1, #0]
  4004b8:	f04f 0322 	mov.w	r3, #34	; 0x22
  4004bc:	700b      	strb	r3, [r1, #0]
  4004be:	4770      	bx	lr
		/** Write Data to GRAM (R22h) */
		LCD_IR(0);
		LCD_IR(ILI9325_GRAM_DATA_REG);
	} else if (g_uc_device_type == DEVICE_TYPE_ILI9341) {
  4004c0:	2802      	cmp	r0, #2
  4004c2:	d10a      	bne.n	4004da <ili93xx_write_ram_prepare+0x3a>
  4004c4:	f04f 41c2 	mov.w	r1, #1627389952	; 0x61000000
  4004c8:	f04f 022c 	mov.w	r2, #44	; 0x2c
  4004cc:	700a      	strb	r2, [r1, #0]
  4004ce:	f04f 0300 	mov.w	r3, #0
  4004d2:	700b      	strb	r3, [r1, #0]
  4004d4:	f04f 003c 	mov.w	r0, #60	; 0x3c
  4004d8:	7008      	strb	r0, [r1, #0]
  4004da:	4770      	bx	lr

004004dc <ili93xx_write_ram>:
 *
 * \param ul_color 24-bits RGB color.
 */
static void ili93xx_write_ram(ili93xx_color_t ul_color)
{
	LCD_WD((ul_color >> 16) & 0xFF);
  4004dc:	f3c0 4207 	ubfx	r2, r0, #16, #8
}

static inline void LCD_WD(uint8_t lcd_data)
{
	*((volatile uint8_t *)((BOARD_ILI93XX_ADDR) | (BOARD_ILI93XX_RS))) =
  4004e0:	f04f 0302 	mov.w	r3, #2
  4004e4:	f2c6 1300 	movt	r3, #24832	; 0x6100
  4004e8:	701a      	strb	r2, [r3, #0]
	LCD_WD((ul_color >> 8) & 0xFF);
  4004ea:	f3c0 2107 	ubfx	r1, r0, #8, #8
  4004ee:	7019      	strb	r1, [r3, #0]
	LCD_WD(ul_color & 0xFF);
  4004f0:	b2c0      	uxtb	r0, r0
  4004f2:	7018      	strb	r0, [r3, #0]
  4004f4:	4770      	bx	lr
  4004f6:	bf00      	nop

004004f8 <ili93xx_write_ram_buffer>:
 * \param p_ul_buf data buffer.
 * \param ul_size size in pixels.
 */
static void ili93xx_write_ram_buffer(const ili93xx_color_t *p_ul_buf,
		uint32_t ul_size)
{
  4004f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4004fc:	4681      	mov	r9, r0
  4004fe:	4688      	mov	r8, r1
	uint32_t ul_addr;
	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  400500:	f031 0a07 	bics.w	sl, r1, #7
  400504:	d04f      	beq.n	4005a6 <ili93xx_write_ram_buffer+0xae>
  400506:	4605      	mov	r5, r0
		ili93xx_write_ram(p_ul_buf[ul_addr]);
  400508:	f240 44dd 	movw	r4, #1245	; 0x4dd
  40050c:	f2c0 0440 	movt	r4, #64	; 0x40
  400510:	f10a 33ff 	add.w	r3, sl, #4294967295
  400514:	f3c3 06c0 	ubfx	r6, r3, #3, #1
  400518:	6800      	ldr	r0, [r0, #0]
  40051a:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 1]);
  40051c:	f8d9 0004 	ldr.w	r0, [r9, #4]
  400520:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 2]);
  400522:	f8d9 0008 	ldr.w	r0, [r9, #8]
  400526:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 3]);
  400528:	f8d9 000c 	ldr.w	r0, [r9, #12]
  40052c:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
  40052e:	f8d9 0010 	ldr.w	r0, [r9, #16]
  400532:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
  400534:	f8d9 0014 	ldr.w	r0, [r9, #20]
  400538:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
  40053a:	f8d9 0018 	ldr.w	r0, [r9, #24]
  40053e:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
  400540:	f8d9 001c 	ldr.w	r0, [r9, #28]
  400544:	47a0      	blx	r4
 */
static void ili93xx_write_ram_buffer(const ili93xx_color_t *p_ul_buf,
		uint32_t ul_size)
{
	uint32_t ul_addr;
	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  400546:	f04f 0708 	mov.w	r7, #8
  40054a:	f105 0520 	add.w	r5, r5, #32
  40054e:	4557      	cmp	r7, sl
  400550:	d35d      	bcc.n	40060e <ili93xx_write_ram_buffer+0x116>
  400552:	e02a      	b.n	4005aa <ili93xx_write_ram_buffer+0xb2>
		ili93xx_write_ram(p_ul_buf[ul_addr]);
  400554:	6828      	ldr	r0, [r5, #0]
  400556:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 1]);
  400558:	6868      	ldr	r0, [r5, #4]
  40055a:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 2]);
  40055c:	68a8      	ldr	r0, [r5, #8]
  40055e:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 3]);
  400560:	68e8      	ldr	r0, [r5, #12]
  400562:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
  400564:	6928      	ldr	r0, [r5, #16]
  400566:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
  400568:	6968      	ldr	r0, [r5, #20]
  40056a:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
  40056c:	69a8      	ldr	r0, [r5, #24]
  40056e:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
  400570:	69e8      	ldr	r0, [r5, #28]
  400572:	47a0      	blx	r4
  400574:	f105 0620 	add.w	r6, r5, #32
static void ili93xx_write_ram_buffer(const ili93xx_color_t *p_ul_buf,
		uint32_t ul_size)
{
	uint32_t ul_addr;
	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
		ili93xx_write_ram(p_ul_buf[ul_addr]);
  400578:	6a28      	ldr	r0, [r5, #32]
  40057a:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 1]);
  40057c:	6a68      	ldr	r0, [r5, #36]	; 0x24
  40057e:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 2]);
  400580:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  400582:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 3]);
  400584:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
  400586:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
  400588:	6b28      	ldr	r0, [r5, #48]	; 0x30
  40058a:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
  40058c:	6b68      	ldr	r0, [r5, #52]	; 0x34
  40058e:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
  400590:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  400592:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
  400594:	6be8      	ldr	r0, [r5, #60]	; 0x3c
  400596:	47a0      	blx	r4
 */
static void ili93xx_write_ram_buffer(const ili93xx_color_t *p_ul_buf,
		uint32_t ul_size)
{
	uint32_t ul_addr;
	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  400598:	f107 0710 	add.w	r7, r7, #16
  40059c:	f105 0540 	add.w	r5, r5, #64	; 0x40
  4005a0:	4557      	cmp	r7, sl
  4005a2:	d3d7      	bcc.n	400554 <ili93xx_write_ram_buffer+0x5c>
  4005a4:	e001      	b.n	4005aa <ili93xx_write_ram_buffer+0xb2>
  4005a6:	f04f 0700 	mov.w	r7, #0
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  4005aa:	45b8      	cmp	r8, r7
  4005ac:	d922      	bls.n	4005f4 <ili93xx_write_ram_buffer+0xfc>
 * \brief Write multiple data in buffer to LCD controller for ili93xx.
 *
 * \param p_ul_buf data buffer.
 * \param ul_size size in pixels.
 */
static void ili93xx_write_ram_buffer(const ili93xx_color_t *p_ul_buf,
  4005ae:	f107 34ff 	add.w	r4, r7, #4294967295
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
		ili93xx_write_ram(p_ul_buf[ul_addr]);
  4005b2:	f240 46dd 	movw	r6, #1245	; 0x4dd
  4005b6:	f2c0 0640 	movt	r6, #64	; 0x40
  4005ba:	ea6f 0007 	mvn.w	r0, r7
  4005be:	eb00 0108 	add.w	r1, r0, r8
  4005c2:	f001 0501 	and.w	r5, r1, #1
  4005c6:	eb09 0484 	add.w	r4, r9, r4, lsl #2
  4005ca:	f854 0f04 	ldr.w	r0, [r4, #4]!
  4005ce:	47b0      	blx	r6
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  4005d0:	f107 0701 	add.w	r7, r7, #1
  4005d4:	45b8      	cmp	r8, r7
  4005d6:	d80f      	bhi.n	4005f8 <ili93xx_write_ram_buffer+0x100>
  4005d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4005dc:	f104 0504 	add.w	r5, r4, #4
		ili93xx_write_ram(p_ul_buf[ul_addr]);
  4005e0:	6860      	ldr	r0, [r4, #4]
  4005e2:	47b0      	blx	r6
  4005e4:	f104 0408 	add.w	r4, r4, #8
  4005e8:	6868      	ldr	r0, [r5, #4]
  4005ea:	47b0      	blx	r6
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  4005ec:	f107 0702 	add.w	r7, r7, #2
  4005f0:	45b8      	cmp	r8, r7
  4005f2:	d8f3      	bhi.n	4005dc <ili93xx_write_ram_buffer+0xe4>
  4005f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4005f8:	2d00      	cmp	r5, #0
  4005fa:	d0ef      	beq.n	4005dc <ili93xx_write_ram_buffer+0xe4>
		ili93xx_write_ram(p_ul_buf[ul_addr]);
  4005fc:	f854 0f04 	ldr.w	r0, [r4, #4]!
  400600:	47b0      	blx	r6
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  400602:	f107 0701 	add.w	r7, r7, #1
  400606:	45b8      	cmp	r8, r7
  400608:	d8e8      	bhi.n	4005dc <ili93xx_write_ram_buffer+0xe4>
  40060a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40060e:	2e00      	cmp	r6, #0
  400610:	d0a0      	beq.n	400554 <ili93xx_write_ram_buffer+0x5c>
static void ili93xx_write_ram_buffer(const ili93xx_color_t *p_ul_buf,
		uint32_t ul_size)
{
	uint32_t ul_addr;
	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
		ili93xx_write_ram(p_ul_buf[ul_addr]);
  400612:	6828      	ldr	r0, [r5, #0]
  400614:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 1]);
  400616:	6868      	ldr	r0, [r5, #4]
  400618:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 2]);
  40061a:	68a8      	ldr	r0, [r5, #8]
  40061c:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 3]);
  40061e:	68e8      	ldr	r0, [r5, #12]
  400620:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 4]);
  400622:	6928      	ldr	r0, [r5, #16]
  400624:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 5]);
  400626:	6968      	ldr	r0, [r5, #20]
  400628:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 6]);
  40062a:	69a8      	ldr	r0, [r5, #24]
  40062c:	47a0      	blx	r4
		ili93xx_write_ram(p_ul_buf[ul_addr + 7]);
  40062e:	69e8      	ldr	r0, [r5, #28]
  400630:	47a0      	blx	r4
 */
static void ili93xx_write_ram_buffer(const ili93xx_color_t *p_ul_buf,
		uint32_t ul_size)
{
	uint32_t ul_addr;
	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  400632:	f107 0708 	add.w	r7, r7, #8
  400636:	f105 0520 	add.w	r5, r5, #32
  40063a:	4557      	cmp	r7, sl
  40063c:	d38a      	bcc.n	400554 <ili93xx_write_ram_buffer+0x5c>
  40063e:	e7b4      	b.n	4005aa <ili93xx_write_ram_buffer+0xb2>

00400640 <ili93xx_write_register_word>:
/** Define EBI access for ILI93xx 8-bit System Interface.*/
#if defined(BOARD_ILI93XX_ADDR) && defined (BOARD_ILI93XX_RS)
static inline void LCD_IR(uint8_t lcd_index)
{
	/** ILI9325 index register address */
	*((volatile uint8_t *)(BOARD_ILI93XX_ADDR)) = lcd_index;
  400640:	f04f 43c2 	mov.w	r3, #1627389952	; 0x61000000
  400644:	f04f 0200 	mov.w	r2, #0
  400648:	701a      	strb	r2, [r3, #0]
  40064a:	7018      	strb	r0, [r3, #0]
 */
static void ili93xx_write_register_word(uint8_t uc_reg, uint16_t us_data)
{
	LCD_IR(0);
	LCD_IR(uc_reg);
	LCD_WD((us_data >> 8) & 0xFF);
  40064c:	ea4f 2011 	mov.w	r0, r1, lsr #8
}

static inline void LCD_WD(uint8_t lcd_data)
{
	*((volatile uint8_t *)((BOARD_ILI93XX_ADDR) | (BOARD_ILI93XX_RS))) =
  400650:	f04f 0302 	mov.w	r3, #2
  400654:	f2c6 1300 	movt	r3, #24832	; 0x6100
  400658:	7018      	strb	r0, [r3, #0]
	LCD_WD(us_data & 0xFF);
  40065a:	b2c9      	uxtb	r1, r1
  40065c:	7019      	strb	r1, [r3, #0]
  40065e:	4770      	bx	lr

00400660 <ili93xx_write_register>:
 * \param uc_reg register address.
 * \param us_data data to be written.
 */
static void ili93xx_write_register(uint8_t uc_reg, uint8_t *p_data,
		uint8_t uc_datacnt)
{
  400660:	b430      	push	{r4, r5}
/** Define EBI access for ILI93xx 8-bit System Interface.*/
#if defined(BOARD_ILI93XX_ADDR) && defined (BOARD_ILI93XX_RS)
static inline void LCD_IR(uint8_t lcd_index)
{
	/** ILI9325 index register address */
	*((volatile uint8_t *)(BOARD_ILI93XX_ADDR)) = lcd_index;
  400662:	f04f 43c2 	mov.w	r3, #1627389952	; 0x61000000
  400666:	f04f 0400 	mov.w	r4, #0
  40066a:	701c      	strb	r4, [r3, #0]
  40066c:	7018      	strb	r0, [r3, #0]
	LCD_IR(0);
	LCD_IR(uc_reg);
	for (uint8_t i = 0; i < uc_datacnt; i++) {
  40066e:	4615      	mov	r5, r2
  400670:	b1d2      	cbz	r2, 4006a8 <ili93xx_write_register+0x48>
}

static inline void LCD_WD(uint8_t lcd_data)
{
	*((volatile uint8_t *)((BOARD_ILI93XX_ADDR) | (BOARD_ILI93XX_RS))) =
  400672:	f04f 0002 	mov.w	r0, #2
  400676:	f2c6 1000 	movt	r0, #24832	; 0x6100
  40067a:	4623      	mov	r3, r4
  40067c:	f102 32ff 	add.w	r2, r2, #4294967295
  400680:	f002 0401 	and.w	r4, r2, #1
		LCD_WD(p_data[i]);
  400684:	5cca      	ldrb	r2, [r1, r3]
  400686:	7002      	strb	r2, [r0, #0]
static void ili93xx_write_register(uint8_t uc_reg, uint8_t *p_data,
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);
	for (uint8_t i = 0; i < uc_datacnt; i++) {
  400688:	f103 0301 	add.w	r3, r3, #1
  40068c:	2d01      	cmp	r5, #1
  40068e:	d80d      	bhi.n	4006ac <ili93xx_write_register+0x4c>
  400690:	e00a      	b.n	4006a8 <ili93xx_write_register+0x48>
		LCD_WD(p_data[i]);
  400692:	5ccc      	ldrb	r4, [r1, r3]
  400694:	7004      	strb	r4, [r0, #0]
static void ili93xx_write_register(uint8_t uc_reg, uint8_t *p_data,
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);
	for (uint8_t i = 0; i < uc_datacnt; i++) {
  400696:	f103 0301 	add.w	r3, r3, #1
		LCD_WD(p_data[i]);
  40069a:	5cca      	ldrb	r2, [r1, r3]
  40069c:	7002      	strb	r2, [r0, #0]
  40069e:	f103 0301 	add.w	r3, r3, #1
static void ili93xx_write_register(uint8_t uc_reg, uint8_t *p_data,
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);
	for (uint8_t i = 0; i < uc_datacnt; i++) {
  4006a2:	b2dc      	uxtb	r4, r3
  4006a4:	42a5      	cmp	r5, r4
  4006a6:	d8f4      	bhi.n	400692 <ili93xx_write_register+0x32>
		LCD_WD(p_data[i]);
	}
}
  4006a8:	bc30      	pop	{r4, r5}
  4006aa:	4770      	bx	lr
  4006ac:	b264      	sxtb	r4, r4
  4006ae:	2c00      	cmp	r4, #0
  4006b0:	d0ef      	beq.n	400692 <ili93xx_write_register+0x32>
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);
	for (uint8_t i = 0; i < uc_datacnt; i++) {
		LCD_WD(p_data[i]);
  4006b2:	5cca      	ldrb	r2, [r1, r3]
  4006b4:	7002      	strb	r2, [r0, #0]
  4006b6:	f103 0301 	add.w	r3, r3, #1
static void ili93xx_write_register(uint8_t uc_reg, uint8_t *p_data,
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);
	for (uint8_t i = 0; i < uc_datacnt; i++) {
  4006ba:	b2da      	uxtb	r2, r3
  4006bc:	4295      	cmp	r5, r2
  4006be:	d8e8      	bhi.n	400692 <ili93xx_write_register+0x32>
  4006c0:	e7f2      	b.n	4006a8 <ili93xx_write_register+0x48>
  4006c2:	bf00      	nop

004006c4 <ili93xx_read_register>:
 * \param p_data the pointer to the read data.
 * \param uc_datacnt the number of the read data
 */
static void ili93xx_read_register(uint8_t uc_reg, uint8_t *p_data,
		uint8_t uc_datacnt)
{
  4006c4:	b430      	push	{r4, r5}
/** Define EBI access for ILI93xx 8-bit System Interface.*/
#if defined(BOARD_ILI93XX_ADDR) && defined (BOARD_ILI93XX_RS)
static inline void LCD_IR(uint8_t lcd_index)
{
	/** ILI9325 index register address */
	*((volatile uint8_t *)(BOARD_ILI93XX_ADDR)) = lcd_index;
  4006c6:	f04f 43c2 	mov.w	r3, #1627389952	; 0x61000000
  4006ca:	f04f 0400 	mov.w	r4, #0
  4006ce:	701c      	strb	r4, [r3, #0]
  4006d0:	7018      	strb	r0, [r3, #0]
	LCD_IR(0);
	LCD_IR(uc_reg);

	for (uint8_t i = 0; i < uc_datacnt; i++) {
  4006d2:	4615      	mov	r5, r2
  4006d4:	b1d2      	cbz	r2, 40070c <ili93xx_read_register+0x48>
																lcd_data;
}

static inline uint8_t LCD_RD(void)
{
	return *((volatile uint8_t *)((BOARD_ILI93XX_ADDR) |(BOARD_ILI93XX_RS)));
  4006d6:	f04f 0002 	mov.w	r0, #2
  4006da:	f2c6 1000 	movt	r0, #24832	; 0x6100
  4006de:	4623      	mov	r3, r4
  4006e0:	f102 32ff 	add.w	r2, r2, #4294967295
  4006e4:	f002 0401 	and.w	r4, r2, #1
  4006e8:	7802      	ldrb	r2, [r0, #0]
		p_data[i] = LCD_RD();
  4006ea:	54ca      	strb	r2, [r1, r3]
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);

	for (uint8_t i = 0; i < uc_datacnt; i++) {
  4006ec:	f103 0301 	add.w	r3, r3, #1
  4006f0:	2d01      	cmp	r5, #1
  4006f2:	d80d      	bhi.n	400710 <ili93xx_read_register+0x4c>
  4006f4:	e00a      	b.n	40070c <ili93xx_read_register+0x48>
  4006f6:	7804      	ldrb	r4, [r0, #0]
		p_data[i] = LCD_RD();
  4006f8:	54cc      	strb	r4, [r1, r3]
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);

	for (uint8_t i = 0; i < uc_datacnt; i++) {
  4006fa:	f103 0301 	add.w	r3, r3, #1
  4006fe:	7802      	ldrb	r2, [r0, #0]
		p_data[i] = LCD_RD();
  400700:	54ca      	strb	r2, [r1, r3]
  400702:	f103 0301 	add.w	r3, r3, #1
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);

	for (uint8_t i = 0; i < uc_datacnt; i++) {
  400706:	b2dc      	uxtb	r4, r3
  400708:	42a5      	cmp	r5, r4
  40070a:	d8f4      	bhi.n	4006f6 <ili93xx_read_register+0x32>
		p_data[i] = LCD_RD();
	}
}
  40070c:	bc30      	pop	{r4, r5}
  40070e:	4770      	bx	lr
  400710:	b264      	sxtb	r4, r4
  400712:	2c00      	cmp	r4, #0
  400714:	d0ef      	beq.n	4006f6 <ili93xx_read_register+0x32>
  400716:	7802      	ldrb	r2, [r0, #0]
{
	LCD_IR(0);
	LCD_IR(uc_reg);

	for (uint8_t i = 0; i < uc_datacnt; i++) {
		p_data[i] = LCD_RD();
  400718:	54ca      	strb	r2, [r1, r3]
  40071a:	f103 0301 	add.w	r3, r3, #1
		uint8_t uc_datacnt)
{
	LCD_IR(0);
	LCD_IR(uc_reg);

	for (uint8_t i = 0; i < uc_datacnt; i++) {
  40071e:	b2da      	uxtb	r2, r3
  400720:	4295      	cmp	r5, r2
  400722:	d8e8      	bhi.n	4006f6 <ili93xx_read_register+0x32>
  400724:	e7f2      	b.n	40070c <ili93xx_read_register+0x48>
  400726:	bf00      	nop

00400728 <ili93xx_delay>:

/**
 * \brief Delay function.
 */
static void ili93xx_delay(uint32_t ul_ms)
{
  400728:	b082      	sub	sp, #8
	volatile uint32_t i;

	for (i = 0; i < ul_ms; i++) {
  40072a:	f04f 0300 	mov.w	r3, #0
  40072e:	9301      	str	r3, [sp, #4]
  400730:	9901      	ldr	r1, [sp, #4]
  400732:	4288      	cmp	r0, r1
  400734:	d917      	bls.n	400766 <ili93xx_delay+0x3e>
		for (i = 0; i < 100000; i++) {
  400736:	f04f 0100 	mov.w	r1, #0
  40073a:	f248 629f 	movw	r2, #34463	; 0x869f
  40073e:	f2c0 0201 	movt	r2, #1
  400742:	9101      	str	r1, [sp, #4]
  400744:	9b01      	ldr	r3, [sp, #4]
  400746:	4293      	cmp	r3, r2
  400748:	d806      	bhi.n	400758 <ili93xx_delay+0x30>
  40074a:	9b01      	ldr	r3, [sp, #4]
  40074c:	f103 0301 	add.w	r3, r3, #1
  400750:	9301      	str	r3, [sp, #4]
  400752:	9b01      	ldr	r3, [sp, #4]
  400754:	4293      	cmp	r3, r2
  400756:	d9f8      	bls.n	40074a <ili93xx_delay+0x22>
 */
static void ili93xx_delay(uint32_t ul_ms)
{
	volatile uint32_t i;

	for (i = 0; i < ul_ms; i++) {
  400758:	9b01      	ldr	r3, [sp, #4]
  40075a:	f103 0301 	add.w	r3, r3, #1
  40075e:	9301      	str	r3, [sp, #4]
  400760:	9b01      	ldr	r3, [sp, #4]
  400762:	4283      	cmp	r3, r0
  400764:	d3ed      	bcc.n	400742 <ili93xx_delay+0x1a>
		for (i = 0; i < 100000; i++) {
		}
	}
}
  400766:	b002      	add	sp, #8
  400768:	4770      	bx	lr
  40076a:	bf00      	nop

0040076c <ili93xx_check_box_coordinates>:
 * \param p_ul_x2 X coordinate of lower-right corner on LCD.
 * \param p_ul_y2 Y coordinate of lower-right corner on LCD.
 */
static void ili93xx_check_box_coordinates(uint32_t *p_ul_x1, uint32_t *p_ul_y1,
		uint32_t *p_ul_x2, uint32_t *p_ul_y2)
{
  40076c:	b430      	push	{r4, r5}
	uint32_t dw;

	if (*p_ul_x1 >= g_ul_lcd_x_length) {
  40076e:	f240 0400 	movw	r4, #0
  400772:	f2c2 0400 	movt	r4, #8192	; 0x2000
  400776:	6824      	ldr	r4, [r4, #0]
  400778:	6805      	ldr	r5, [r0, #0]
  40077a:	42a5      	cmp	r5, r4
		*p_ul_x1 = g_ul_lcd_x_length - 1;
  40077c:	bf24      	itt	cs
  40077e:	f104 35ff 	addcs.w	r5, r4, #4294967295
  400782:	6005      	strcs	r5, [r0, #0]
	}

	if (*p_ul_x2 >= g_ul_lcd_x_length) {
  400784:	6815      	ldr	r5, [r2, #0]
  400786:	42ac      	cmp	r4, r5
		*p_ul_x2 = g_ul_lcd_x_length - 1;
  400788:	bf9c      	itt	ls
  40078a:	f104 34ff 	addls.w	r4, r4, #4294967295
  40078e:	6014      	strls	r4, [r2, #0]
	}

	if (*p_ul_y1 >= g_ul_lcd_y_length) {
  400790:	f240 0404 	movw	r4, #4
  400794:	f2c2 0400 	movt	r4, #8192	; 0x2000
  400798:	6824      	ldr	r4, [r4, #0]
  40079a:	680d      	ldr	r5, [r1, #0]
  40079c:	42a5      	cmp	r5, r4
		*p_ul_y1 = g_ul_lcd_y_length - 1;
  40079e:	bf24      	itt	cs
  4007a0:	f104 35ff 	addcs.w	r5, r4, #4294967295
  4007a4:	600d      	strcs	r5, [r1, #0]
	}

	if (*p_ul_y2 >= g_ul_lcd_y_length) {
  4007a6:	681d      	ldr	r5, [r3, #0]
  4007a8:	42ac      	cmp	r4, r5
		*p_ul_y2 = g_ul_lcd_y_length - 1;
  4007aa:	bf9c      	itt	ls
  4007ac:	f104 34ff 	addls.w	r4, r4, #4294967295
  4007b0:	601c      	strls	r4, [r3, #0]
	}

	if (*p_ul_x1 > *p_ul_x2) {
  4007b2:	6804      	ldr	r4, [r0, #0]
  4007b4:	6815      	ldr	r5, [r2, #0]
  4007b6:	42ac      	cmp	r4, r5
		dw = *p_ul_x1;
		*p_ul_x1 = *p_ul_x2;
  4007b8:	bf84      	itt	hi
  4007ba:	6005      	strhi	r5, [r0, #0]
		*p_ul_x2 = dw;
  4007bc:	6014      	strhi	r4, [r2, #0]
	}

	if (*p_ul_y1 > *p_ul_y2) {
  4007be:	680a      	ldr	r2, [r1, #0]
  4007c0:	6818      	ldr	r0, [r3, #0]
  4007c2:	4282      	cmp	r2, r0
		dw = *p_ul_y1;
		*p_ul_y1 = *p_ul_y2;
  4007c4:	bf84      	itt	hi
  4007c6:	6008      	strhi	r0, [r1, #0]
		*p_ul_y2 = dw;
  4007c8:	601a      	strhi	r2, [r3, #0]
	}
}
  4007ca:	bc30      	pop	{r4, r5}
  4007cc:	4770      	bx	lr
  4007ce:	bf00      	nop

004007d0 <ili93xx_device_type_identify>:
 *        ILI9341 device ID locates in Read ID4 (RD3h) register.
 *
 * \return 0 if secceed in identifying device; otherwise fails.
 */
uint8_t ili93xx_device_type_identify(void)
{
  4007d0:	b500      	push	{lr}
  4007d2:	b083      	sub	sp, #12
	uint8_t paratable[6];
	uint16_t chipid;

	/** Read ID4 (RD4h) register to get device code for ILI9341*/
	ili93xx_read_register(ILI9341_CMD_READ_ID4, paratable, 4);
  4007d4:	f04f 00d3 	mov.w	r0, #211	; 0xd3
  4007d8:	4669      	mov	r1, sp
  4007da:	f04f 0204 	mov.w	r2, #4
  4007de:	f240 63c5 	movw	r3, #1733	; 0x6c5
  4007e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4007e6:	4798      	blx	r3
	chipid = ((uint16_t)paratable[2] << 8) + paratable[3];
  4007e8:	f89d 2002 	ldrb.w	r2, [sp, #2]
  4007ec:	f89d 0003 	ldrb.w	r0, [sp, #3]
  4007f0:	eb00 2102 	add.w	r1, r0, r2, lsl #8

	if (chipid == ILI9341_DEVICE_CODE) {
  4007f4:	b28a      	uxth	r2, r1
  4007f6:	f249 3341 	movw	r3, #37697	; 0x9341
  4007fa:	429a      	cmp	r2, r3
  4007fc:	d109      	bne.n	400812 <ili93xx_device_type_identify+0x42>
		g_uc_device_type = DEVICE_TYPE_ILI9341;
  4007fe:	f640 402c 	movw	r0, #3116	; 0xc2c
  400802:	f2c2 0000 	movt	r0, #8192	; 0x2000
  400806:	f04f 0302 	mov.w	r3, #2
  40080a:	7003      	strb	r3, [r0, #0]
		return 0;
  40080c:	f04f 0000 	mov.w	r0, #0
  400810:	e020      	b.n	400854 <ili93xx_device_type_identify+0x84>
	}

	/** Driver Code Read (R00h) for ILI9325*/
	ili93xx_read_register(ILI9325_DEVICE_CODE_REG, paratable, 2);
  400812:	f04f 0000 	mov.w	r0, #0
  400816:	4669      	mov	r1, sp
  400818:	f04f 0202 	mov.w	r2, #2
  40081c:	f240 63c5 	movw	r3, #1733	; 0x6c5
  400820:	f2c0 0340 	movt	r3, #64	; 0x40
  400824:	4798      	blx	r3
	chipid = ((uint16_t)paratable[0] << 8) + paratable[1];
  400826:	f89d 0000 	ldrb.w	r0, [sp]
  40082a:	f89d 1001 	ldrb.w	r1, [sp, #1]
  40082e:	eb01 2200 	add.w	r2, r1, r0, lsl #8
	if (chipid == ILI9325_DEVICE_CODE) {
  400832:	b290      	uxth	r0, r2
  400834:	f249 3325 	movw	r3, #37669	; 0x9325
  400838:	4298      	cmp	r0, r3
  40083a:	d109      	bne.n	400850 <ili93xx_device_type_identify+0x80>
		g_uc_device_type = DEVICE_TYPE_ILI9325;
  40083c:	f640 412c 	movw	r1, #3116	; 0xc2c
  400840:	f2c2 0100 	movt	r1, #8192	; 0x2000
  400844:	f04f 0201 	mov.w	r2, #1
  400848:	700a      	strb	r2, [r1, #0]
		return 0;
  40084a:	f04f 0000 	mov.w	r0, #0
  40084e:	e001      	b.n	400854 <ili93xx_device_type_identify+0x84>
	}

	return 1;
  400850:	f04f 0001 	mov.w	r0, #1
}
  400854:	b003      	add	sp, #12
  400856:	bd00      	pop	{pc}

00400858 <ili93xx_display_on>:

/**
 * \brief Turn on the LCD.
 */
void ili93xx_display_on(void)
{
  400858:	b508      	push	{r3, lr}
	if (g_uc_device_type == DEVICE_TYPE_ILI9325) {
  40085a:	f640 432c 	movw	r3, #3116	; 0xc2c
  40085e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400862:	7818      	ldrb	r0, [r3, #0]
  400864:	2801      	cmp	r0, #1
  400866:	d109      	bne.n	40087c <ili93xx_display_on+0x24>
		ili93xx_write_register_word(ILI9325_DISP_CTRL1,
  400868:	f04f 0007 	mov.w	r0, #7
  40086c:	f240 1133 	movw	r1, #307	; 0x133
  400870:	f240 6241 	movw	r2, #1601	; 0x641
  400874:	f2c0 0240 	movt	r2, #64	; 0x40
  400878:	4790      	blx	r2
  40087a:	bd08      	pop	{r3, pc}
				ILI9325_DISP_CTRL1_BASEE |
				ILI9325_DISP_CTRL1_GON |
				ILI9325_DISP_CTRL1_DTE |
				ILI9325_DISP_CTRL1_D(0x03));
	} else if (g_uc_device_type == DEVICE_TYPE_ILI9341) {
  40087c:	2802      	cmp	r0, #2
  40087e:	d109      	bne.n	400894 <ili93xx_display_on+0x3c>
		ili93xx_write_register(ILI9341_CMD_DISPLAY_ON, NULL, 0);
  400880:	f04f 0029 	mov.w	r0, #41	; 0x29
  400884:	f04f 0100 	mov.w	r1, #0
  400888:	460a      	mov	r2, r1
  40088a:	f240 6361 	movw	r3, #1633	; 0x661
  40088e:	f2c0 0340 	movt	r3, #64	; 0x40
  400892:	4798      	blx	r3
  400894:	bd08      	pop	{r3, pc}
  400896:	bf00      	nop

00400898 <ili93xx_set_foreground_color>:
 * \brief Set foreground color.
 *
 * \param ul_color foreground color.
 */
void ili93xx_set_foreground_color(ili93xx_color_t ul_color)
{
  400898:	f640 016c 	movw	r1, #2156	; 0x86c
  40089c:	f2c2 0100 	movt	r1, #8192	; 0x2000
  4008a0:	f1a1 0304 	sub.w	r3, r1, #4
/**
 * \brief Set foreground color.
 *
 * \param ul_color foreground color.
 */
void ili93xx_set_foreground_color(ili93xx_color_t ul_color)
  4008a4:	f501 716f 	add.w	r1, r1, #956	; 0x3bc
  4008a8:	f103 0204 	add.w	r2, r3, #4
{
	uint32_t i;

	/** Fill the cache with selected color */
	for (i = 0; i < LCD_DATA_CACHE_SIZE; ++i) {
		g_ul_pixel_cache[i] = ul_color;
  4008ac:	6058      	str	r0, [r3, #4]
  4008ae:	f103 0308 	add.w	r3, r3, #8
  4008b2:	6050      	str	r0, [r2, #4]
void ili93xx_set_foreground_color(ili93xx_color_t ul_color)
{
	uint32_t i;

	/** Fill the cache with selected color */
	for (i = 0; i < LCD_DATA_CACHE_SIZE; ++i) {
  4008b4:	428b      	cmp	r3, r1
  4008b6:	d1f7      	bne.n	4008a8 <ili93xx_set_foreground_color+0x10>
		g_ul_pixel_cache[i] = ul_color;
	}
}
  4008b8:	4770      	bx	lr
  4008ba:	bf00      	nop

004008bc <ili93xx_set_window>:
 * \param ul_width The width of the window.
 * \param ul_height The height of the window.
 */
void ili93xx_set_window(uint32_t ul_x, uint32_t ul_y, uint32_t ul_width,
		uint32_t ul_height)
{
  4008bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4008c0:	b082      	sub	sp, #8
  4008c2:	460d      	mov	r5, r1
  4008c4:	4617      	mov	r7, r2
  4008c6:	461e      	mov	r6, r3
	Assert(ul_x <= (g_ul_lcd_x_length - 1));
	Assert(ul_y <= (g_ul_lcd_y_length - 1));
	Assert(ul_width <= (g_ul_lcd_x_length - ul_x));
	Assert(ul_height <= (g_ul_lcd_y_length - ul_y));
	if (g_uc_device_type == DEVICE_TYPE_ILI9325) {
  4008c8:	f640 442c 	movw	r4, #3116	; 0xc2c
  4008cc:	f2c2 0400 	movt	r4, #8192	; 0x2000
  4008d0:	7824      	ldrb	r4, [r4, #0]
  4008d2:	2c01      	cmp	r4, #1
  4008d4:	d11e      	bne.n	400914 <ili93xx_set_window+0x58>
		/** Set Horizontal Address Start Position */
		ili93xx_write_register_word(ILI9325_HORIZONTAL_ADDR_START,
  4008d6:	fa1f f880 	uxth.w	r8, r0
  4008da:	f04f 0050 	mov.w	r0, #80	; 0x50
  4008de:	4641      	mov	r1, r8
  4008e0:	f240 6441 	movw	r4, #1601	; 0x641
  4008e4:	f2c0 0440 	movt	r4, #64	; 0x40
  4008e8:	47a0      	blx	r4
				(uint16_t)ul_x);

		/** Set Horizontal Address End Position */
		ili93xx_write_register_word(ILI9325_HORIZONTAL_ADDR_END,
  4008ea:	f108 38ff 	add.w	r8, r8, #4294967295
  4008ee:	eb08 0107 	add.w	r1, r8, r7
  4008f2:	f04f 0051 	mov.w	r0, #81	; 0x51
  4008f6:	b289      	uxth	r1, r1
  4008f8:	47a0      	blx	r4
				(uint16_t)(ul_x + ul_width - 1));

		/** Set Vertical Address Start Position */
		ili93xx_write_register_word(ILI9325_VERTICAL_ADDR_START,
  4008fa:	b2ad      	uxth	r5, r5
  4008fc:	f04f 0052 	mov.w	r0, #82	; 0x52
  400900:	4629      	mov	r1, r5
  400902:	47a0      	blx	r4
				(uint16_t)ul_y);

		/** Set Vertical Address End Position */
		ili93xx_write_register_word(ILI9325_VERTICAL_ADDR_END,
  400904:	f105 35ff 	add.w	r5, r5, #4294967295
  400908:	19aa      	adds	r2, r5, r6
  40090a:	f04f 0053 	mov.w	r0, #83	; 0x53
  40090e:	b291      	uxth	r1, r2
  400910:	47a0      	blx	r4
  400912:	e037      	b.n	400984 <ili93xx_set_window+0xc8>
				(uint16_t)(ul_y + ul_height - 1));
	} else if (g_uc_device_type == DEVICE_TYPE_ILI9341) {
  400914:	2c02      	cmp	r4, #2
  400916:	d135      	bne.n	400984 <ili93xx_set_window+0xc8>
		uint8_t paratable[4];

		/** Set Column Address Position */
		paratable[0] = (ul_x >> 8) & 0xFF;
  400918:	ea4f 2310 	mov.w	r3, r0, lsr #8
  40091c:	f88d 3004 	strb.w	r3, [sp, #4]
		paratable[1] = ul_x & 0xFF;
  400920:	b2c1      	uxtb	r1, r0
  400922:	f88d 1005 	strb.w	r1, [sp, #5]
		paratable[2] = ((ul_x + ul_width - 1) >> 8) & 0xFF;
  400926:	f100 30ff 	add.w	r0, r0, #4294967295
  40092a:	1882      	adds	r2, r0, r2
  40092c:	ea4f 2412 	mov.w	r4, r2, lsr #8
  400930:	f88d 4006 	strb.w	r4, [sp, #6]
		paratable[3] = (ul_x + ul_width - 1) & 0xFF;
  400934:	f101 33ff 	add.w	r3, r1, #4294967295
  400938:	19df      	adds	r7, r3, r7
  40093a:	f88d 7007 	strb.w	r7, [sp, #7]
		ili93xx_write_register(ILI9341_CMD_COLUMN_ADDRESS_SET,
  40093e:	f04f 002a 	mov.w	r0, #42	; 0x2a
  400942:	a901      	add	r1, sp, #4
  400944:	f04f 0204 	mov.w	r2, #4
  400948:	f240 6461 	movw	r4, #1633	; 0x661
  40094c:	f2c0 0440 	movt	r4, #64	; 0x40
  400950:	47a0      	blx	r4
				paratable, 4);

		/** Set Page Address Position */
		paratable[0] = (ul_y >> 8) & 0xFF;
  400952:	ea4f 2115 	mov.w	r1, r5, lsr #8
  400956:	f88d 1004 	strb.w	r1, [sp, #4]
		paratable[1] = ul_y & 0xFF;
  40095a:	b2e8      	uxtb	r0, r5
  40095c:	f88d 0005 	strb.w	r0, [sp, #5]
		paratable[2] = ((ul_y + ul_height - 1) >> 8) & 0xFF;
  400960:	f105 35ff 	add.w	r5, r5, #4294967295
  400964:	19aa      	adds	r2, r5, r6
  400966:	ea4f 2512 	mov.w	r5, r2, lsr #8
  40096a:	f88d 5006 	strb.w	r5, [sp, #6]
		paratable[3] = (ul_y + ul_height - 1) & 0xFF;
  40096e:	f100 33ff 	add.w	r3, r0, #4294967295
  400972:	199e      	adds	r6, r3, r6
  400974:	f88d 6007 	strb.w	r6, [sp, #7]
		ili93xx_write_register(ILI9341_CMD_PAGE_ADDRESS_SET,
  400978:	f04f 002b 	mov.w	r0, #43	; 0x2b
  40097c:	a901      	add	r1, sp, #4
  40097e:	f04f 0204 	mov.w	r2, #4
  400982:	47a0      	blx	r4
				       paratable, 4);
	}
}
  400984:	b002      	add	sp, #8
  400986:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40098a:	bf00      	nop

0040098c <ili93xx_set_cursor_position>:
 *
 * \param us_x X coordinate of upper-left corner on LCD.
 * \param us_y Y coordinate of upper-left corner on LCD.
 */
void ili93xx_set_cursor_position(uint16_t us_x, uint16_t us_y)
{
  40098c:	b538      	push	{r3, r4, r5, lr}
  40098e:	4602      	mov	r2, r0
  400990:	460c      	mov	r4, r1
	if (g_uc_device_type == DEVICE_TYPE_ILI9325) {
  400992:	f640 432c 	movw	r3, #3116	; 0xc2c
  400996:	f2c2 0300 	movt	r3, #8192	; 0x2000
  40099a:	7818      	ldrb	r0, [r3, #0]
  40099c:	2801      	cmp	r0, #1
  40099e:	d10b      	bne.n	4009b8 <ili93xx_set_cursor_position+0x2c>
		/** GRAM Horizontal/Vertical Address Set (R20h, R21h) */
		ili93xx_write_register_word(ILI9325_HORIZONTAL_GRAM_ADDR_SET, us_x);
  4009a0:	f04f 0020 	mov.w	r0, #32
  4009a4:	4611      	mov	r1, r2
  4009a6:	f240 6541 	movw	r5, #1601	; 0x641
  4009aa:	f2c0 0540 	movt	r5, #64	; 0x40
  4009ae:	47a8      	blx	r5
		ili93xx_write_register_word(ILI9325_VERTICAL_GRAM_ADDR_SET, us_y);
  4009b0:	f04f 0021 	mov.w	r0, #33	; 0x21
  4009b4:	4621      	mov	r1, r4
  4009b6:	47a8      	blx	r5
  4009b8:	bd38      	pop	{r3, r4, r5, pc}
  4009ba:	bf00      	nop

004009bc <ili93xx_init>:
 * \param p_opt pointer to ILI93xx option structure.
 *
 * \return 0 if initialization succeeds, otherwise fails.
 */
uint32_t ili93xx_init(struct ili93xx_opt_t *p_opt)
{
  4009bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4009c0:	b085      	sub	sp, #20
  4009c2:	4606      	mov	r6, r0
	uint8_t paratable[15];

	/** Identify the LCD driver device*/
	if (ili93xx_device_type_identify() != 0) {
  4009c4:	f240 73d1 	movw	r3, #2001	; 0x7d1
  4009c8:	f2c0 0340 	movt	r3, #64	; 0x40
  4009cc:	4798      	blx	r3
  4009ce:	2800      	cmp	r0, #0
  4009d0:	f040 8268 	bne.w	400ea4 <ili93xx_init+0x4e8>
		return 1;
	}

	g_ul_lcd_x_length = ILI93XX_LCD_WIDTH;
  4009d4:	f240 0000 	movw	r0, #0
  4009d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4009dc:	f04f 02f0 	mov.w	r2, #240	; 0xf0
  4009e0:	6002      	str	r2, [r0, #0]
	g_ul_lcd_y_length = ILI93XX_LCD_HEIGHT;
  4009e2:	f240 0104 	movw	r1, #4
  4009e6:	f2c2 0100 	movt	r1, #8192	; 0x2000
  4009ea:	f44f 73a0 	mov.w	r3, #320	; 0x140
  4009ee:	600b      	str	r3, [r1, #0]

	if (g_uc_device_type == DEVICE_TYPE_ILI9325) {
  4009f0:	f640 402c 	movw	r0, #3116	; 0xc2c
  4009f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
  4009f8:	7802      	ldrb	r2, [r0, #0]
  4009fa:	2a01      	cmp	r2, #1
  4009fc:	f040 8110 	bne.w	400c20 <ili93xx_init+0x264>
		/** Turn off LCD */
		ili93xx_write_register_word(ILI9325_DISP_CTRL1, ILI9325_DISP_CTRL1_GON |
  400a00:	f04f 0007 	mov.w	r0, #7
  400a04:	f04f 0133 	mov.w	r1, #51	; 0x33
  400a08:	f240 6441 	movw	r4, #1601	; 0x641
  400a0c:	f2c0 0440 	movt	r4, #64	; 0x40
  400a10:	47a0      	blx	r4
				ILI9325_DISP_CTRL1_DTE | ILI9325_DISP_CTRL1_D(0x03));

		/** Start initial sequence */
		/** Disable sleep and standby mode*/
		ili93xx_write_register_word(ILI9325_POWER_CTRL1, 0x0000);
  400a12:	f04f 0010 	mov.w	r0, #16
  400a16:	f04f 0100 	mov.w	r1, #0
  400a1a:	47a0      	blx	r4
		/** Start internal OSC */
		ili93xx_write_register_word(ILI9325_START_OSC_CTRL,
  400a1c:	f04f 0000 	mov.w	r0, #0
  400a20:	f04f 0101 	mov.w	r1, #1
  400a24:	47a0      	blx	r4
				ILI9325_START_OSC_CTRL_EN);
		/** Set SS bit and direction output from S720 to S1 */
		ili93xx_write_register_word(ILI9325_DRIVER_OUTPUT_CTRL1,
  400a26:	f04f 0001 	mov.w	r0, #1
  400a2a:	f44f 7180 	mov.w	r1, #256	; 0x100
  400a2e:	47a0      	blx	r4
				ILI9325_DRIVER_OUTPUT_CTRL1_SS);
		/** Set 1 line inversion */
		ili93xx_write_register_word(ILI9325_LCD_DRIVING_CTRL,
  400a30:	f04f 0002 	mov.w	r0, #2
  400a34:	f44f 61e0 	mov.w	r1, #1792	; 0x700
  400a38:	47a0      	blx	r4
				ILI9325_LCD_DRIVING_CTRL_BIT10 | ILI9325_LCD_DRIVING_CTRL_EOR
				| ILI9325_LCD_DRIVING_CTRL_BC0);
		/** Disable resizing feature */
		ili93xx_write_register_word(ILI9325_RESIZE_CTRL, 0x0000);
  400a3a:	f04f 0004 	mov.w	r0, #4
  400a3e:	f04f 0100 	mov.w	r1, #0
  400a42:	47a0      	blx	r4
		/** Set the back porch and front porch */
		ili93xx_write_register_word(ILI9325_DISP_CTRL2,
  400a44:	f04f 0008 	mov.w	r0, #8
  400a48:	f240 2107 	movw	r1, #519	; 0x207
  400a4c:	47a0      	blx	r4
				ILI9325_DISP_CTRL2_BP(
				0x07) | ILI9325_DISP_CTRL2_FP(0x02));
		/** Set non-display area refresh cycle ISC[3:0] */
		ili93xx_write_register_word(ILI9325_DISP_CTRL3, 0x0000);
  400a4e:	f04f 0009 	mov.w	r0, #9
  400a52:	f04f 0100 	mov.w	r1, #0
  400a56:	47a0      	blx	r4
		/** Disable FMARK function */
		ili93xx_write_register_word(ILI9325_DISP_CTRL4, 0x0000);
  400a58:	f04f 000a 	mov.w	r0, #10
  400a5c:	f04f 0100 	mov.w	r1, #0
  400a60:	47a0      	blx	r4
		/** 18-bit RGB interface and writing display data by system
		 *interface */
		ili93xx_write_register_word(ILI9325_RGB_DISP_INTERFACE_CTRL1,
  400a62:	f04f 000c 	mov.w	r0, #12
  400a66:	f04f 0100 	mov.w	r1, #0
  400a6a:	47a0      	blx	r4
				0x0000);
		/** Set the output position of frame cycle */
		ili93xx_write_register_word(ILI9325_FRAME_MAKER_POS, 0x0000);
  400a6c:	f04f 000d 	mov.w	r0, #13
  400a70:	f04f 0100 	mov.w	r1, #0
  400a74:	47a0      	blx	r4
		/** RGB interface polarity */
		ili93xx_write_register_word(ILI9325_RGB_DISP_INTERFACE_CTRL2,
  400a76:	f04f 000f 	mov.w	r0, #15
  400a7a:	f04f 0100 	mov.w	r1, #0
  400a7e:	47a0      	blx	r4
				0x0000);

		/** Power on sequence */
		/** Disable sleep and standby mode */
		ili93xx_write_register_word(ILI9325_POWER_CTRL1, 0x0000);
  400a80:	f04f 0010 	mov.w	r0, #16
  400a84:	f04f 0100 	mov.w	r1, #0
  400a88:	47a0      	blx	r4

		/**
		 * Selects the operating frequency of the step-up circuit 1,2
		 * and Sets the ratio factor of Vci.
		 */
		ili93xx_write_register_word(ILI9325_POWER_CTRL2, 0x0000);
  400a8a:	f04f 0011 	mov.w	r0, #17
  400a8e:	f04f 0100 	mov.w	r1, #0
  400a92:	47a0      	blx	r4
		/** Set VREG1OUT voltage */
		ili93xx_write_register_word(ILI9325_POWER_CTRL3, 0x0000);
  400a94:	f04f 0012 	mov.w	r0, #18
  400a98:	f04f 0100 	mov.w	r1, #0
  400a9c:	47a0      	blx	r4
		/** Set VCOM amplitude */
		ili93xx_write_register_word(ILI9325_POWER_CTRL4, 0x0000);
  400a9e:	f04f 0013 	mov.w	r0, #19
  400aa2:	f04f 0100 	mov.w	r1, #0
  400aa6:	47a0      	blx	r4
		ili93xx_delay(200);
  400aa8:	f04f 00c8 	mov.w	r0, #200	; 0xc8
  400aac:	f240 7529 	movw	r5, #1833	; 0x729
  400ab0:	f2c0 0540 	movt	r5, #64	; 0x40
  400ab4:	47a8      	blx	r5

		/**
		 * Adjusts the constant current and Sets the factor used
		 * in the step-up circuits.
		 */
		ili93xx_write_register_word(ILI9325_POWER_CTRL1,
  400ab6:	f04f 0010 	mov.w	r0, #16
  400aba:	f241 2190 	movw	r1, #4752	; 0x1290
  400abe:	47a0      	blx	r4

		/**
		 * Select the operating frequency of the step-up circuit 1,2 and
		 * Sets the ratio factor of Vci
		 */
		ili93xx_write_register_word(ILI9325_POWER_CTRL2,
  400ac0:	f04f 0011 	mov.w	r0, #17
  400ac4:	f240 2127 	movw	r1, #551	; 0x227
  400ac8:	47a0      	blx	r4
				ILI9325_POWER_CTRL2_DC1(0x02) |
				ILI9325_POWER_CTRL2_DC0(0x02) | ILI9325_POWER_CTRL2_VC(0x07));
		ili93xx_delay(50);
  400aca:	f04f 0032 	mov.w	r0, #50	; 0x32
  400ace:	47a8      	blx	r5
		/** Internal reference voltage= Vci */
		ili93xx_write_register_word(ILI9325_POWER_CTRL3,
  400ad0:	f04f 0012 	mov.w	r0, #18
  400ad4:	f04f 011b 	mov.w	r1, #27
  400ad8:	47a0      	blx	r4
				ILI9325_POWER_CTRL3_PON | ILI9325_POWER_CTRL3_VRH(0x0B));
		ili93xx_delay(50);
  400ada:	f04f 0032 	mov.w	r0, #50	; 0x32
  400ade:	47a8      	blx	r5
		/** Set VDV[4:0] for VCOM amplitude */
		ili93xx_write_register_word(ILI9325_POWER_CTRL4,
  400ae0:	f04f 0013 	mov.w	r0, #19
  400ae4:	f44f 5188 	mov.w	r1, #4352	; 0x1100
  400ae8:	47a0      	blx	r4
				ILI9325_POWER_CTRL4_VDV(0x11));
		/** Set VCM[5:0] for VCOMH */
		ili93xx_write_register_word(ILI9325_POWER_CTRL7,
  400aea:	f04f 0029 	mov.w	r0, #41	; 0x29
  400aee:	f04f 0119 	mov.w	r1, #25
  400af2:	47a0      	blx	r4
				ILI9325_POWER_CTRL7_VCM(0x19));
		/** Set Frame Rate */
		ili93xx_write_register_word(ILI9325_FRAME_RATE_AND_COLOR_CTRL,
  400af4:	f04f 002b 	mov.w	r0, #43	; 0x2b
  400af8:	f04f 010d 	mov.w	r1, #13
  400afc:	47a0      	blx	r4
				ILI9325_FRAME_RATE_AND_COLOR_CTRL_FRS(0x0D));
		ili93xx_delay(50);
  400afe:	f04f 0032 	mov.w	r0, #50	; 0x32
  400b02:	47a8      	blx	r5

		/** Adjust the Gamma Curve */
		ili93xx_write_register_word(ILI9325_GAMMA_CTL1, 0x0000);
  400b04:	f04f 0030 	mov.w	r0, #48	; 0x30
  400b08:	f04f 0100 	mov.w	r1, #0
  400b0c:	47a0      	blx	r4
		ili93xx_write_register_word(ILI9325_GAMMA_CTL2,
  400b0e:	f04f 0031 	mov.w	r0, #49	; 0x31
  400b12:	f44f 7101 	mov.w	r1, #516	; 0x204
  400b16:	47a0      	blx	r4
				ILI9325_GAMMA_CTL2_KP3(0x02) |
				ILI9325_GAMMA_CTL2_KP2(0x04));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL3,
  400b18:	f04f 0032 	mov.w	r0, #50	; 0x32
  400b1c:	f44f 7100 	mov.w	r1, #512	; 0x200
  400b20:	47a0      	blx	r4
				ILI9325_GAMMA_CTL3_KP5(0x02) |
				ILI9325_GAMMA_CTL3_KP4(0x00));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL4,
  400b22:	f04f 0035 	mov.w	r0, #53	; 0x35
  400b26:	f04f 0107 	mov.w	r1, #7
  400b2a:	47a0      	blx	r4
				ILI9325_GAMMA_CTL4_RP1(0x00) |
				ILI9325_GAMMA_CTL4_RP0(0x07));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL5,
  400b2c:	f04f 0036 	mov.w	r0, #54	; 0x36
  400b30:	f241 4104 	movw	r1, #5124	; 0x1404
  400b34:	47a0      	blx	r4
				ILI9325_GAMMA_CTL5_VRP1(0x14) |
				ILI9325_GAMMA_CTL5_VRP0(0x04));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL6,
  400b36:	f04f 0037 	mov.w	r0, #55	; 0x37
  400b3a:	f240 7105 	movw	r1, #1797	; 0x705
  400b3e:	47a0      	blx	r4
				ILI9325_GAMMA_CTL6_KN1(0x07) |
				ILI9325_GAMMA_CTL6_KN0(0x05));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL7,
  400b40:	f04f 0038 	mov.w	r0, #56	; 0x38
  400b44:	f240 3105 	movw	r1, #773	; 0x305
  400b48:	47a0      	blx	r4
				ILI9325_GAMMA_CTL7_KN3(0x03) |
				ILI9325_GAMMA_CTL7_KN2(0x05));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL8,
  400b4a:	f04f 0039 	mov.w	r0, #57	; 0x39
  400b4e:	f240 7107 	movw	r1, #1799	; 0x707
  400b52:	47a0      	blx	r4
				ILI9325_GAMMA_CTL8_KN5(0x07) |
				ILI9325_GAMMA_CTL8_KN4(0x07));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL9,
  400b54:	f04f 003c 	mov.w	r0, #60	; 0x3c
  400b58:	f240 7101 	movw	r1, #1793	; 0x701
  400b5c:	47a0      	blx	r4
				ILI9325_GAMMA_CTL9_RN1(0x07) |
				ILI9325_GAMMA_CTL9_RN0(0x01));
		ili93xx_write_register_word(ILI9325_GAMMA_CTL10,
  400b5e:	f04f 003d 	mov.w	r0, #61	; 0x3d
  400b62:	f04f 010e 	mov.w	r1, #14
  400b66:	47a0      	blx	r4
		 * DFM Set the mode of transferring data to the internal RAM
		 * when TRI = 1.
		 * I/D[1:0] = 11 Horizontal : increment Vertical : increment,
		 * AM=0:Horizontal
		 */
		ili93xx_write_register_word(ILI9325_ENTRY_MODE,
  400b68:	f04f 0003 	mov.w	r0, #3
  400b6c:	f24d 0110 	movw	r1, #53264	; 0xd010
  400b70:	47a0      	blx	r4
				ILI9325_ENTRY_MODE_ID(0x01) | ILI9325_ENTRY_MODE_BGR);
		/**
		 * Sets the number of lines to drive the LCD at an interval of 8
		 * lines. The scan direction is from G320 to G1
		 */
		ili93xx_write_register_word(ILI9325_DRIVER_OUTPUT_CTRL2,
  400b72:	f04f 0060 	mov.w	r0, #96	; 0x60
  400b76:	f44f 4127 	mov.w	r1, #42752	; 0xa700
  400b7a:	47a0      	blx	r4
				ILI9325_DRIVER_OUTPUT_CTRL2_GS |
				ILI9325_DRIVER_OUTPUT_CTRL2_NL(0x27));

		/** Vertical Scrolling */
		/** Disable scrolling and enable the grayscale inversion */
		ili93xx_write_register_word(ILI9325_BASE_IMG_DISP_CTRL,
  400b7c:	f04f 0061 	mov.w	r0, #97	; 0x61
  400b80:	f04f 0101 	mov.w	r1, #1
  400b84:	47a0      	blx	r4
				ILI9325_BASE_IMG_DISP_CTRL_REV);
		ili93xx_write_register_word(ILI9325_VERTICAL_SCROLL_CTRL,
  400b86:	f04f 006a 	mov.w	r0, #106	; 0x6a
  400b8a:	f04f 0100 	mov.w	r1, #0
  400b8e:	47a0      	blx	r4
				0x0000);

		/** Disable Partial Display */
		ili93xx_write_register_word(ILI9325_PARTIAL_IMG1_DISP_POS,
  400b90:	f04f 0080 	mov.w	r0, #128	; 0x80
  400b94:	f04f 0100 	mov.w	r1, #0
  400b98:	47a0      	blx	r4
				0x0000);
		ili93xx_write_register_word(
  400b9a:	f04f 0081 	mov.w	r0, #129	; 0x81
  400b9e:	f04f 0100 	mov.w	r1, #0
  400ba2:	47a0      	blx	r4
				ILI9325_PARTIAL_IMG1_AREA_START_LINE,
				0x0000);
		ili93xx_write_register_word(ILI9325_PARTIAL_IMG1_AREA_END_LINE,
  400ba4:	f04f 0082 	mov.w	r0, #130	; 0x82
  400ba8:	f04f 0100 	mov.w	r1, #0
  400bac:	47a0      	blx	r4
				0x0000);
		ili93xx_write_register_word(ILI9325_PARTIAL_IMG2_DISP_POS,
  400bae:	f04f 0083 	mov.w	r0, #131	; 0x83
  400bb2:	f04f 0100 	mov.w	r1, #0
  400bb6:	47a0      	blx	r4
				0x0000);
		ili93xx_write_register_word(
  400bb8:	f04f 0084 	mov.w	r0, #132	; 0x84
  400bbc:	f04f 0100 	mov.w	r1, #0
  400bc0:	47a0      	blx	r4
				ILI9325_PARTIAL_IMG2_AREA_START_LINE,
				0x0000);
		ili93xx_write_register_word(ILI9325_PARTIAL_IMG2_AREA_END_LINE,
  400bc2:	f04f 0085 	mov.w	r0, #133	; 0x85
  400bc6:	f04f 0100 	mov.w	r1, #0
  400bca:	47a0      	blx	r4
				0x0000);

		/** Panel Control */
		ili93xx_write_register_word(ILI9325_PANEL_INTERFACE_CTRL1,
  400bcc:	f04f 0090 	mov.w	r0, #144	; 0x90
  400bd0:	f04f 0110 	mov.w	r1, #16
  400bd4:	47a0      	blx	r4
				ILI9325_PANEL_INTERFACE_CTRL1_RTNI(0x10));
		ili93xx_write_register_word(ILI9325_PANEL_INTERFACE_CTRL2,
  400bd6:	f04f 0092 	mov.w	r0, #146	; 0x92
  400bda:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  400bde:	47a0      	blx	r4
				ILI9325_PANEL_INTERFACE_CTRL2_NOWI(0x06));
		ili93xx_write_register_word(ILI9325_PANEL_INTERFACE_CTRL4,
  400be0:	f04f 0095 	mov.w	r0, #149	; 0x95
  400be4:	f44f 7188 	mov.w	r1, #272	; 0x110
  400be8:	47a0      	blx	r4
				ILI9325_PANEL_INTERFACE_CTRL4_DIVE(0x01) |
				ILI9325_PANEL_INTERFACE_CTRL4_RTNE(0x10));

		ili93xx_set_window(0, 0, p_opt->ul_width, p_opt->ul_height);
  400bea:	f04f 0000 	mov.w	r0, #0
  400bee:	4601      	mov	r1, r0
  400bf0:	6832      	ldr	r2, [r6, #0]
  400bf2:	6873      	ldr	r3, [r6, #4]
  400bf4:	f640 04bd 	movw	r4, #2237	; 0x8bd
  400bf8:	f2c0 0440 	movt	r4, #64	; 0x40
  400bfc:	47a0      	blx	r4
		ili93xx_set_foreground_color(p_opt->foreground_color);
  400bfe:	68b0      	ldr	r0, [r6, #8]
  400c00:	f640 0299 	movw	r2, #2201	; 0x899
  400c04:	f2c0 0240 	movt	r2, #64	; 0x40
  400c08:	4790      	blx	r2
		ili93xx_set_cursor_position(0, 0);
  400c0a:	f04f 0000 	mov.w	r0, #0
  400c0e:	4601      	mov	r1, r0
  400c10:	f640 138d 	movw	r3, #2445	; 0x98d
  400c14:	f2c0 0340 	movt	r3, #64	; 0x40
  400c18:	4798      	blx	r3
	} else {
		/** exit with return value 1 if device type is not supported.*/
		return 1;
	}

	return 0;
  400c1a:	f04f 0000 	mov.w	r0, #0
  400c1e:	e146      	b.n	400eae <ili93xx_init+0x4f2>
				ILI9325_PANEL_INTERFACE_CTRL4_RTNE(0x10));

		ili93xx_set_window(0, 0, p_opt->ul_width, p_opt->ul_height);
		ili93xx_set_foreground_color(p_opt->foreground_color);
		ili93xx_set_cursor_position(0, 0);
	} else if (g_uc_device_type == DEVICE_TYPE_ILI9341) {
  400c20:	2a02      	cmp	r2, #2
  400c22:	f040 8142 	bne.w	400eaa <ili93xx_init+0x4ee>
		/** init for ILI9341 **/
		/** power control A configuration*/
		paratable[0] = 0x39;
  400c26:	f04f 0439 	mov.w	r4, #57	; 0x39
  400c2a:	f88d 4000 	strb.w	r4, [sp]
		paratable[1] = 0x2C;
  400c2e:	f04f 052c 	mov.w	r5, #44	; 0x2c
  400c32:	f88d 5001 	strb.w	r5, [sp, #1]
		paratable[2] = 0x00;
  400c36:	f04f 0500 	mov.w	r5, #0
  400c3a:	f88d 5002 	strb.w	r5, [sp, #2]
		paratable[3] = 0x34;
  400c3e:	f04f 0734 	mov.w	r7, #52	; 0x34
  400c42:	f88d 7003 	strb.w	r7, [sp, #3]
		paratable[4] = 0x02;
  400c46:	f04f 0902 	mov.w	r9, #2
  400c4a:	f88d 9004 	strb.w	r9, [sp, #4]
		ili93xx_write_register(ILI9341_CMD_POWER_CONTROL_A, paratable, 5);
  400c4e:	f04f 00cb 	mov.w	r0, #203	; 0xcb
  400c52:	4669      	mov	r1, sp
  400c54:	f04f 0205 	mov.w	r2, #5
  400c58:	f240 6461 	movw	r4, #1633	; 0x661
  400c5c:	f2c0 0440 	movt	r4, #64	; 0x40
  400c60:	47a0      	blx	r4

		/** power control B configuration */
		paratable[0] = 0;
  400c62:	f88d 5000 	strb.w	r5, [sp]
		paratable[1] = 0xAA;
  400c66:	f04f 01aa 	mov.w	r1, #170	; 0xaa
  400c6a:	f88d 1001 	strb.w	r1, [sp, #1]
		paratable[2] = 0xB0;
  400c6e:	f04f 03b0 	mov.w	r3, #176	; 0xb0
  400c72:	f88d 3002 	strb.w	r3, [sp, #2]
		ili93xx_write_register(ILI9341_CMD_POWER_CONTROL_B, paratable, 3);
  400c76:	f04f 00cf 	mov.w	r0, #207	; 0xcf
  400c7a:	4669      	mov	r1, sp
  400c7c:	f04f 0203 	mov.w	r2, #3
  400c80:	47a0      	blx	r4

		/** Pump Ratio Control configuration */
		paratable[0] = 0x30;
  400c82:	f04f 0030 	mov.w	r0, #48	; 0x30
  400c86:	f88d 0000 	strb.w	r0, [sp]
		ili93xx_write_register(ILI9341_CMD_PUMP_RATIO_CONTROL,
  400c8a:	f04f 00f7 	mov.w	r0, #247	; 0xf7
  400c8e:	4669      	mov	r1, sp
  400c90:	f04f 0201 	mov.w	r2, #1
  400c94:	47a0      	blx	r4
				paratable, 1);

		/** Power Control 1 configuration*/
		paratable[0] = 0x25;
  400c96:	f04f 0225 	mov.w	r2, #37	; 0x25
  400c9a:	f88d 2000 	strb.w	r2, [sp]
		ili93xx_write_register(ILI9341_CMD_POWER_CONTROL_1, paratable, 1);
  400c9e:	f04f 00c0 	mov.w	r0, #192	; 0xc0
  400ca2:	4669      	mov	r1, sp
  400ca4:	f04f 0201 	mov.w	r2, #1
  400ca8:	47a0      	blx	r4

		/** Power Control 2 configuration*/
		paratable[0] = 0x11;
  400caa:	f04f 0811 	mov.w	r8, #17
  400cae:	f88d 8000 	strb.w	r8, [sp]
		ili93xx_write_register(ILI9341_CMD_POWER_CONTROL_2, paratable, 1);
  400cb2:	f04f 00c1 	mov.w	r0, #193	; 0xc1
  400cb6:	4669      	mov	r1, sp
  400cb8:	f04f 0201 	mov.w	r2, #1
  400cbc:	47a0      	blx	r4

		/** VOM Control 1 configuration*/
		paratable[0] = 0x5C;
  400cbe:	f04f 075c 	mov.w	r7, #92	; 0x5c
  400cc2:	f88d 7000 	strb.w	r7, [sp]
		paratable[1] = 0x4C;
  400cc6:	f04f 014c 	mov.w	r1, #76	; 0x4c
  400cca:	f88d 1001 	strb.w	r1, [sp, #1]
		ili93xx_write_register(ILI9341_CMD_VCOM_CONTROL_1, paratable, 2);
  400cce:	f04f 00c5 	mov.w	r0, #197	; 0xc5
  400cd2:	4669      	mov	r1, sp
  400cd4:	464a      	mov	r2, r9
  400cd6:	47a0      	blx	r4

		/** VOM control 2 configuration*/
		paratable[0] = 0x94;
  400cd8:	f04f 0394 	mov.w	r3, #148	; 0x94
  400cdc:	f88d 3000 	strb.w	r3, [sp]
		ili93xx_write_register(ILI9341_CMD_VCOM_CONTROL_2, paratable, 1);
  400ce0:	f04f 00c7 	mov.w	r0, #199	; 0xc7
  400ce4:	4669      	mov	r1, sp
  400ce6:	f04f 0201 	mov.w	r2, #1
  400cea:	47a0      	blx	r4

		/** Driver Timing Control A configuration*/
		paratable[0] = 0x85;
  400cec:	f04f 0085 	mov.w	r0, #133	; 0x85
  400cf0:	f88d 0000 	strb.w	r0, [sp]
		paratable[1] = 0x01;
  400cf4:	f04f 0701 	mov.w	r7, #1
  400cf8:	f88d 7001 	strb.w	r7, [sp, #1]
		paratable[2] = 0x78;
  400cfc:	f04f 0278 	mov.w	r2, #120	; 0x78
  400d00:	f88d 2002 	strb.w	r2, [sp, #2]
		ili93xx_write_register(ILI9341_CMD_DRIVER_TIMING_CTL_A, paratable, 3);
  400d04:	f04f 00e8 	mov.w	r0, #232	; 0xe8
  400d08:	4669      	mov	r1, sp
  400d0a:	f04f 0203 	mov.w	r2, #3
  400d0e:	47a0      	blx	r4

		/** Driver Timing Control B configuration*/
		paratable[0] = 0x00;
  400d10:	f88d 5000 	strb.w	r5, [sp]
		paratable[1] = 0x00;
  400d14:	f88d 5001 	strb.w	r5, [sp, #1]
		ili93xx_write_register(ILI9341_CMD_DRIVER_TIMING_CTL_B, paratable, 2);
  400d18:	f04f 00ea 	mov.w	r0, #234	; 0xea
  400d1c:	4669      	mov	r1, sp
  400d1e:	464a      	mov	r2, r9
  400d20:	47a0      	blx	r4

		/** Memory Access Control configuration*/
		paratable[0] = ILI9341_CMD_MEMORY_ACCESS_CONTROL_MX |
  400d22:	f04f 0148 	mov.w	r1, #72	; 0x48
  400d26:	f88d 1000 	strb.w	r1, [sp]
				ILI9341_CMD_MEMORY_ACCESS_CONTROL_BGR;
		ili93xx_write_register(ILI9341_CMD_MEMORY_ACCESS_CONTROL,
  400d2a:	f04f 0036 	mov.w	r0, #54	; 0x36
  400d2e:	4669      	mov	r1, sp
  400d30:	463a      	mov	r2, r7
  400d32:	47a0      	blx	r4
				paratable, 1);

		/** Colmod Pixel Format Set configuation*/
		paratable[0] = 0x06;
  400d34:	f04f 0306 	mov.w	r3, #6
  400d38:	f88d 3000 	strb.w	r3, [sp]
		ili93xx_write_register(ILI9341_CMD_PIXEL_FORMAT_SET, paratable, 1);
  400d3c:	f04f 003a 	mov.w	r0, #58	; 0x3a
  400d40:	4669      	mov	r1, sp
  400d42:	463a      	mov	r2, r7
  400d44:	47a0      	blx	r4

		/** Display Function Control */
		paratable[0] = 0x02;
  400d46:	f88d 9000 	strb.w	r9, [sp]
		paratable[1] = 0x82;
  400d4a:	f04f 0082 	mov.w	r0, #130	; 0x82
  400d4e:	f88d 0001 	strb.w	r0, [sp, #1]
		paratable[2] = 0x27;
  400d52:	f04f 0227 	mov.w	r2, #39	; 0x27
  400d56:	f88d 2002 	strb.w	r2, [sp, #2]
		paratable[3] = 0x00;
  400d5a:	f88d 5003 	strb.w	r5, [sp, #3]
		ili93xx_write_register(ILI9341_CMD_DISPLAY_FUNCTION_CTL,
  400d5e:	f04f 00b6 	mov.w	r0, #182	; 0xb6
  400d62:	4669      	mov	r1, sp
  400d64:	f04f 0204 	mov.w	r2, #4
  400d68:	47a0      	blx	r4
				      paratable, 4);
				
		paratable[0] = 0x00;
  400d6a:	f88d 5000 	strb.w	r5, [sp]
		ili93xx_write_register(ILI9341_CMD_ENABLE_3_GAMMA_CONTROL,
  400d6e:	f04f 00f2 	mov.w	r0, #242	; 0xf2
  400d72:	4669      	mov	r1, sp
  400d74:	463a      	mov	r2, r7
  400d76:	47a0      	blx	r4
				      paratable,1);
		
		paratable[0] = 0x01;
  400d78:	f88d 7000 	strb.w	r7, [sp]
		ili93xx_write_register(ILI9341_CMD_GAMMA_SET, paratable,1);
  400d7c:	f04f 0026 	mov.w	r0, #38	; 0x26
  400d80:	4669      	mov	r1, sp
  400d82:	463a      	mov	r2, r7
  400d84:	47a0      	blx	r4
		
		/** set gamma curve parameters*/
		paratable[0]=0x0F;
  400d86:	f04f 070f 	mov.w	r7, #15
  400d8a:	f88d 7000 	strb.w	r7, [sp]
		paratable[1]=0x31;
  400d8e:	f04f 0931 	mov.w	r9, #49	; 0x31
  400d92:	f88d 9001 	strb.w	r9, [sp, #1]
		paratable[2]=0x2B;
  400d96:	f04f 012b 	mov.w	r1, #43	; 0x2b
  400d9a:	f88d 1002 	strb.w	r1, [sp, #2]
		paratable[3]=0x0C;
  400d9e:	f04f 030c 	mov.w	r3, #12
  400da2:	f88d 3003 	strb.w	r3, [sp, #3]
		paratable[4]=0x0E;
  400da6:	f04f 0a0e 	mov.w	sl, #14
  400daa:	f88d a004 	strb.w	sl, [sp, #4]
		paratable[5]=0x08;
  400dae:	f04f 0008 	mov.w	r0, #8
  400db2:	f88d 0005 	strb.w	r0, [sp, #5]
		paratable[6]=0x4E;
  400db6:	f04f 024e 	mov.w	r2, #78	; 0x4e
  400dba:	f88d 2006 	strb.w	r2, [sp, #6]
		paratable[7]=0xF1;
  400dbe:	f04f 01f1 	mov.w	r1, #241	; 0xf1
  400dc2:	f88d 1007 	strb.w	r1, [sp, #7]
		paratable[8]=0x37;
  400dc6:	f04f 0337 	mov.w	r3, #55	; 0x37
  400dca:	f88d 3008 	strb.w	r3, [sp, #8]
		paratable[9]=0x07;
  400dce:	f04f 0007 	mov.w	r0, #7
  400dd2:	f88d 0009 	strb.w	r0, [sp, #9]
		paratable[10]=0x10;
  400dd6:	f04f 0210 	mov.w	r2, #16
  400dda:	f88d 200a 	strb.w	r2, [sp, #10]
		paratable[11]=0x03;
  400dde:	f04f 0b03 	mov.w	fp, #3
  400de2:	f88d b00b 	strb.w	fp, [sp, #11]
		paratable[12]=0x0E;
  400de6:	f88d a00c 	strb.w	sl, [sp, #12]
		paratable[13]=0x09;
  400dea:	f04f 0109 	mov.w	r1, #9
  400dee:	f88d 100d 	strb.w	r1, [sp, #13]
		paratable[14]=0x00;
  400df2:	f88d 500e 	strb.w	r5, [sp, #14]
		ili93xx_write_register(ILI9341_CMD_POSITIVE_GAMMA_CORRECTION,
  400df6:	f04f 00e0 	mov.w	r0, #224	; 0xe0
  400dfa:	4669      	mov	r1, sp
  400dfc:	463a      	mov	r2, r7
  400dfe:	47a0      	blx	r4
				      paratable, 15);
		paratable[0]=0x00;
  400e00:	f88d 5000 	strb.w	r5, [sp]
		paratable[1]=0x0E;
  400e04:	f88d a001 	strb.w	sl, [sp, #1]
		paratable[2]=0x14;
  400e08:	f04f 0314 	mov.w	r3, #20
  400e0c:	f88d 3002 	strb.w	r3, [sp, #2]
		paratable[3]=0x03;
  400e10:	f88d b003 	strb.w	fp, [sp, #3]
		paratable[4]=0x11;
  400e14:	f88d 8004 	strb.w	r8, [sp, #4]
		paratable[5]=0x07;
  400e18:	f04f 0007 	mov.w	r0, #7
  400e1c:	f88d 0005 	strb.w	r0, [sp, #5]
		paratable[6]=0x31;
  400e20:	f88d 9006 	strb.w	r9, [sp, #6]
		paratable[7]=0xC1;
  400e24:	f04f 02c1 	mov.w	r2, #193	; 0xc1
  400e28:	f88d 2007 	strb.w	r2, [sp, #7]
		paratable[8]=0x48;
  400e2c:	f04f 0148 	mov.w	r1, #72	; 0x48
  400e30:	f88d 1008 	strb.w	r1, [sp, #8]
		paratable[9]=0x08;
  400e34:	f04f 0308 	mov.w	r3, #8
  400e38:	f88d 3009 	strb.w	r3, [sp, #9]
		paratable[10]=0x0F;
  400e3c:	f88d 700a 	strb.w	r7, [sp, #10]
		paratable[11]=0x0C;
  400e40:	f04f 000c 	mov.w	r0, #12
  400e44:	f88d 000b 	strb.w	r0, [sp, #11]
		paratable[12]=0x31;
  400e48:	f88d 900c 	strb.w	r9, [sp, #12]
		paratable[13]=0x36;
  400e4c:	f04f 0236 	mov.w	r2, #54	; 0x36
  400e50:	f88d 200d 	strb.w	r2, [sp, #13]
		paratable[14]=0x0F;
  400e54:	f88d 700e 	strb.w	r7, [sp, #14]
		ili93xx_write_register(ILI9341_CMD_NEGATIVE_GAMMA_CORRECTION,
  400e58:	f04f 00e1 	mov.w	r0, #225	; 0xe1
  400e5c:	4669      	mov	r1, sp
  400e5e:	463a      	mov	r2, r7
  400e60:	47a0      	blx	r4
				      paratable, 15);
		
		/** set window area*/
		ili93xx_set_window(0, 0, p_opt->ul_width, p_opt->ul_height);
  400e62:	4628      	mov	r0, r5
  400e64:	4629      	mov	r1, r5
  400e66:	6832      	ldr	r2, [r6, #0]
  400e68:	6873      	ldr	r3, [r6, #4]
  400e6a:	f640 07bd 	movw	r7, #2237	; 0x8bd
  400e6e:	f2c0 0740 	movt	r7, #64	; 0x40
  400e72:	47b8      	blx	r7
		ili93xx_set_foreground_color(p_opt->foreground_color);
  400e74:	68b0      	ldr	r0, [r6, #8]
  400e76:	f640 0199 	movw	r1, #2201	; 0x899
  400e7a:	f2c0 0140 	movt	r1, #64	; 0x40
  400e7e:	4788      	blx	r1
		/** Leave sleep mode*/
		ili93xx_write_register(ILI9341_CMD_SLEEP_OUT, paratable, 0);
  400e80:	4640      	mov	r0, r8
  400e82:	4669      	mov	r1, sp
  400e84:	462a      	mov	r2, r5
  400e86:	47a0      	blx	r4
		ili93xx_delay(10);
  400e88:	f04f 000a 	mov.w	r0, #10
  400e8c:	f240 7329 	movw	r3, #1833	; 0x729
  400e90:	f2c0 0340 	movt	r3, #64	; 0x40
  400e94:	4798      	blx	r3
		/** Display on*/
		ili93xx_write_register(ILI9341_CMD_DISPLAY_ON, paratable, 0);
  400e96:	f04f 0029 	mov.w	r0, #41	; 0x29
  400e9a:	4669      	mov	r1, sp
  400e9c:	462a      	mov	r2, r5
  400e9e:	47a0      	blx	r4
	} else {
		/** exit with return value 1 if device type is not supported.*/
		return 1;
	}

	return 0;
  400ea0:	4628      	mov	r0, r5
  400ea2:	e004      	b.n	400eae <ili93xx_init+0x4f2>
{
	uint8_t paratable[15];

	/** Identify the LCD driver device*/
	if (ili93xx_device_type_identify() != 0) {
		return 1;
  400ea4:	f04f 0001 	mov.w	r0, #1
  400ea8:	e001      	b.n	400eae <ili93xx_init+0x4f2>
		ili93xx_delay(10);
		/** Display on*/
		ili93xx_write_register(ILI9341_CMD_DISPLAY_ON, paratable, 0);
	} else {
		/** exit with return value 1 if device type is not supported.*/
		return 1;
  400eaa:	f04f 0001 	mov.w	r0, #1
	}

	return 0;
}
  400eae:	b005      	add	sp, #20
  400eb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00400eb4 <ili93xx_draw_pixel>:
 * \param ul_y Y coordinate of pixel.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili93xx_draw_pixel(uint32_t ul_x, uint32_t ul_y)
{
  400eb4:	b510      	push	{r4, lr}
	if ((ul_x >= g_ul_lcd_x_length) || (ul_y >= g_ul_lcd_y_length)) {
  400eb6:	f240 0300 	movw	r3, #0
  400eba:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ebe:	681a      	ldr	r2, [r3, #0]
  400ec0:	4282      	cmp	r2, r0
  400ec2:	d942      	bls.n	400f4a <ili93xx_draw_pixel+0x96>
  400ec4:	f240 0304 	movw	r3, #4
  400ec8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400ecc:	681a      	ldr	r2, [r3, #0]
  400ece:	428a      	cmp	r2, r1
  400ed0:	d93e      	bls.n	400f50 <ili93xx_draw_pixel+0x9c>
		return 1;
	}

	if (g_uc_device_type == DEVICE_TYPE_ILI9325) {
  400ed2:	f640 432c 	movw	r3, #3116	; 0xc2c
  400ed6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  400eda:	781a      	ldrb	r2, [r3, #0]
  400edc:	2a01      	cmp	r2, #1
  400ede:	d118      	bne.n	400f12 <ili93xx_draw_pixel+0x5e>
		/** Set cursor */
		ili93xx_set_cursor_position(ul_x, ul_y);
  400ee0:	b280      	uxth	r0, r0
  400ee2:	b289      	uxth	r1, r1
  400ee4:	f640 128d 	movw	r2, #2445	; 0x98d
  400ee8:	f2c0 0240 	movt	r2, #64	; 0x40
  400eec:	4790      	blx	r2
		/** Prepare to write in GRAM */
		ili93xx_write_ram_prepare();
  400eee:	f240 40a1 	movw	r0, #1185	; 0x4a1
  400ef2:	f2c0 0040 	movt	r0, #64	; 0x40
  400ef6:	4780      	blx	r0
		ili93xx_write_ram(*g_ul_pixel_cache);
  400ef8:	f640 016c 	movw	r1, #2156	; 0x86c
  400efc:	f2c2 0100 	movt	r1, #8192	; 0x2000
  400f00:	6808      	ldr	r0, [r1, #0]
  400f02:	f240 43dd 	movw	r3, #1245	; 0x4dd
  400f06:	f2c0 0340 	movt	r3, #64	; 0x40
  400f0a:	4798      	blx	r3
		/** Prepare to write in GRAM */
		ili93xx_write_ram_prepare();
		ili93xx_write_ram(*g_ul_pixel_cache);
	}

	return 0;
  400f0c:	f04f 0000 	mov.w	r0, #0
  400f10:	bd10      	pop	{r4, pc}
		/** Set cursor */
		ili93xx_set_cursor_position(ul_x, ul_y);
		/** Prepare to write in GRAM */
		ili93xx_write_ram_prepare();
		ili93xx_write_ram(*g_ul_pixel_cache);
	} else if (g_uc_device_type == DEVICE_TYPE_ILI9341) {
  400f12:	2a02      	cmp	r2, #2
  400f14:	d11f      	bne.n	400f56 <ili93xx_draw_pixel+0xa2>
		ili93xx_set_window(ul_x, ul_y, 0, 0);
  400f16:	f04f 0200 	mov.w	r2, #0
  400f1a:	4613      	mov	r3, r2
  400f1c:	f640 04bd 	movw	r4, #2237	; 0x8bd
  400f20:	f2c0 0440 	movt	r4, #64	; 0x40
  400f24:	47a0      	blx	r4
		/** Prepare to write in GRAM */
		ili93xx_write_ram_prepare();
  400f26:	f240 40a1 	movw	r0, #1185	; 0x4a1
  400f2a:	f2c0 0040 	movt	r0, #64	; 0x40
  400f2e:	4780      	blx	r0
		ili93xx_write_ram(*g_ul_pixel_cache);
  400f30:	f640 016c 	movw	r1, #2156	; 0x86c
  400f34:	f2c2 0100 	movt	r1, #8192	; 0x2000
  400f38:	6808      	ldr	r0, [r1, #0]
  400f3a:	f240 43dd 	movw	r3, #1245	; 0x4dd
  400f3e:	f2c0 0340 	movt	r3, #64	; 0x40
  400f42:	4798      	blx	r3
	}

	return 0;
  400f44:	f04f 0000 	mov.w	r0, #0
  400f48:	bd10      	pop	{r4, pc}
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili93xx_draw_pixel(uint32_t ul_x, uint32_t ul_y)
{
	if ((ul_x >= g_ul_lcd_x_length) || (ul_y >= g_ul_lcd_y_length)) {
		return 1;
  400f4a:	f04f 0001 	mov.w	r0, #1
  400f4e:	bd10      	pop	{r4, pc}
  400f50:	f04f 0001 	mov.w	r0, #1
  400f54:	bd10      	pop	{r4, pc}
		/** Prepare to write in GRAM */
		ili93xx_write_ram_prepare();
		ili93xx_write_ram(*g_ul_pixel_cache);
	}

	return 0;
  400f56:	f04f 0000 	mov.w	r0, #0
}
  400f5a:	bd10      	pop	{r4, pc}

00400f5c <ili93xx_draw_filled_rectangle>:
 * \param ul_x2 X coordinate of lower-right corner on LCD.
 * \param ul_y2 Y coordinate of lower-right corner on LCD.
 */
void ili93xx_draw_filled_rectangle(uint32_t ul_x1, uint32_t ul_y1,
		uint32_t ul_x2, uint32_t ul_y2)
{
  400f5c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  400f60:	b085      	sub	sp, #20
  400f62:	9003      	str	r0, [sp, #12]
  400f64:	9102      	str	r1, [sp, #8]
  400f66:	9201      	str	r2, [sp, #4]
  400f68:	9300      	str	r3, [sp, #0]
	uint32_t size, blocks;

	/** Swap coordinates if necessary */
	ili93xx_check_box_coordinates(&ul_x1, &ul_y1, &ul_x2, &ul_y2);
  400f6a:	a803      	add	r0, sp, #12
  400f6c:	a902      	add	r1, sp, #8
  400f6e:	aa01      	add	r2, sp, #4
  400f70:	466b      	mov	r3, sp
  400f72:	f240 746d 	movw	r4, #1901	; 0x76d
  400f76:	f2c0 0440 	movt	r4, #64	; 0x40
  400f7a:	47a0      	blx	r4

	/** Determine the refresh window area */
	ili93xx_set_window(ul_x1, ul_y1, (ul_x2 - ul_x1) + 1,
  400f7c:	9a03      	ldr	r2, [sp, #12]
			(ul_y2 - ul_y1) + 1);
  400f7e:	9b02      	ldr	r3, [sp, #8]

	/** Swap coordinates if necessary */
	ili93xx_check_box_coordinates(&ul_x1, &ul_y1, &ul_x2, &ul_y2);

	/** Determine the refresh window area */
	ili93xx_set_window(ul_x1, ul_y1, (ul_x2 - ul_x1) + 1,
  400f80:	9901      	ldr	r1, [sp, #4]
  400f82:	f101 0501 	add.w	r5, r1, #1
			(ul_y2 - ul_y1) + 1);
  400f86:	9800      	ldr	r0, [sp, #0]
  400f88:	f100 0401 	add.w	r4, r0, #1

	/** Swap coordinates if necessary */
	ili93xx_check_box_coordinates(&ul_x1, &ul_y1, &ul_x2, &ul_y2);

	/** Determine the refresh window area */
	ili93xx_set_window(ul_x1, ul_y1, (ul_x2 - ul_x1) + 1,
  400f8c:	4610      	mov	r0, r2
  400f8e:	4619      	mov	r1, r3
  400f90:	1aaa      	subs	r2, r5, r2
  400f92:	1ae3      	subs	r3, r4, r3
  400f94:	f640 04bd 	movw	r4, #2237	; 0x8bd
  400f98:	f2c0 0440 	movt	r4, #64	; 0x40
  400f9c:	47a0      	blx	r4
			(ul_y2 - ul_y1) + 1);

	/** Set cursor */
	ili93xx_set_cursor_position(ul_x1, ul_y1);
  400f9e:	f8bd 000c 	ldrh.w	r0, [sp, #12]
  400fa2:	f8bd 1008 	ldrh.w	r1, [sp, #8]
  400fa6:	f640 128d 	movw	r2, #2445	; 0x98d
  400faa:	f2c0 0240 	movt	r2, #64	; 0x40
  400fae:	4790      	blx	r2

	/** Prepare to write in Graphic RAM */
	ili93xx_write_ram_prepare();
  400fb0:	f240 43a1 	movw	r3, #1185	; 0x4a1
  400fb4:	f2c0 0340 	movt	r3, #64	; 0x40
  400fb8:	4798      	blx	r3

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);
  400fba:	9902      	ldr	r1, [sp, #8]
  400fbc:	9800      	ldr	r0, [sp, #0]
  400fbe:	1a44      	subs	r4, r0, r1
  400fc0:	9a01      	ldr	r2, [sp, #4]
  400fc2:	f102 0801 	add.w	r8, r2, #1
  400fc6:	9b03      	ldr	r3, [sp, #12]
  400fc8:	ebc3 0108 	rsb	r1, r3, r8
  400fcc:	fb04 1801 	mla	r8, r4, r1, r1

	/** Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
  400fd0:	f648 0089 	movw	r0, #34953	; 0x8889
  400fd4:	f6c8 0088 	movt	r0, #34952	; 0x8888
  400fd8:	fba0 2408 	umull	r2, r4, r0, r8
	while (blocks--) {
  400fdc:	09e4      	lsrs	r4, r4, #7
  400fde:	d01d      	beq.n	40101c <ili93xx_draw_filled_rectangle+0xc0>
		ili93xx_write_ram_buffer(g_ul_pixel_cache,
  400fe0:	f640 076c 	movw	r7, #2156	; 0x86c
  400fe4:	f2c2 0700 	movt	r7, #8192	; 0x2000
  400fe8:	f04f 06f0 	mov.w	r6, #240	; 0xf0
  400fec:	f240 45f9 	movw	r5, #1273	; 0x4f9
  400ff0:	f2c0 0540 	movt	r5, #64	; 0x40
  400ff4:	f104 32ff 	add.w	r2, r4, #4294967295
  400ff8:	f002 0901 	and.w	r9, r2, #1
  400ffc:	4638      	mov	r0, r7
  400ffe:	4631      	mov	r1, r6
  401000:	47a8      	blx	r5

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);

	/** Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
  401002:	3c01      	subs	r4, #1
  401004:	d134      	bne.n	401070 <ili93xx_draw_filled_rectangle+0x114>
  401006:	e009      	b.n	40101c <ili93xx_draw_filled_rectangle+0xc0>
		ili93xx_write_ram_buffer(g_ul_pixel_cache,
  401008:	4638      	mov	r0, r7
  40100a:	4631      	mov	r1, r6
  40100c:	47a8      	blx	r5
  40100e:	f104 34ff 	add.w	r4, r4, #4294967295
  401012:	4638      	mov	r0, r7
  401014:	4631      	mov	r1, r6
  401016:	47a8      	blx	r5

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);

	/** Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
  401018:	3c01      	subs	r4, #1
  40101a:	d1f5      	bne.n	401008 <ili93xx_draw_filled_rectangle+0xac>
		ili93xx_write_ram_buffer(g_ul_pixel_cache,
								LCD_DATA_CACHE_SIZE);
	}

	/** Send remaining pixels */
	ili93xx_write_ram_buffer(g_ul_pixel_cache,
  40101c:	f648 0389 	movw	r3, #34953	; 0x8889
  401020:	f6c8 0388 	movt	r3, #34952	; 0x8888
  401024:	fba3 2108 	umull	r2, r1, r3, r8
  401028:	ea4f 10d1 	mov.w	r0, r1, lsr #7
  40102c:	ebc0 1200 	rsb	r2, r0, r0, lsl #4
  401030:	f640 006c 	movw	r0, #2156	; 0x86c
  401034:	f2c2 0000 	movt	r0, #8192	; 0x2000
  401038:	eba8 1102 	sub.w	r1, r8, r2, lsl #4
  40103c:	f240 44f9 	movw	r4, #1273	; 0x4f9
  401040:	f2c0 0440 	movt	r4, #64	; 0x40
  401044:	47a0      	blx	r4
					size % LCD_DATA_CACHE_SIZE);

	/** Reset the refresh window area */
	ili93xx_set_window(0, 0, g_ul_lcd_x_length, g_ul_lcd_y_length);
  401046:	f04f 0000 	mov.w	r0, #0
  40104a:	4601      	mov	r1, r0
  40104c:	f240 0300 	movw	r3, #0
  401050:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401054:	681a      	ldr	r2, [r3, #0]
  401056:	f240 0404 	movw	r4, #4
  40105a:	f2c2 0400 	movt	r4, #8192	; 0x2000
  40105e:	6823      	ldr	r3, [r4, #0]
  401060:	f640 04bd 	movw	r4, #2237	; 0x8bd
  401064:	f2c0 0440 	movt	r4, #64	; 0x40
  401068:	47a0      	blx	r4
}
  40106a:	b005      	add	sp, #20
  40106c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401070:	f1b9 0f00 	cmp.w	r9, #0
  401074:	d0c8      	beq.n	401008 <ili93xx_draw_filled_rectangle+0xac>
	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);

	/** Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
		ili93xx_write_ram_buffer(g_ul_pixel_cache,
  401076:	4638      	mov	r0, r7
  401078:	4631      	mov	r1, r6
  40107a:	47a8      	blx	r5

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);

	/** Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
  40107c:	3c01      	subs	r4, #1
  40107e:	d1c3      	bne.n	401008 <ili93xx_draw_filled_rectangle+0xac>
  401080:	e7cc      	b.n	40101c <ili93xx_draw_filled_rectangle+0xc0>
  401082:	bf00      	nop

00401084 <ili93xx_draw_line>:
 * \param ul_x2 X coordinate of line end.
 * \param ul_y2 Y coordinate of line end.
 */
void ili93xx_draw_line(uint32_t ul_x1, uint32_t ul_y1,
		uint32_t ul_x2, uint32_t ul_y2)
{
  401084:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401088:	b083      	sub	sp, #12
  40108a:	4682      	mov	sl, r0
  40108c:	4689      	mov	r9, r1
	if ((ul_y1 == ul_y2) || (ul_x1 == ul_x2)) {
  40108e:	4299      	cmp	r1, r3
  401090:	d001      	beq.n	401096 <ili93xx_draw_line+0x12>
  401092:	4290      	cmp	r0, r2
  401094:	d107      	bne.n	4010a6 <ili93xx_draw_line+0x22>
		ili93xx_draw_filled_rectangle(ul_x1, ul_y1, ul_x2, ul_y2);
  401096:	4650      	mov	r0, sl
  401098:	4649      	mov	r1, r9
  40109a:	f640 745d 	movw	r4, #3933	; 0xf5d
  40109e:	f2c0 0440 	movt	r4, #64	; 0x40
  4010a2:	47a0      	blx	r4
  4010a4:	e068      	b.n	401178 <ili93xx_draw_line+0xf4>
	int dx, dy;
	int i;
	int xinc, yinc, cumul;
	int x, y;

	x = ul_x1;
  4010a6:	4680      	mov	r8, r0
	y = ul_y1;
  4010a8:	460f      	mov	r7, r1
	dx = ul_x2 - ul_x1;
  4010aa:	1a15      	subs	r5, r2, r0
	dy = ul_y2 - ul_y1;
  4010ac:	1a5c      	subs	r4, r3, r1
	xinc = (dx > 0) ? 1 : -1;
  4010ae:	2d00      	cmp	r5, #0
  4010b0:	bfd4      	ite	le
  4010b2:	f04f 33ff 	movle.w	r3, #4294967295
  4010b6:	2301      	movgt	r3, #1
  4010b8:	9300      	str	r3, [sp, #0]
	yinc = (dy > 0) ? 1 : -1;
  4010ba:	2c00      	cmp	r4, #0
  4010bc:	bfd4      	ite	le
  4010be:	f04f 30ff 	movle.w	r0, #4294967295
  4010c2:	2001      	movgt	r0, #1
  4010c4:	9001      	str	r0, [sp, #4]
	dx = abs(ul_x2 - ul_x1);
  4010c6:	2d00      	cmp	r5, #0
  4010c8:	bfb8      	it	lt
  4010ca:	426d      	neglt	r5, r5
	dy = abs(ul_y2 - ul_y1);
  4010cc:	2c00      	cmp	r4, #0
  4010ce:	bfb8      	it	lt
  4010d0:	4264      	neglt	r4, r4

	ili93xx_draw_pixel(x, y);
  4010d2:	4650      	mov	r0, sl
  4010d4:	f640 62b5 	movw	r2, #3765	; 0xeb5
  4010d8:	f2c0 0240 	movt	r2, #64	; 0x40
  4010dc:	4790      	blx	r2

	if (dx > dy) {
  4010de:	42a5      	cmp	r5, r4
  4010e0:	dd26      	ble.n	401130 <ili93xx_draw_line+0xac>
		cumul = dx >> 1;
  4010e2:	ea4f 0665 	mov.w	r6, r5, asr #1

		for (i = 1; i <= dx; i++) {
  4010e6:	2d00      	cmp	r5, #0
  4010e8:	dd46      	ble.n	401178 <ili93xx_draw_line+0xf4>
 * \param ul_x1 X coordinate of line start.
 * \param ul_y1 Y coordinate of line start.
 * \param ul_x2 X coordinate of line end.
 * \param ul_y2 Y coordinate of line end.
 */
void ili93xx_draw_line(uint32_t ul_x1, uint32_t ul_y1,
  4010ea:	f8dd b000 	ldr.w	fp, [sp]
  4010ee:	eb0a 090b 	add.w	r9, sl, fp
	ili93xx_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  4010f2:	f04f 0801 	mov.w	r8, #1
			if (cumul >= dx) {
				cumul -= dx;
				y += yinc;
			}

			ili93xx_draw_pixel(x, y);
  4010f6:	f640 6ab5 	movw	sl, #3765	; 0xeb5
  4010fa:	f2c0 0a40 	movt	sl, #64	; 0x40
  4010fe:	ebc8 0005 	rsb	r0, r8, r5
  401102:	ea00 0208 	and.w	r2, r0, r8
  401106:	9200      	str	r2, [sp, #0]
	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
			x += xinc;
			cumul += dy;
  401108:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  40110a:	42b5      	cmp	r5, r6
  40110c:	dc3a      	bgt.n	401184 <ili93xx_draw_line+0x100>
  40110e:	e036      	b.n	40117e <ili93xx_draw_line+0xfa>
	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
			x += xinc;
			cumul += dy;
  401110:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  401112:	42b5      	cmp	r5, r6
  401114:	dc02      	bgt.n	40111c <ili93xx_draw_line+0x98>
				cumul -= dx;
  401116:	1b76      	subs	r6, r6, r5
				y += yinc;
  401118:	9a01      	ldr	r2, [sp, #4]
  40111a:	18bf      	adds	r7, r7, r2
			}

			ili93xx_draw_pixel(x, y);
  40111c:	4648      	mov	r0, r9
  40111e:	4639      	mov	r1, r7
  401120:	47d0      	blx	sl
	ili93xx_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  401122:	f108 0801 	add.w	r8, r8, #1
  401126:	44d9      	add	r9, fp
			x += xinc;
			cumul += dy;
  401128:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  40112a:	42b5      	cmp	r5, r6
  40112c:	dc47      	bgt.n	4011be <ili93xx_draw_line+0x13a>
  40112e:	e043      	b.n	4011b8 <ili93xx_draw_line+0x134>
			}

			ili93xx_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;
  401130:	ea4f 0664 	mov.w	r6, r4, asr #1

		for (i = 1; i <= dy; i++) {
  401134:	2c00      	cmp	r4, #0
  401136:	dd1f      	ble.n	401178 <ili93xx_draw_line+0xf4>
 * \param ul_x1 X coordinate of line start.
 * \param ul_y1 Y coordinate of line start.
 * \param ul_x2 X coordinate of line end.
 * \param ul_y2 Y coordinate of line end.
 */
void ili93xx_draw_line(uint32_t ul_x1, uint32_t ul_y1,
  401138:	f8dd b004 	ldr.w	fp, [sp, #4]
  40113c:	44d9      	add	r9, fp
			ili93xx_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  40113e:	f04f 0701 	mov.w	r7, #1
			if (cumul >= dy) {
				cumul -= dy;
				x += xinc;
			}

			ili93xx_draw_pixel(x, y);
  401142:	f640 6ab5 	movw	sl, #3765	; 0xeb5
  401146:	f2c0 0a40 	movt	sl, #64	; 0x40
  40114a:	1be1      	subs	r1, r4, r7
  40114c:	4039      	ands	r1, r7
  40114e:	9101      	str	r1, [sp, #4]
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
			y += yinc;
			cumul += dx;
  401150:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  401152:	42b4      	cmp	r4, r6
  401154:	dc3f      	bgt.n	4011d6 <ili93xx_draw_line+0x152>
  401156:	e03b      	b.n	4011d0 <ili93xx_draw_line+0x14c>
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
			y += yinc;
			cumul += dx;
  401158:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  40115a:	42b4      	cmp	r4, r6
  40115c:	dc02      	bgt.n	401164 <ili93xx_draw_line+0xe0>
				cumul -= dy;
  40115e:	1b36      	subs	r6, r6, r4
				x += xinc;
  401160:	9900      	ldr	r1, [sp, #0]
  401162:	4488      	add	r8, r1
			}

			ili93xx_draw_pixel(x, y);
  401164:	4640      	mov	r0, r8
  401166:	4649      	mov	r1, r9
  401168:	47d0      	blx	sl
			ili93xx_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  40116a:	f107 0701 	add.w	r7, r7, #1
  40116e:	44d9      	add	r9, fp
			y += yinc;
			cumul += dx;
  401170:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  401172:	42b4      	cmp	r4, r6
  401174:	dc4c      	bgt.n	401210 <ili93xx_draw_line+0x18c>
  401176:	e048      	b.n	40120a <ili93xx_draw_line+0x186>
	if ((ul_y1 == ul_y2) || (ul_x1 == ul_x2)) {
		ili93xx_draw_filled_rectangle(ul_x1, ul_y1, ul_x2, ul_y2);
	} else {
		ili93xx_draw_line_bresenham(ul_x1, ul_y1, ul_x2, ul_y2);
	}
}
  401178:	b003      	add	sp, #12
  40117a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 1; i <= dx; i++) {
			x += xinc;
			cumul += dy;

			if (cumul >= dx) {
				cumul -= dx;
  40117e:	1b76      	subs	r6, r6, r5
				y += yinc;
  401180:	9901      	ldr	r1, [sp, #4]
  401182:	187f      	adds	r7, r7, r1
			}

			ili93xx_draw_pixel(x, y);
  401184:	4648      	mov	r0, r9
  401186:	4639      	mov	r1, r7
  401188:	47d0      	blx	sl
	ili93xx_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  40118a:	f108 0801 	add.w	r8, r8, #1
  40118e:	44d9      	add	r9, fp
  401190:	4545      	cmp	r5, r8
  401192:	dbf1      	blt.n	401178 <ili93xx_draw_line+0xf4>
  401194:	9b00      	ldr	r3, [sp, #0]
  401196:	2b00      	cmp	r3, #0
  401198:	d0ba      	beq.n	401110 <ili93xx_draw_line+0x8c>
			x += xinc;
			cumul += dy;
  40119a:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  40119c:	42b5      	cmp	r5, r6
  40119e:	dc02      	bgt.n	4011a6 <ili93xx_draw_line+0x122>
				cumul -= dx;
  4011a0:	1b76      	subs	r6, r6, r5
				y += yinc;
  4011a2:	9801      	ldr	r0, [sp, #4]
  4011a4:	183f      	adds	r7, r7, r0
			}

			ili93xx_draw_pixel(x, y);
  4011a6:	4648      	mov	r0, r9
  4011a8:	4639      	mov	r1, r7
  4011aa:	47d0      	blx	sl
	ili93xx_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  4011ac:	f108 0801 	add.w	r8, r8, #1
  4011b0:	44d9      	add	r9, fp
  4011b2:	4545      	cmp	r5, r8
  4011b4:	daac      	bge.n	401110 <ili93xx_draw_line+0x8c>
  4011b6:	e7df      	b.n	401178 <ili93xx_draw_line+0xf4>
			x += xinc;
			cumul += dy;

			if (cumul >= dx) {
				cumul -= dx;
  4011b8:	1b76      	subs	r6, r6, r5
				y += yinc;
  4011ba:	9901      	ldr	r1, [sp, #4]
  4011bc:	187f      	adds	r7, r7, r1
			}

			ili93xx_draw_pixel(x, y);
  4011be:	4648      	mov	r0, r9
  4011c0:	4639      	mov	r1, r7
  4011c2:	47d0      	blx	sl
	ili93xx_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  4011c4:	f108 0801 	add.w	r8, r8, #1
  4011c8:	44d9      	add	r9, fp
  4011ca:	4545      	cmp	r5, r8
  4011cc:	daa0      	bge.n	401110 <ili93xx_draw_line+0x8c>
  4011ce:	e7d3      	b.n	401178 <ili93xx_draw_line+0xf4>
		for (i = 1; i <= dy; i++) {
			y += yinc;
			cumul += dx;

			if (cumul >= dy) {
				cumul -= dy;
  4011d0:	1b36      	subs	r6, r6, r4
				x += xinc;
  4011d2:	9b00      	ldr	r3, [sp, #0]
  4011d4:	4498      	add	r8, r3
			}

			ili93xx_draw_pixel(x, y);
  4011d6:	4640      	mov	r0, r8
  4011d8:	4649      	mov	r1, r9
  4011da:	47d0      	blx	sl
			ili93xx_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  4011dc:	f107 0701 	add.w	r7, r7, #1
  4011e0:	44d9      	add	r9, fp
  4011e2:	42bc      	cmp	r4, r7
  4011e4:	dbc8      	blt.n	401178 <ili93xx_draw_line+0xf4>
  4011e6:	9801      	ldr	r0, [sp, #4]
  4011e8:	2800      	cmp	r0, #0
  4011ea:	d0b5      	beq.n	401158 <ili93xx_draw_line+0xd4>
			y += yinc;
			cumul += dx;
  4011ec:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  4011ee:	42b4      	cmp	r4, r6
  4011f0:	dc02      	bgt.n	4011f8 <ili93xx_draw_line+0x174>
				cumul -= dy;
  4011f2:	1b36      	subs	r6, r6, r4
				x += xinc;
  4011f4:	9a00      	ldr	r2, [sp, #0]
  4011f6:	4490      	add	r8, r2
			}

			ili93xx_draw_pixel(x, y);
  4011f8:	4640      	mov	r0, r8
  4011fa:	4649      	mov	r1, r9
  4011fc:	47d0      	blx	sl
			ili93xx_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  4011fe:	f107 0701 	add.w	r7, r7, #1
  401202:	44d9      	add	r9, fp
  401204:	42bc      	cmp	r4, r7
  401206:	daa7      	bge.n	401158 <ili93xx_draw_line+0xd4>
  401208:	e7b6      	b.n	401178 <ili93xx_draw_line+0xf4>
			y += yinc;
			cumul += dx;

			if (cumul >= dy) {
				cumul -= dy;
  40120a:	1b36      	subs	r6, r6, r4
				x += xinc;
  40120c:	9b00      	ldr	r3, [sp, #0]
  40120e:	4498      	add	r8, r3
			}

			ili93xx_draw_pixel(x, y);
  401210:	4640      	mov	r0, r8
  401212:	4649      	mov	r1, r9
  401214:	47d0      	blx	sl
			ili93xx_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  401216:	f107 0701 	add.w	r7, r7, #1
  40121a:	44d9      	add	r9, fp
  40121c:	42bc      	cmp	r4, r7
  40121e:	da9b      	bge.n	401158 <ili93xx_draw_line+0xd4>
  401220:	e7aa      	b.n	401178 <ili93xx_draw_line+0xf4>
  401222:	bf00      	nop

00401224 <ili93xx_draw_circle>:
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili93xx_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
{
  401224:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401228:	b083      	sub	sp, #12
  40122a:	4607      	mov	r7, r0
  40122c:	4688      	mov	r8, r1
	int32_t d;
	uint32_t curX;
	uint32_t curY;

	if (ul_r == 0) {
  40122e:	4616      	mov	r6, r2
  401230:	2a00      	cmp	r2, #0
  401232:	d04b      	beq.n	4012cc <ili93xx_draw_circle+0xa8>
		return 1;
	}

	d = 3 - (ul_r << 1);
  401234:	ea4f 0342 	mov.w	r3, r2, lsl #1
  401238:	f1c3 0003 	rsb	r0, r3, #3
  40123c:	9001      	str	r0, [sp, #4]
	curX = 0;
  40123e:	f04f 0500 	mov.w	r5, #0
	curY = ul_r;

	while (curX <= curY) {
		ili93xx_draw_pixel(ul_x + curX, ul_y + curY);
  401242:	f640 64b5 	movw	r4, #3765	; 0xeb5
  401246:	f2c0 0440 	movt	r4, #64	; 0x40
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili93xx_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  40124a:	eb05 0a07 	add.w	sl, r5, r7
	d = 3 - (ul_r << 1);
	curX = 0;
	curY = ul_r;

	while (curX <= curY) {
		ili93xx_draw_pixel(ul_x + curX, ul_y + curY);
  40124e:	eb06 0b08 	add.w	fp, r6, r8
  401252:	4650      	mov	r0, sl
  401254:	4659      	mov	r1, fp
  401256:	47a0      	blx	r4
		ili93xx_draw_pixel(ul_x + curX, ul_y - curY);
  401258:	ebc6 0908 	rsb	r9, r6, r8
  40125c:	4650      	mov	r0, sl
  40125e:	4649      	mov	r1, r9
  401260:	47a0      	blx	r4
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili93xx_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  401262:	ebc5 0a07 	rsb	sl, r5, r7
	curY = ul_r;

	while (curX <= curY) {
		ili93xx_draw_pixel(ul_x + curX, ul_y + curY);
		ili93xx_draw_pixel(ul_x + curX, ul_y - curY);
		ili93xx_draw_pixel(ul_x - curX, ul_y + curY);
  401266:	4650      	mov	r0, sl
  401268:	4659      	mov	r1, fp
  40126a:	47a0      	blx	r4
		ili93xx_draw_pixel(ul_x - curX, ul_y - curY);
  40126c:	4650      	mov	r0, sl
  40126e:	4649      	mov	r1, r9
  401270:	47a0      	blx	r4
		ili93xx_draw_pixel(ul_x + curY, ul_y + curX);
  401272:	eb06 0a07 	add.w	sl, r6, r7
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili93xx_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  401276:	eb05 0b08 	add.w	fp, r5, r8
	while (curX <= curY) {
		ili93xx_draw_pixel(ul_x + curX, ul_y + curY);
		ili93xx_draw_pixel(ul_x + curX, ul_y - curY);
		ili93xx_draw_pixel(ul_x - curX, ul_y + curY);
		ili93xx_draw_pixel(ul_x - curX, ul_y - curY);
		ili93xx_draw_pixel(ul_x + curY, ul_y + curX);
  40127a:	4650      	mov	r0, sl
  40127c:	4659      	mov	r1, fp
  40127e:	47a0      	blx	r4
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili93xx_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  401280:	ebc5 0908 	rsb	r9, r5, r8
		ili93xx_draw_pixel(ul_x + curX, ul_y + curY);
		ili93xx_draw_pixel(ul_x + curX, ul_y - curY);
		ili93xx_draw_pixel(ul_x - curX, ul_y + curY);
		ili93xx_draw_pixel(ul_x - curX, ul_y - curY);
		ili93xx_draw_pixel(ul_x + curY, ul_y + curX);
		ili93xx_draw_pixel(ul_x + curY, ul_y - curX);
  401284:	4650      	mov	r0, sl
  401286:	4649      	mov	r1, r9
  401288:	47a0      	blx	r4
		ili93xx_draw_pixel(ul_x - curY, ul_y + curX);
  40128a:	ebc6 0a07 	rsb	sl, r6, r7
  40128e:	4650      	mov	r0, sl
  401290:	4659      	mov	r1, fp
  401292:	47a0      	blx	r4
		ili93xx_draw_pixel(ul_x - curY, ul_y - curX);
  401294:	4650      	mov	r0, sl
  401296:	4649      	mov	r1, r9
  401298:	47a0      	blx	r4

		if (d < 0) {
  40129a:	9a01      	ldr	r2, [sp, #4]
  40129c:	2a00      	cmp	r2, #0
  40129e:	da05      	bge.n	4012ac <ili93xx_draw_circle+0x88>
			d += (curX << 2) + 6;
  4012a0:	eb02 0285 	add.w	r2, r2, r5, lsl #2
  4012a4:	f102 0206 	add.w	r2, r2, #6
  4012a8:	9201      	str	r2, [sp, #4]
  4012aa:	e008      	b.n	4012be <ili93xx_draw_circle+0x9a>
		} else {
			d += ((curX - curY) << 2) + 10;
  4012ac:	9901      	ldr	r1, [sp, #4]
  4012ae:	f101 010a 	add.w	r1, r1, #10
  4012b2:	1bab      	subs	r3, r5, r6
  4012b4:	eb01 0083 	add.w	r0, r1, r3, lsl #2
  4012b8:	9001      	str	r0, [sp, #4]
			curY--;
  4012ba:	f106 36ff 	add.w	r6, r6, #4294967295
		}

		curX++;
  4012be:	f105 0501 	add.w	r5, r5, #1

	d = 3 - (ul_r << 1);
	curX = 0;
	curY = ul_r;

	while (curX <= curY) {
  4012c2:	42ae      	cmp	r6, r5
  4012c4:	d2c1      	bcs.n	40124a <ili93xx_draw_circle+0x26>
		}

		curX++;
	}

	return 0;
  4012c6:	f04f 0000 	mov.w	r0, #0
  4012ca:	e001      	b.n	4012d0 <ili93xx_draw_circle+0xac>
	int32_t d;
	uint32_t curX;
	uint32_t curY;

	if (ul_r == 0) {
		return 1;
  4012cc:	f04f 0001 	mov.w	r0, #1

		curX++;
	}

	return 0;
}
  4012d0:	b003      	add	sp, #12
  4012d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4012d6:	bf00      	nop

004012d8 <ili93xx_draw_string>:
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili93xx_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
{
  4012d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4012dc:	b089      	sub	sp, #36	; 0x24
  4012de:	9006      	str	r0, [sp, #24]
  4012e0:	468b      	mov	fp, r1
	uint32_t xorg = ul_x;

	while (*p_str != 0) {
  4012e2:	7813      	ldrb	r3, [r2, #0]
  4012e4:	2b00      	cmp	r3, #0
  4012e6:	f000 80c7 	beq.w	401478 <ili93xx_draw_string+0x1a0>
  4012ea:	9200      	str	r2, [sp, #0]
  4012ec:	4682      	mov	sl, r0
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili93xx_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  4012ee:	f243 1240 	movw	r2, #12608	; 0x3140
  4012f2:	f2c0 0240 	movt	r2, #64	; 0x40
  4012f6:	9205      	str	r2, [sp, #20]
  4012f8:	f2a2 206b 	subw	r0, r2, #619	; 0x26b
  4012fc:	9007      	str	r0, [sp, #28]
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  4012fe:	f640 61b5 	movw	r1, #3765	; 0xeb5
  401302:	4689      	mov	r9, r1
  401304:	f2c0 0940 	movt	r9, #64	; 0x40
{
	uint32_t xorg = ul_x;

	while (*p_str != 0) {
		/** If newline, jump to the next line (font height + 2) */
		if (*p_str == '\n') {
  401308:	2b0a      	cmp	r3, #10
  40130a:	d104      	bne.n	401316 <ili93xx_draw_string+0x3e>
			ul_y += gfont.height + 2;
  40130c:	f10b 0b10 	add.w	fp, fp, #16
			ul_x = xorg;
  401310:	f8dd a018 	ldr.w	sl, [sp, #24]
  401314:	e0a9      	b.n	40146a <ili93xx_draw_string+0x192>

	/**
	 * Compute offset according of the specified ASCII character
	 *  Note: the first 32 characters of the ASCII table are not handled
	 */
	offset = ((uint32_t)uc_c - 0x20) * 20;
  401316:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40131a:	ea4f 0883 	mov.w	r8, r3, lsl #2
  40131e:	f5a8 7720 	sub.w	r7, r8, #640	; 0x280
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili93xx_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  401322:	9c05      	ldr	r4, [sp, #20]
  401324:	19e0      	adds	r0, r4, r7
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  401326:	f2a8 267f 	subw	r6, r8, #639	; 0x27f
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili93xx_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  40132a:	19a6      	adds	r6, r4, r6
  40132c:	9d07      	ldr	r5, [sp, #28]
  40132e:	44a8      	add	r8, r5
  401330:	4655      	mov	r5, sl
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  401332:	f10b 0201 	add.w	r2, fp, #1
  401336:	9201      	str	r2, [sp, #4]
  401338:	f10b 0102 	add.w	r1, fp, #2
  40133c:	9102      	str	r1, [sp, #8]
  40133e:	f10b 0303 	add.w	r3, fp, #3
  401342:	9303      	str	r3, [sp, #12]
  401344:	f10b 0704 	add.w	r7, fp, #4
  401348:	9704      	str	r7, [sp, #16]
  40134a:	464c      	mov	r4, r9
  40134c:	4681      	mov	r9, r0
  40134e:	4627      	mov	r7, r4
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili93xx_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  401350:	4634      	mov	r4, r6
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  401352:	f816 0c01 	ldrb.w	r0, [r6, #-1]
  401356:	f010 0f80 	tst.w	r0, #128	; 0x80
  40135a:	d002      	beq.n	401362 <ili93xx_draw_string+0x8a>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  40135c:	4628      	mov	r0, r5
  40135e:	4659      	mov	r1, fp
  401360:	47b8      	blx	r7
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  401362:	f814 2c01 	ldrb.w	r2, [r4, #-1]
  401366:	f002 0140 	and.w	r1, r2, #64	; 0x40
  40136a:	b2cb      	uxtb	r3, r1
  40136c:	b113      	cbz	r3, 401374 <ili93xx_draw_string+0x9c>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  40136e:	4628      	mov	r0, r5
  401370:	9901      	ldr	r1, [sp, #4]
  401372:	47b8      	blx	r7
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  401374:	f814 0c01 	ldrb.w	r0, [r4, #-1]
  401378:	f000 0220 	and.w	r2, r0, #32
  40137c:	b2d1      	uxtb	r1, r2
  40137e:	b111      	cbz	r1, 401386 <ili93xx_draw_string+0xae>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  401380:	4628      	mov	r0, r5
  401382:	9902      	ldr	r1, [sp, #8]
  401384:	47b8      	blx	r7
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  401386:	f814 3c01 	ldrb.w	r3, [r4, #-1]
  40138a:	f003 0010 	and.w	r0, r3, #16
  40138e:	b2c2      	uxtb	r2, r0
  401390:	b112      	cbz	r2, 401398 <ili93xx_draw_string+0xc0>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  401392:	4628      	mov	r0, r5
  401394:	9903      	ldr	r1, [sp, #12]
  401396:	47b8      	blx	r7
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  401398:	f814 1c01 	ldrb.w	r1, [r4, #-1]
  40139c:	f001 0308 	and.w	r3, r1, #8
  4013a0:	b2d8      	uxtb	r0, r3
  4013a2:	b110      	cbz	r0, 4013aa <ili93xx_draw_string+0xd2>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  4013a4:	4628      	mov	r0, r5
  4013a6:	9904      	ldr	r1, [sp, #16]
  4013a8:	47b8      	blx	r7
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  4013aa:	f814 2c01 	ldrb.w	r2, [r4, #-1]
  4013ae:	f002 0104 	and.w	r1, r2, #4
  4013b2:	b2cb      	uxtb	r3, r1
  4013b4:	b11b      	cbz	r3, 4013be <ili93xx_draw_string+0xe6>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  4013b6:	4628      	mov	r0, r5
  4013b8:	f10b 0105 	add.w	r1, fp, #5
  4013bc:	47b8      	blx	r7
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  4013be:	f814 0c01 	ldrb.w	r0, [r4, #-1]
  4013c2:	f000 0202 	and.w	r2, r0, #2
  4013c6:	b2d1      	uxtb	r1, r2
  4013c8:	b119      	cbz	r1, 4013d2 <ili93xx_draw_string+0xfa>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  4013ca:	4628      	mov	r0, r5
  4013cc:	f10b 0106 	add.w	r1, fp, #6
  4013d0:	47b8      	blx	r7
		/**
		 * Draw pixel on screen depending on the corresponding bit value
		 * from the charset
		 */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  4013d2:	f814 4c01 	ldrb.w	r4, [r4, #-1]
  4013d6:	f014 0f01 	tst.w	r4, #1
  4013da:	d003      	beq.n	4013e4 <ili93xx_draw_string+0x10c>
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
  4013dc:	4628      	mov	r0, r5
  4013de:	f10b 0107 	add.w	r1, fp, #7
  4013e2:	47b8      	blx	r7
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili93xx_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  4013e4:	464c      	mov	r4, r9
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  4013e6:	f899 3001 	ldrb.w	r3, [r9, #1]
  4013ea:	f013 0f80 	tst.w	r3, #128	; 0x80
  4013ee:	d003      	beq.n	4013f8 <ili93xx_draw_string+0x120>
				ili93xx_draw_pixel(ul_x + col, ul_y + row + 8);
  4013f0:	4628      	mov	r0, r5
  4013f2:	f10b 0108 	add.w	r1, fp, #8
  4013f6:	47b8      	blx	r7
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  4013f8:	7860      	ldrb	r0, [r4, #1]
  4013fa:	f000 0240 	and.w	r2, r0, #64	; 0x40
  4013fe:	b2d1      	uxtb	r1, r2
  401400:	b119      	cbz	r1, 40140a <ili93xx_draw_string+0x132>
				ili93xx_draw_pixel(ul_x + col, ul_y + row + 8);
  401402:	4628      	mov	r0, r5
  401404:	f10b 0109 	add.w	r1, fp, #9
  401408:	47b8      	blx	r7
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  40140a:	7863      	ldrb	r3, [r4, #1]
  40140c:	f003 0020 	and.w	r0, r3, #32
  401410:	b2c2      	uxtb	r2, r0
  401412:	b11a      	cbz	r2, 40141c <ili93xx_draw_string+0x144>
				ili93xx_draw_pixel(ul_x + col, ul_y + row + 8);
  401414:	4628      	mov	r0, r5
  401416:	f10b 010a 	add.w	r1, fp, #10
  40141a:	47b8      	blx	r7
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  40141c:	7861      	ldrb	r1, [r4, #1]
  40141e:	f001 0310 	and.w	r3, r1, #16
  401422:	b2d8      	uxtb	r0, r3
  401424:	b118      	cbz	r0, 40142e <ili93xx_draw_string+0x156>
				ili93xx_draw_pixel(ul_x + col, ul_y + row + 8);
  401426:	4628      	mov	r0, r5
  401428:	f10b 010b 	add.w	r1, fp, #11
  40142c:	47b8      	blx	r7
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  40142e:	7862      	ldrb	r2, [r4, #1]
  401430:	f002 0108 	and.w	r1, r2, #8
  401434:	b2cb      	uxtb	r3, r1
  401436:	b11b      	cbz	r3, 401440 <ili93xx_draw_string+0x168>
				ili93xx_draw_pixel(ul_x + col, ul_y + row + 8);
  401438:	4628      	mov	r0, r5
  40143a:	f10b 010c 	add.w	r1, fp, #12
  40143e:	47b8      	blx	r7
				ili93xx_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  401440:	7860      	ldrb	r0, [r4, #1]
  401442:	f000 0204 	and.w	r2, r0, #4
  401446:	b2d1      	uxtb	r1, r2
  401448:	b119      	cbz	r1, 401452 <ili93xx_draw_string+0x17a>
				ili93xx_draw_pixel(ul_x + col, ul_y + row + 8);
  40144a:	4628      	mov	r0, r5
  40144c:	f10b 010d 	add.w	r1, fp, #13
  401450:	47b8      	blx	r7
  401452:	f109 0902 	add.w	r9, r9, #2
  401456:	f106 0602 	add.w	r6, r6, #2
  40145a:	f105 0501 	add.w	r5, r5, #1
	 * Compute offset according of the specified ASCII character
	 *  Note: the first 32 characters of the ASCII table are not handled
	 */
	offset = ((uint32_t)uc_c - 0x20) * 20;

	for (col = 0; col < 10; col++) {
  40145e:	4546      	cmp	r6, r8
  401460:	f47f af76 	bne.w	401350 <ili93xx_draw_string+0x78>
  401464:	46b9      	mov	r9, r7
			/**
			 * Draw the character and place cursor right after (font
			 * width + 2)
			 */
			ili93xx_draw_char(ul_x, ul_y, *p_str);
			ul_x += gfont.width + 2;
  401466:	f10a 0a0c 	add.w	sl, sl, #12
 */
void ili93xx_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
{
	uint32_t xorg = ul_x;

	while (*p_str != 0) {
  40146a:	9800      	ldr	r0, [sp, #0]
  40146c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  401470:	9000      	str	r0, [sp, #0]
  401472:	2b00      	cmp	r3, #0
  401474:	f47f af48 	bne.w	401308 <ili93xx_draw_string+0x30>
			ul_x += gfont.width + 2;
		}

		p_str++;
	}
}
  401478:	b009      	add	sp, #36	; 0x24
  40147a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40147e:	bf00      	nop

00401480 <smc_set_setup_timing>:
 * \param ul_setup_timing Setup timing for NWE, NCS, NRD.
 */
void smc_set_setup_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_setup_timing)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_SETUP = ul_setup_timing;
  401480:	ea4f 1101 	mov.w	r1, r1, lsl #4
  401484:	5042      	str	r2, [r0, r1]
  401486:	4770      	bx	lr

00401488 <smc_set_pulse_timing>:
 * \param ul_pulse_timing Pulse timing for NWE,NCS,NRD.
 */
void smc_set_pulse_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_pulse_timing)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_PULSE = ul_pulse_timing;
  401488:	eb00 1101 	add.w	r1, r0, r1, lsl #4
  40148c:	604a      	str	r2, [r1, #4]
  40148e:	4770      	bx	lr

00401490 <smc_set_cycle_timing>:
 * \param ul_cycle_timing Cycle timing for NWE and NRD.
 */
void smc_set_cycle_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_cycle_timing)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_CYCLE = ul_cycle_timing;
  401490:	eb00 1101 	add.w	r1, r0, r1, lsl #4
  401494:	608a      	str	r2, [r1, #8]
  401496:	4770      	bx	lr

00401498 <smc_set_mode>:
 * \param ul_cs Chip select number to be set.
 * \param ul_mode SMC mode.
 */
void smc_set_mode(Smc *p_smc, uint32_t ul_cs, uint32_t ul_mode)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_MODE = ul_mode;
  401498:	eb00 1101 	add.w	r1, r0, r1, lsl #4
  40149c:	60ca      	str	r2, [r1, #12]
  40149e:	4770      	bx	lr

004014a0 <pio_pull_up>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4014a0:	b10a      	cbz	r2, 4014a6 <pio_pull_up+0x6>
		p_pio->PIO_PUER = ul_mask;
  4014a2:	6641      	str	r1, [r0, #100]	; 0x64
  4014a4:	4770      	bx	lr
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4014a6:	6601      	str	r1, [r0, #96]	; 0x60
  4014a8:	4770      	bx	lr
  4014aa:	bf00      	nop

004014ac <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  4014ac:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  4014ae:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP)
	switch (ul_type) {
  4014b0:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  4014b4:	d030      	beq.n	401518 <pio_set_peripheral+0x6c>
  4014b6:	d808      	bhi.n	4014ca <pio_set_peripheral+0x1e>
  4014b8:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  4014bc:	d014      	beq.n	4014e8 <pio_set_peripheral+0x3c>
  4014be:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  4014c2:	d01e      	beq.n	401502 <pio_set_peripheral+0x56>
  4014c4:	2900      	cmp	r1, #0
  4014c6:	d03b      	beq.n	401540 <pio_set_peripheral+0x94>
  4014c8:	e039      	b.n	40153e <pio_set_peripheral+0x92>
  4014ca:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  4014ce:	d037      	beq.n	401540 <pio_set_peripheral+0x94>
  4014d0:	d803      	bhi.n	4014da <pio_set_peripheral+0x2e>
  4014d2:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  4014d6:	d132      	bne.n	40153e <pio_set_peripheral+0x92>
  4014d8:	e029      	b.n	40152e <pio_set_peripheral+0x82>
  4014da:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  4014de:	d02f      	beq.n	401540 <pio_set_peripheral+0x94>
  4014e0:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  4014e4:	d12b      	bne.n	40153e <pio_set_peripheral+0x92>
  4014e6:	e02b      	b.n	401540 <pio_set_peripheral+0x94>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4014e8:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4014ea:	6f04      	ldr	r4, [r0, #112]	; 0x70
  4014ec:	ea6f 0302 	mvn.w	r3, r2
  4014f0:	4021      	ands	r1, r4
  4014f2:	4019      	ands	r1, r3
  4014f4:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4014f6:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4014f8:	6f44      	ldr	r4, [r0, #116]	; 0x74
  4014fa:	4021      	ands	r1, r4
  4014fc:	400b      	ands	r3, r1
  4014fe:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401500:	e01d      	b.n	40153e <pio_set_peripheral+0x92>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401502:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401504:	ea42 0103 	orr.w	r1, r2, r3
  401508:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40150a:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  40150c:	6f41      	ldr	r1, [r0, #116]	; 0x74
  40150e:	400b      	ands	r3, r1
  401510:	ea23 0302 	bic.w	r3, r3, r2
  401514:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  401516:	e012      	b.n	40153e <pio_set_peripheral+0x92>
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  401518:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40151a:	6f01      	ldr	r1, [r0, #112]	; 0x70
  40151c:	400b      	ands	r3, r1
  40151e:	ea23 0302 	bic.w	r3, r3, r2
  401522:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401524:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401526:	ea42 0103 	orr.w	r1, r2, r3
  40152a:	6741      	str	r1, [r0, #116]	; 0x74
		break;
  40152c:	e007      	b.n	40153e <pio_set_peripheral+0x92>

	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40152e:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  401530:	ea42 0103 	orr.w	r1, r2, r3
  401534:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  401536:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  401538:	ea42 0103 	orr.w	r1, r2, r3
  40153c:	6741      	str	r1, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  40153e:	6042      	str	r2, [r0, #4]
}
  401540:	bc10      	pop	{r4}
  401542:	4770      	bx	lr

00401544 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  401544:	6441      	str	r1, [r0, #68]	; 0x44
  401546:	4770      	bx	lr

00401548 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  401548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40154a:	4604      	mov	r4, r0
  40154c:	460d      	mov	r5, r1
  40154e:	4616      	mov	r6, r2
  401550:	461f      	mov	r7, r3
	pio_disable_interrupt(p_pio, ul_mask);
  401552:	f241 5345 	movw	r3, #5445	; 0x1545
  401556:	f2c0 0340 	movt	r3, #64	; 0x40
  40155a:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  40155c:	4620      	mov	r0, r4
  40155e:	4629      	mov	r1, r5
  401560:	9a06      	ldr	r2, [sp, #24]
  401562:	f241 43a1 	movw	r3, #5281	; 0x14a1
  401566:	f2c0 0340 	movt	r3, #64	; 0x40
  40156a:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40156c:	b10f      	cbz	r7, 401572 <pio_set_output+0x2a>
		p_pio->PIO_MDER = ul_mask;
  40156e:	6525      	str	r5, [r4, #80]	; 0x50
  401570:	e000      	b.n	401574 <pio_set_output+0x2c>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  401572:	6565      	str	r5, [r4, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  401574:	b10e      	cbz	r6, 40157a <pio_set_output+0x32>
		p_pio->PIO_SODR = ul_mask;
  401576:	6325      	str	r5, [r4, #48]	; 0x30
  401578:	e000      	b.n	40157c <pio_set_output+0x34>
	} else {
		p_pio->PIO_CODR = ul_mask;
  40157a:	6365      	str	r5, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  40157c:	6125      	str	r5, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  40157e:	6025      	str	r5, [r4, #0]
  401580:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401582:	bf00      	nop

00401584 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  401584:	b570      	push	{r4, r5, r6, lr}
  401586:	4604      	mov	r4, r0
  401588:	460d      	mov	r5, r1
  40158a:	4616      	mov	r6, r2
	pio_disable_interrupt(p_pio, ul_mask);
  40158c:	f241 5345 	movw	r3, #5445	; 0x1545
  401590:	f2c0 0340 	movt	r3, #64	; 0x40
  401594:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  401596:	4620      	mov	r0, r4
  401598:	4629      	mov	r1, r5
  40159a:	f006 0201 	and.w	r2, r6, #1
  40159e:	f241 43a1 	movw	r3, #5281	; 0x14a1
  4015a2:	f2c0 0340 	movt	r3, #64	; 0x40
  4015a6:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  4015a8:	f016 0f0a 	tst.w	r6, #10
		p_pio->PIO_IFER = ul_mask;
  4015ac:	bf14      	ite	ne
  4015ae:	6225      	strne	r5, [r4, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  4015b0:	6265      	streq	r5, [r4, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  4015b2:	f016 0f02 	tst.w	r6, #2
  4015b6:	d002      	beq.n	4015be <pio_set_input+0x3a>
		p_pio->PIO_IFSCDR = ul_mask;
  4015b8:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
  4015bc:	e004      	b.n	4015c8 <pio_set_input+0x44>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  4015be:	f016 0f08 	tst.w	r6, #8
			p_pio->PIO_IFSCER = ul_mask;
  4015c2:	bf18      	it	ne
  4015c4:	f8c4 5084 	strne.w	r5, [r4, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  4015c8:	6165      	str	r5, [r4, #20]
	p_pio->PIO_PER = ul_mask;
  4015ca:	6025      	str	r5, [r4, #0]
  4015cc:	bd70      	pop	{r4, r5, r6, pc}
  4015ce:	bf00      	nop

004015d0 <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  4015d0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  4015d2:	4770      	bx	lr

004015d4 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  4015d4:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  4015d6:	4770      	bx	lr

004015d8 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  4015d8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4015da:	b083      	sub	sp, #12
  4015dc:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4015de:	ea4f 1650 	mov.w	r6, r0, lsr #5
  4015e2:	f506 1100 	add.w	r1, r6, #2097152	; 0x200000
  4015e6:	f201 7207 	addw	r2, r1, #1799	; 0x707
  4015ea:	ea4f 2642 	mov.w	r6, r2, lsl #9
#endif

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4015ee:	f005 44f0 	and.w	r4, r5, #2013265920	; 0x78000000
  4015f2:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
  4015f6:	d064      	beq.n	4016c2 <pio_configure_pin+0xea>
  4015f8:	d80a      	bhi.n	401610 <pio_configure_pin+0x38>
  4015fa:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
  4015fe:	d02c      	beq.n	40165a <pio_configure_pin+0x82>
  401600:	f1b4 5fc0 	cmp.w	r4, #402653184	; 0x18000000
  401604:	d043      	beq.n	40168e <pio_configure_pin+0xb6>
  401606:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
  40160a:	f040 809d 	bne.w	401748 <pio_configure_pin+0x170>
  40160e:	e00a      	b.n	401626 <pio_configure_pin+0x4e>
  401610:	f1b4 5f40 	cmp.w	r4, #805306368	; 0x30000000
  401614:	d07e      	beq.n	401714 <pio_configure_pin+0x13c>
  401616:	f1b4 5f60 	cmp.w	r4, #939524096	; 0x38000000
  40161a:	d07b      	beq.n	401714 <pio_configure_pin+0x13c>
  40161c:	f1b4 5f20 	cmp.w	r4, #671088640	; 0x28000000
  401620:	f040 8092 	bne.w	401748 <pio_configure_pin+0x170>
  401624:	e067      	b.n	4016f6 <pio_configure_pin+0x11e>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  401626:	f000 031f 	and.w	r3, r0, #31
  40162a:	f04f 0401 	mov.w	r4, #1
  40162e:	fa04 f703 	lsl.w	r7, r4, r3
  401632:	4630      	mov	r0, r6
  401634:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  401638:	463a      	mov	r2, r7
  40163a:	f241 43ad 	movw	r3, #5293	; 0x14ad
  40163e:	f2c0 0340 	movt	r3, #64	; 0x40
  401642:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401644:	4630      	mov	r0, r6
  401646:	4639      	mov	r1, r7
  401648:	ea05 0204 	and.w	r2, r5, r4
  40164c:	f241 43a1 	movw	r3, #5281	; 0x14a1
  401650:	f2c0 0340 	movt	r3, #64	; 0x40
  401654:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401656:	4620      	mov	r0, r4
	switch (ul_flags & PIO_TYPE_Msk) {
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401658:	e078      	b.n	40174c <pio_configure_pin+0x174>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  40165a:	f000 071f 	and.w	r7, r0, #31
  40165e:	f04f 0401 	mov.w	r4, #1
  401662:	fa04 f707 	lsl.w	r7, r4, r7
  401666:	4630      	mov	r0, r6
  401668:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  40166c:	463a      	mov	r2, r7
  40166e:	f241 43ad 	movw	r3, #5293	; 0x14ad
  401672:	f2c0 0340 	movt	r3, #64	; 0x40
  401676:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401678:	4630      	mov	r0, r6
  40167a:	4639      	mov	r1, r7
  40167c:	ea05 0204 	and.w	r2, r5, r4
  401680:	f241 43a1 	movw	r3, #5281	; 0x14a1
  401684:	f2c0 0340 	movt	r3, #64	; 0x40
  401688:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40168a:	4620      	mov	r0, r4
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  40168c:	e05e      	b.n	40174c <pio_configure_pin+0x174>
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  40168e:	f000 001f 	and.w	r0, r0, #31
  401692:	f04f 0401 	mov.w	r4, #1
  401696:	fa04 f700 	lsl.w	r7, r4, r0
  40169a:	4630      	mov	r0, r6
  40169c:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  4016a0:	463a      	mov	r2, r7
  4016a2:	f241 43ad 	movw	r3, #5293	; 0x14ad
  4016a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4016aa:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  4016ac:	4630      	mov	r0, r6
  4016ae:	4639      	mov	r1, r7
  4016b0:	ea05 0204 	and.w	r2, r5, r4
  4016b4:	f241 43a1 	movw	r3, #5281	; 0x14a1
  4016b8:	f2c0 0340 	movt	r3, #64	; 0x40
  4016bc:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4016be:	4620      	mov	r0, r4
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  4016c0:	e044      	b.n	40174c <pio_configure_pin+0x174>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  4016c2:	f000 021f 	and.w	r2, r0, #31
  4016c6:	f04f 0401 	mov.w	r4, #1
  4016ca:	fa04 f702 	lsl.w	r7, r4, r2
  4016ce:	4630      	mov	r0, r6
  4016d0:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  4016d4:	463a      	mov	r2, r7
  4016d6:	f241 43ad 	movw	r3, #5293	; 0x14ad
  4016da:	f2c0 0340 	movt	r3, #64	; 0x40
  4016de:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  4016e0:	4630      	mov	r0, r6
  4016e2:	4639      	mov	r1, r7
  4016e4:	ea05 0204 	and.w	r2, r5, r4
  4016e8:	f241 43a1 	movw	r3, #5281	; 0x14a1
  4016ec:	f2c0 0340 	movt	r3, #64	; 0x40
  4016f0:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4016f2:	4620      	mov	r0, r4
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  4016f4:	e02a      	b.n	40174c <pio_configure_pin+0x174>
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  4016f6:	f000 011f 	and.w	r1, r0, #31
  4016fa:	f04f 0401 	mov.w	r4, #1
  4016fe:	4630      	mov	r0, r6
  401700:	fa04 f101 	lsl.w	r1, r4, r1
  401704:	462a      	mov	r2, r5
  401706:	f241 5385 	movw	r3, #5509	; 0x1585
  40170a:	f2c0 0340 	movt	r3, #64	; 0x40
  40170e:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401710:	4620      	mov	r0, r4
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  401712:	e01b      	b.n	40174c <pio_configure_pin+0x174>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401714:	f000 031f 	and.w	r3, r0, #31
  401718:	f04f 0401 	mov.w	r4, #1
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  40171c:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  401720:	ea05 0004 	and.w	r0, r5, r4
  401724:	9000      	str	r0, [sp, #0]
  401726:	4630      	mov	r0, r6
  401728:	fa04 f103 	lsl.w	r1, r4, r3
  40172c:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
  401730:	bf14      	ite	ne
  401732:	2200      	movne	r2, #0
  401734:	2201      	moveq	r2, #1
  401736:	f3c5 0380 	ubfx	r3, r5, #2, #1
  40173a:	f241 5549 	movw	r5, #5449	; 0x1549
  40173e:	f2c0 0540 	movt	r5, #64	; 0x40
  401742:	47a8      	blx	r5

	default:
		return 0;
	}

	return 1;
  401744:	4620      	mov	r0, r4
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  401746:	e001      	b.n	40174c <pio_configure_pin+0x174>

	default:
		return 0;
  401748:	f04f 0000 	mov.w	r0, #0
	}

	return 1;
}
  40174c:	b003      	add	sp, #12
  40174e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00401750 <pio_configure_pin_group>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  401750:	b5f0      	push	{r4, r5, r6, r7, lr}
  401752:	b083      	sub	sp, #12
  401754:	4607      	mov	r7, r0
  401756:	460e      	mov	r6, r1
  401758:	4615      	mov	r5, r2
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40175a:	f002 44f0 	and.w	r4, r2, #2013265920	; 0x78000000
  40175e:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
  401762:	d050      	beq.n	401806 <pio_configure_pin_group+0xb6>
  401764:	d809      	bhi.n	40177a <pio_configure_pin_group+0x2a>
  401766:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
  40176a:	d024      	beq.n	4017b6 <pio_configure_pin_group+0x66>
  40176c:	f1b4 5fc0 	cmp.w	r4, #402653184	; 0x18000000
  401770:	d035      	beq.n	4017de <pio_configure_pin_group+0x8e>
  401772:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
  401776:	d178      	bne.n	40186a <pio_configure_pin_group+0x11a>
  401778:	e009      	b.n	40178e <pio_configure_pin_group+0x3e>
  40177a:	f1b4 5f40 	cmp.w	r4, #805306368	; 0x30000000
  40177e:	d05e      	beq.n	40183e <pio_configure_pin_group+0xee>
  401780:	f1b4 5f60 	cmp.w	r4, #939524096	; 0x38000000
  401784:	d05b      	beq.n	40183e <pio_configure_pin_group+0xee>
  401786:	f1b4 5f20 	cmp.w	r4, #671088640	; 0x28000000
  40178a:	d16e      	bne.n	40186a <pio_configure_pin_group+0x11a>
  40178c:	e04f      	b.n	40182e <pio_configure_pin_group+0xde>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
  40178e:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  401792:	4632      	mov	r2, r6
  401794:	f241 43ad 	movw	r3, #5293	; 0x14ad
  401798:	f2c0 0340 	movt	r3, #64	; 0x40
  40179c:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  40179e:	4638      	mov	r0, r7
  4017a0:	4631      	mov	r1, r6
  4017a2:	f005 0201 	and.w	r2, r5, #1
  4017a6:	f241 43a1 	movw	r3, #5281	; 0x14a1
  4017aa:	f2c0 0340 	movt	r3, #64	; 0x40
  4017ae:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4017b0:	f04f 0001 	mov.w	r0, #1
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  4017b4:	e05b      	b.n	40186e <pio_configure_pin_group+0x11e>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, ul_mask);
  4017b6:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4017ba:	4632      	mov	r2, r6
  4017bc:	f241 43ad 	movw	r3, #5293	; 0x14ad
  4017c0:	f2c0 0340 	movt	r3, #64	; 0x40
  4017c4:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  4017c6:	4638      	mov	r0, r7
  4017c8:	4631      	mov	r1, r6
  4017ca:	f005 0201 	and.w	r2, r5, #1
  4017ce:	f241 43a1 	movw	r3, #5281	; 0x14a1
  4017d2:	f2c0 0340 	movt	r3, #64	; 0x40
  4017d6:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4017d8:	f04f 0001 	mov.w	r0, #1
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  4017dc:	e047      	b.n	40186e <pio_configure_pin_group+0x11e>
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
  4017de:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  4017e2:	4632      	mov	r2, r6
  4017e4:	f241 43ad 	movw	r3, #5293	; 0x14ad
  4017e8:	f2c0 0340 	movt	r3, #64	; 0x40
  4017ec:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  4017ee:	4638      	mov	r0, r7
  4017f0:	4631      	mov	r1, r6
  4017f2:	f005 0201 	and.w	r2, r5, #1
  4017f6:	f241 43a1 	movw	r3, #5281	; 0x14a1
  4017fa:	f2c0 0340 	movt	r3, #64	; 0x40
  4017fe:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401800:	f04f 0001 	mov.w	r0, #1
		break;
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  401804:	e033      	b.n	40186e <pio_configure_pin_group+0x11e>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  401806:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  40180a:	4632      	mov	r2, r6
  40180c:	f241 43ad 	movw	r3, #5293	; 0x14ad
  401810:	f2c0 0340 	movt	r3, #64	; 0x40
  401814:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  401816:	4638      	mov	r0, r7
  401818:	4631      	mov	r1, r6
  40181a:	f005 0201 	and.w	r2, r5, #1
  40181e:	f241 43a1 	movw	r3, #5281	; 0x14a1
  401822:	f2c0 0340 	movt	r3, #64	; 0x40
  401826:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401828:	f04f 0001 	mov.w	r0, #1
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  40182c:	e01f      	b.n	40186e <pio_configure_pin_group+0x11e>
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  40182e:	f241 5385 	movw	r3, #5509	; 0x1585
  401832:	f2c0 0340 	movt	r3, #64	; 0x40
  401836:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401838:	f04f 0001 	mov.w	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
  40183c:	e017      	b.n	40186e <pio_configure_pin_group+0x11e>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  40183e:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
  401842:	f005 0001 	and.w	r0, r5, #1
  401846:	9000      	str	r0, [sp, #0]
  401848:	4638      	mov	r0, r7
  40184a:	4631      	mov	r1, r6
  40184c:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
  401850:	bf14      	ite	ne
  401852:	2200      	movne	r2, #0
  401854:	2201      	moveq	r2, #1
  401856:	f3c5 0380 	ubfx	r3, r5, #2, #1
  40185a:	f241 5449 	movw	r4, #5449	; 0x1549
  40185e:	f2c0 0440 	movt	r4, #64	; 0x40
  401862:	47a0      	blx	r4

	default:
		return 0;
	}

	return 1;
  401864:	f04f 0001 	mov.w	r0, #1
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  401868:	e001      	b.n	40186e <pio_configure_pin_group+0x11e>

	default:
		return 0;
  40186a:	f04f 0000 	mov.w	r0, #0
	}

	return 1;
}
  40186e:	b003      	add	sp, #12
  401870:	bdf0      	pop	{r4, r5, r6, r7, pc}
  401872:	bf00      	nop

00401874 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  401874:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401878:	4680      	mov	r8, r0
  40187a:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40187c:	f241 53d1 	movw	r3, #5585	; 0x15d1
  401880:	f2c0 0340 	movt	r3, #64	; 0x40
  401884:	4798      	blx	r3
  401886:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  401888:	4640      	mov	r0, r8
  40188a:	f241 51d5 	movw	r1, #5589	; 0x15d5
  40188e:	f2c0 0140 	movt	r1, #64	; 0x40
  401892:	4788      	blx	r1

	/* Check pending events */
	if (status != 0) {
  401894:	4005      	ands	r5, r0
  401896:	d014      	beq.n	4018c2 <pio_handler_process+0x4e>
  401898:	4c12      	ldr	r4, [pc, #72]	; (4018e4 <pio_handler_process+0x70>)
 * \brief Process an interrupt request on the given PIO controller.
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
  40189a:	4627      	mov	r7, r4
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  40189c:	f854 0c0c 	ldr.w	r0, [r4, #-12]
  4018a0:	42b0      	cmp	r0, r6
  4018a2:	d10a      	bne.n	4018ba <pio_handler_process+0x46>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  4018a4:	f854 1c08 	ldr.w	r1, [r4, #-8]
  4018a8:	4229      	tst	r1, r5
  4018aa:	d006      	beq.n	4018ba <pio_handler_process+0x46>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  4018ac:	6822      	ldr	r2, [r4, #0]
  4018ae:	4630      	mov	r0, r6
  4018b0:	4790      	blx	r2
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  4018b2:	f854 3c08 	ldr.w	r3, [r4, #-8]
  4018b6:	ea25 0503 	bic.w	r5, r5, r3
  4018ba:	f104 0410 	add.w	r4, r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  4018be:	2d00      	cmp	r5, #0
  4018c0:	d1eb      	bne.n	40189a <pio_handler_process+0x26>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  4018c2:	f640 41e8 	movw	r1, #3304	; 0xce8
  4018c6:	f2c2 0100 	movt	r1, #8192	; 0x2000
  4018ca:	6808      	ldr	r0, [r1, #0]
  4018cc:	b138      	cbz	r0, 4018de <pio_handler_process+0x6a>
		if (pio_capture_handler) {
  4018ce:	f640 4230 	movw	r2, #3120	; 0xc30
  4018d2:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4018d6:	6813      	ldr	r3, [r2, #0]
  4018d8:	b10b      	cbz	r3, 4018de <pio_handler_process+0x6a>
			pio_capture_handler(p_pio);
  4018da:	4640      	mov	r0, r8
  4018dc:	4798      	blx	r3
  4018de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4018e2:	bf00      	nop
  4018e4:	20000c40 	.word	0x20000c40

004018e8 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  4018e8:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  4018ea:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  4018ee:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4018f2:	f04f 010b 	mov.w	r1, #11
  4018f6:	f641 0375 	movw	r3, #6261	; 0x1875
  4018fa:	f2c0 0340 	movt	r3, #64	; 0x40
  4018fe:	4798      	blx	r3
  401900:	bd08      	pop	{r3, pc}
  401902:	bf00      	nop

00401904 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  401904:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  401906:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  40190a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40190e:	f04f 010c 	mov.w	r1, #12
  401912:	f641 0375 	movw	r3, #6261	; 0x1875
  401916:	f2c0 0340 	movt	r3, #64	; 0x40
  40191a:	4798      	blx	r3
  40191c:	bd08      	pop	{r3, pc}
  40191e:	bf00      	nop

00401920 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  401920:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  401922:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  401926:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40192a:	f04f 010d 	mov.w	r1, #13
  40192e:	f641 0375 	movw	r3, #6261	; 0x1875
  401932:	f2c0 0340 	movt	r3, #64	; 0x40
  401936:	4798      	blx	r3
  401938:	bd08      	pop	{r3, pc}
  40193a:	bf00      	nop

0040193c <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  40193c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401940:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401944:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  401946:	f022 0170 	bic.w	r1, r2, #112	; 0x70
  40194a:	4308      	orrs	r0, r1
  40194c:	6318      	str	r0, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40194e:	6e98      	ldr	r0, [r3, #104]	; 0x68
  401950:	f010 0f08 	tst.w	r0, #8
  401954:	d007      	beq.n	401966 <pmc_switch_mck_to_pllack+0x2a>
  401956:	e010      	b.n	40197a <pmc_switch_mck_to_pllack+0x3e>
  401958:	f100 33ff 	add.w	r3, r0, #4294967295
  40195c:	6e90      	ldr	r0, [r2, #104]	; 0x68
  40195e:	f010 0f08 	tst.w	r0, #8
  401962:	d038      	beq.n	4019d6 <pmc_switch_mck_to_pllack+0x9a>
  401964:	e009      	b.n	40197a <pmc_switch_mck_to_pllack+0x3e>
  401966:	f44f 6000 	mov.w	r0, #2048	; 0x800
  40196a:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40196e:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401972:	6e91      	ldr	r1, [r2, #104]	; 0x68
  401974:	f011 0f08 	tst.w	r1, #8
  401978:	d0ee      	beq.n	401958 <pmc_switch_mck_to_pllack+0x1c>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40197a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  40197e:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401982:	6b0a      	ldr	r2, [r1, #48]	; 0x30
  401984:	f022 0303 	bic.w	r3, r2, #3
  401988:	f043 0002 	orr.w	r0, r3, #2
  40198c:	6308      	str	r0, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40198e:	6e89      	ldr	r1, [r1, #104]	; 0x68
  401990:	f011 0f08 	tst.w	r1, #8
  401994:	d009      	beq.n	4019aa <pmc_switch_mck_to_pllack+0x6e>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  401996:	f04f 0000 	mov.w	r0, #0
  40199a:	4770      	bx	lr
  40199c:	f103 33ff 	add.w	r3, r3, #4294967295
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4019a0:	6e91      	ldr	r1, [r2, #104]	; 0x68
  4019a2:	f011 0f08 	tst.w	r1, #8
  4019a6:	d013      	beq.n	4019d0 <pmc_switch_mck_to_pllack+0x94>
  4019a8:	e009      	b.n	4019be <pmc_switch_mck_to_pllack+0x82>
  4019aa:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4019ae:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4019b2:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4019b6:	6e90      	ldr	r0, [r2, #104]	; 0x68
  4019b8:	f010 0f08 	tst.w	r0, #8
  4019bc:	d0ee      	beq.n	40199c <pmc_switch_mck_to_pllack+0x60>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4019be:	f04f 0000 	mov.w	r0, #0
  4019c2:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4019c4:	f04f 0001 	mov.w	r0, #1
  4019c8:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4019ca:	f04f 0001 	mov.w	r0, #1
		}
	}

	return 0;
}
  4019ce:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  4019d0:	3b01      	subs	r3, #1
  4019d2:	d1f0      	bne.n	4019b6 <pmc_switch_mck_to_pllack+0x7a>
  4019d4:	e7f9      	b.n	4019ca <pmc_switch_mck_to_pllack+0x8e>
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  4019d6:	1e58      	subs	r0, r3, #1
  4019d8:	d1cb      	bne.n	401972 <pmc_switch_mck_to_pllack+0x36>
  4019da:	e7f3      	b.n	4019c4 <pmc_switch_mck_to_pllack+0x88>

004019dc <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  4019dc:	b188      	cbz	r0, 401a02 <pmc_switch_mainck_to_xtal+0x26>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4019de:	f44f 6180 	mov.w	r1, #1024	; 0x400
  4019e2:	f2c4 010e 	movt	r1, #16398	; 0x400e
  4019e6:	6a08      	ldr	r0, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  4019e8:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  4019ec:	f6cf 62c8 	movt	r2, #65224	; 0xfec8
  4019f0:	4002      	ands	r2, r0
  4019f2:	f04f 0302 	mov.w	r3, #2
  4019f6:	f2c0 1337 	movt	r3, #311	; 0x137
  4019fa:	ea42 0003 	orr.w	r0, r2, r3
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4019fe:	6208      	str	r0, [r1, #32]
  401a00:	4770      	bx	lr
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  401a02:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a06:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a0a:	6a1a      	ldr	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  401a0c:	f422 105c 	bic.w	r0, r2, #3604480	; 0x370000
  401a10:	f020 0203 	bic.w	r2, r0, #3
  401a14:	f442 105c 	orr.w	r0, r2, #3604480	; 0x370000
  401a18:	f040 0201 	orr.w	r2, r0, #1
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  401a1c:	ea4f 6101 	mov.w	r1, r1, lsl #24
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  401a20:	ea42 4011 	orr.w	r0, r2, r1, lsr #16
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  401a24:	6218      	str	r0, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  401a26:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401a2a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401a2e:	6e93      	ldr	r3, [r2, #104]	; 0x68
  401a30:	f013 0f01 	tst.w	r3, #1
  401a34:	d0fb      	beq.n	401a2e <pmc_switch_mainck_to_xtal+0x52>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  401a36:	f44f 6180 	mov.w	r1, #1024	; 0x400
  401a3a:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401a3e:	6a08      	ldr	r0, [r1, #32]
  401a40:	f040 729b 	orr.w	r2, r0, #20316160	; 0x1360000
  401a44:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
  401a48:	620b      	str	r3, [r1, #32]
  401a4a:	4770      	bx	lr

00401a4c <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  401a4c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a50:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a54:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401a56:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  401a5a:	4770      	bx	lr

00401a5c <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  401a5c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a60:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a64:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  401a68:	629a      	str	r2, [r3, #40]	; 0x28
  401a6a:	4770      	bx	lr

00401a6c <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  401a6c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401a70:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a74:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401a76:	f000 0002 	and.w	r0, r0, #2
  401a7a:	4770      	bx	lr

00401a7c <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  401a7c:	2822      	cmp	r0, #34	; 0x22
  401a7e:	d835      	bhi.n	401aec <pmc_enable_periph_clk+0x70>
		return 1;
	}

	if (ul_id < 32) {
  401a80:	281f      	cmp	r0, #31
  401a82:	d817      	bhi.n	401ab4 <pmc_enable_periph_clk+0x38>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  401a84:	f44f 6180 	mov.w	r1, #1024	; 0x400
  401a88:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401a8c:	698a      	ldr	r2, [r1, #24]
  401a8e:	f04f 0301 	mov.w	r3, #1
  401a92:	fa03 f300 	lsl.w	r3, r3, r0
  401a96:	401a      	ands	r2, r3
  401a98:	4293      	cmp	r3, r2
  401a9a:	d02a      	beq.n	401af2 <pmc_enable_periph_clk+0x76>
			PMC->PMC_PCER0 = 1 << ul_id;
  401a9c:	f04f 0101 	mov.w	r1, #1
  401aa0:	fa01 f000 	lsl.w	r0, r1, r0
  401aa4:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401aa8:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401aac:	6110      	str	r0, [r2, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  401aae:	f04f 0000 	mov.w	r0, #0
  401ab2:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CP)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  401ab4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401ab8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401abc:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CP)
	} else {
		ul_id -= 32;
  401ac0:	f1a0 0020 	sub.w	r0, r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  401ac4:	f04f 0101 	mov.w	r1, #1
  401ac8:	fa01 f100 	lsl.w	r1, r1, r0
  401acc:	400a      	ands	r2, r1
  401ace:	4291      	cmp	r1, r2
  401ad0:	d012      	beq.n	401af8 <pmc_enable_periph_clk+0x7c>
			PMC->PMC_PCER1 = 1 << ul_id;
  401ad2:	f04f 0301 	mov.w	r3, #1
  401ad6:	fa03 f000 	lsl.w	r0, r3, r0
  401ada:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401ade:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401ae2:	f8c2 0100 	str.w	r0, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  401ae6:	f04f 0000 	mov.w	r0, #0
  401aea:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  401aec:	f04f 0001 	mov.w	r0, #1
  401af0:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  401af2:	f04f 0000 	mov.w	r0, #0
  401af6:	4770      	bx	lr
  401af8:	f04f 0000 	mov.w	r0, #0
}
  401afc:	4770      	bx	lr
  401afe:	bf00      	nop

00401b00 <uart_init>:
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  401b00:	b410      	push	{r4}
	uint32_t cd = 0;

	/* Reset and disable receiver & transmitter */
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
  401b02:	f04f 03ac 	mov.w	r3, #172	; 0xac
  401b06:	6003      	str	r3, [r0, #0]
			| UART_CR_RXDIS | UART_CR_TXDIS;

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
  401b08:	680a      	ldr	r2, [r1, #0]
  401b0a:	684c      	ldr	r4, [r1, #4]
  401b0c:	fbb2 f3f4 	udiv	r3, r2, r4
  401b10:	ea4f 1313 	mov.w	r3, r3, lsr #4
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
  401b14:	f103 34ff 	add.w	r4, r3, #4294967295
  401b18:	f64f 72fe 	movw	r2, #65534	; 0xfffe
  401b1c:	4294      	cmp	r4, r2
  401b1e:	d80c      	bhi.n	401b3a <uart_init+0x3a>
		return 1;

	p_uart->UART_BRGR = cd;
  401b20:	6203      	str	r3, [r0, #32]
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;
  401b22:	6889      	ldr	r1, [r1, #8]
  401b24:	6041      	str	r1, [r0, #4]

	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  401b26:	f240 2302 	movw	r3, #514	; 0x202
  401b2a:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  401b2e:	f04f 0250 	mov.w	r2, #80	; 0x50
  401b32:	6002      	str	r2, [r0, #0]

	return 0;
  401b34:	f04f 0000 	mov.w	r0, #0
  401b38:	e001      	b.n	401b3e <uart_init+0x3e>

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
		return 1;
  401b3a:	f04f 0001 	mov.w	r0, #1

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;

	return 0;
}
  401b3e:	bc10      	pop	{r4}
  401b40:	4770      	bx	lr
  401b42:	bf00      	nop

00401b44 <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  401b44:	6943      	ldr	r3, [r0, #20]
  401b46:	f013 0f02 	tst.w	r3, #2
  401b4a:	d003      	beq.n	401b54 <uart_write+0x10>
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  401b4c:	61c1      	str	r1, [r0, #28]
	return 0;
  401b4e:	f04f 0000 	mov.w	r0, #0
  401b52:	4770      	bx	lr
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
		return 1;
  401b54:	f04f 0001 	mov.w	r0, #1

	/* Send character */
	p_uart->UART_THR = uc_data;
	return 0;
}
  401b58:	4770      	bx	lr
  401b5a:	bf00      	nop

00401b5c <uart_read>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
  401b5c:	6943      	ldr	r3, [r0, #20]
  401b5e:	f013 0f01 	tst.w	r3, #1
  401b62:	d004      	beq.n	401b6e <uart_read+0x12>
		return 1;

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
  401b64:	6980      	ldr	r0, [r0, #24]
  401b66:	7008      	strb	r0, [r1, #0]
	return 0;
  401b68:	f04f 0000 	mov.w	r0, #0
  401b6c:	4770      	bx	lr
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
		return 1;
  401b6e:	f04f 0001 	mov.w	r0, #1

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
	return 0;
}
  401b72:	4770      	bx	lr

00401b74 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  401b74:	6943      	ldr	r3, [r0, #20]
  401b76:	f013 0f02 	tst.w	r3, #2
  401b7a:	d007      	beq.n	401b8c <usart_write+0x18>
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  401b7c:	ea4f 51c1 	mov.w	r1, r1, lsl #23
  401b80:	ea4f 52d1 	mov.w	r2, r1, lsr #23
  401b84:	61c2      	str	r2, [r0, #28]
	return 0;
  401b86:	f04f 0000 	mov.w	r0, #0
  401b8a:	4770      	bx	lr
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
		return 1;
  401b8c:	f04f 0001 	mov.w	r0, #1
	}

	p_usart->US_THR = US_THR_TXCHR(c);
	return 0;
}
  401b90:	4770      	bx	lr
  401b92:	bf00      	nop

00401b94 <usart_read>:
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  401b94:	6943      	ldr	r3, [r0, #20]
  401b96:	f013 0f01 	tst.w	r3, #1
  401b9a:	d008      	beq.n	401bae <usart_read+0x1a>
		return 1;
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  401b9c:	6980      	ldr	r0, [r0, #24]
  401b9e:	ea4f 52c0 	mov.w	r2, r0, lsl #23
  401ba2:	ea4f 53d2 	mov.w	r3, r2, lsr #23
  401ba6:	600b      	str	r3, [r1, #0]

	return 0;
  401ba8:	f04f 0000 	mov.w	r0, #0
  401bac:	4770      	bx	lr
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
		return 1;
  401bae:	f04f 0001 	mov.w	r0, #1

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;

	return 0;
}
  401bb2:	4770      	bx	lr

00401bb4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  401bb4:	e7fe      	b.n	401bb4 <Dummy_Handler>
  401bb6:	bf00      	nop

00401bb8 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401bb8:	b538      	push	{r3, r4, r5, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  401bba:	4b50      	ldr	r3, [pc, #320]	; (401cfc <Reset_Handler+0x144>)
  401bbc:	4a50      	ldr	r2, [pc, #320]	; (401d00 <Reset_Handler+0x148>)
  401bbe:	429a      	cmp	r2, r3
  401bc0:	d929      	bls.n	401c16 <Reset_Handler+0x5e>
		for (; pDest < &_erelocate;) {
  401bc2:	4d50      	ldr	r5, [pc, #320]	; (401d04 <Reset_Handler+0x14c>)
  401bc4:	4b4d      	ldr	r3, [pc, #308]	; (401cfc <Reset_Handler+0x144>)
  401bc6:	42ab      	cmp	r3, r5
  401bc8:	d248      	bcs.n	401c5c <Reset_Handler+0xa4>

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  401bca:	f103 0004 	add.w	r0, r3, #4
  401bce:	4a4e      	ldr	r2, [pc, #312]	; (401d08 <Reset_Handler+0x150>)
  401bd0:	1a11      	subs	r1, r2, r0
  401bd2:	f021 0403 	bic.w	r4, r1, #3
  401bd6:	f04f 0300 	mov.w	r3, #0
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
  401bda:	f240 0200 	movw	r2, #0
  401bde:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401be2:	f643 1100 	movw	r1, #14592	; 0x3900
  401be6:	f2c0 0140 	movt	r1, #64	; 0x40
  401bea:	f104 0004 	add.w	r0, r4, #4
  401bee:	f3c4 0480 	ubfx	r4, r4, #2, #1
  401bf2:	585d      	ldr	r5, [r3, r1]
  401bf4:	509d      	str	r5, [r3, r2]
  401bf6:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  401bfa:	4283      	cmp	r3, r0
  401bfc:	d16d      	bne.n	401cda <Reset_Handler+0x122>
  401bfe:	e02d      	b.n	401c5c <Reset_Handler+0xa4>
			*pDest++ = *pSrc++;
  401c00:	585d      	ldr	r5, [r3, r1]
  401c02:	509d      	str	r5, [r3, r2]
  401c04:	f103 0304 	add.w	r3, r3, #4
  401c08:	585c      	ldr	r4, [r3, r1]
  401c0a:	509c      	str	r4, [r3, r2]
  401c0c:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  401c10:	4283      	cmp	r3, r0
  401c12:	d1f5      	bne.n	401c00 <Reset_Handler+0x48>
  401c14:	e022      	b.n	401c5c <Reset_Handler+0xa4>
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  401c16:	4839      	ldr	r0, [pc, #228]	; (401cfc <Reset_Handler+0x144>)
  401c18:	4939      	ldr	r1, [pc, #228]	; (401d00 <Reset_Handler+0x148>)
  401c1a:	4281      	cmp	r1, r0
  401c1c:	d21e      	bcs.n	401c5c <Reset_Handler+0xa4>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  401c1e:	f640 0550 	movw	r5, #2128	; 0x850
  401c22:	f2c2 0500 	movt	r5, #8192	; 0x2000
  401c26:	f240 0400 	movw	r4, #0
  401c2a:	f2c2 0400 	movt	r4, #8192	; 0x2000
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  401c2e:	4b37      	ldr	r3, [pc, #220]	; (401d0c <Reset_Handler+0x154>)
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  401c30:	1b2a      	subs	r2, r5, r4
  401c32:	d013      	beq.n	401c5c <Reset_Handler+0xa4>
  401c34:	f1a2 0004 	sub.w	r0, r2, #4
  401c38:	f3c0 0180 	ubfx	r1, r0, #2, #1
			*pDest-- = *pSrc--;
  401c3c:	589c      	ldr	r4, [r3, r2]
  401c3e:	f845 4d04 	str.w	r4, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  401c42:	3a04      	subs	r2, #4
  401c44:	d152      	bne.n	401cec <Reset_Handler+0x134>
  401c46:	e009      	b.n	401c5c <Reset_Handler+0xa4>
			*pDest-- = *pSrc--;
  401c48:	5899      	ldr	r1, [r3, r2]
  401c4a:	f845 1d04 	str.w	r1, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  401c4e:	f1a2 0204 	sub.w	r2, r2, #4
			*pDest-- = *pSrc--;
  401c52:	589c      	ldr	r4, [r3, r2]
  401c54:	f845 4d04 	str.w	r4, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  401c58:	3a04      	subs	r2, #4
  401c5a:	d1f5      	bne.n	401c48 <Reset_Handler+0x90>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  401c5c:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401c5e:	4b2c      	ldr	r3, [pc, #176]	; (401d10 <Reset_Handler+0x158>)
  401c60:	4a2c      	ldr	r2, [pc, #176]	; (401d14 <Reset_Handler+0x15c>)
  401c62:	429a      	cmp	r2, r3
  401c64:	d21e      	bcs.n	401ca4 <Reset_Handler+0xec>
  401c66:	f1a2 0504 	sub.w	r5, r2, #4

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  401c6a:	492b      	ldr	r1, [pc, #172]	; (401d18 <Reset_Handler+0x160>)
  401c6c:	1b48      	subs	r0, r1, r5
  401c6e:	f020 0403 	bic.w	r4, r0, #3
  401c72:	f640 0350 	movw	r3, #2128	; 0x850
  401c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401c7a:	18e2      	adds	r2, r4, r3
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
		*pDest++ = 0;
  401c7c:	f04f 0100 	mov.w	r1, #0
  401c80:	1b50      	subs	r0, r2, r5
  401c82:	f1a0 0004 	sub.w	r0, r0, #4
  401c86:	f3c0 0480 	ubfx	r4, r0, #2, #1
  401c8a:	f845 1f04 	str.w	r1, [r5, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401c8e:	4295      	cmp	r5, r2
  401c90:	d11c      	bne.n	401ccc <Reset_Handler+0x114>
  401c92:	e007      	b.n	401ca4 <Reset_Handler+0xec>
  401c94:	f105 0304 	add.w	r3, r5, #4
		*pDest++ = 0;
  401c98:	6069      	str	r1, [r5, #4]
  401c9a:	f105 0508 	add.w	r5, r5, #8
  401c9e:	6059      	str	r1, [r3, #4]
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401ca0:	4295      	cmp	r5, r2
  401ca2:	d1f7      	bne.n	401c94 <Reset_Handler+0xdc>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  401ca4:	f44f 456d 	mov.w	r5, #60672	; 0xed00
  401ca8:	f2ce 0500 	movt	r5, #57344	; 0xe000
  401cac:	f240 0200 	movw	r2, #0
  401cb0:	f2c0 0240 	movt	r2, #64	; 0x40
  401cb4:	60aa      	str	r2, [r5, #8]

	/* Initialize the C library */
	__libc_init_array();
  401cb6:	f242 4161 	movw	r1, #9313	; 0x2461
  401cba:	f2c0 0140 	movt	r1, #64	; 0x40
  401cbe:	4788      	blx	r1

	/* Branch to main function */
	main();
  401cc0:	f242 108d 	movw	r0, #8589	; 0x218d
  401cc4:	f2c0 0040 	movt	r0, #64	; 0x40
  401cc8:	4780      	blx	r0
  401cca:	e7fe      	b.n	401cca <Reset_Handler+0x112>
  401ccc:	2c00      	cmp	r4, #0
  401cce:	d0e1      	beq.n	401c94 <Reset_Handler+0xdc>
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
		*pDest++ = 0;
  401cd0:	f845 1f04 	str.w	r1, [r5, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401cd4:	4295      	cmp	r5, r2
  401cd6:	d1dd      	bne.n	401c94 <Reset_Handler+0xdc>
  401cd8:	e7e4      	b.n	401ca4 <Reset_Handler+0xec>
  401cda:	2c00      	cmp	r4, #0
  401cdc:	d090      	beq.n	401c00 <Reset_Handler+0x48>
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
  401cde:	585c      	ldr	r4, [r3, r1]
  401ce0:	509c      	str	r4, [r3, r2]
  401ce2:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  401ce6:	4283      	cmp	r3, r0
  401ce8:	d18a      	bne.n	401c00 <Reset_Handler+0x48>
  401cea:	e7b7      	b.n	401c5c <Reset_Handler+0xa4>
  401cec:	2900      	cmp	r1, #0
  401cee:	d0ab      	beq.n	401c48 <Reset_Handler+0x90>
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
			*pDest-- = *pSrc--;
  401cf0:	5898      	ldr	r0, [r3, r2]
  401cf2:	f845 0d04 	str.w	r0, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  401cf6:	3a04      	subs	r2, #4
  401cf8:	d1a6      	bne.n	401c48 <Reset_Handler+0x90>
  401cfa:	e7af      	b.n	401c5c <Reset_Handler+0xa4>
  401cfc:	20000000 	.word	0x20000000
  401d00:	00403900 	.word	0x00403900
  401d04:	20000850 	.word	0x20000850
  401d08:	20000853 	.word	0x20000853
  401d0c:	004038fc 	.word	0x004038fc
  401d10:	20000d00 	.word	0x20000d00
  401d14:	20000850 	.word	0x20000850
  401d18:	20000cfb 	.word	0x20000cfb

00401d1c <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  401d1c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401d20:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401d24:	6b18      	ldr	r0, [r3, #48]	; 0x30
  401d26:	f000 0303 	and.w	r3, r0, #3
  401d2a:	2b03      	cmp	r3, #3
  401d2c:	f200 80a9 	bhi.w	401e82 <SystemCoreClockUpdate+0x166>
  401d30:	e8df f003 	tbb	[pc, r3]
  401d34:	4f4f1402 	.word	0x4f4f1402
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  401d38:	f241 4010 	movw	r0, #5136	; 0x1410
  401d3c:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401d40:	6941      	ldr	r1, [r0, #20]
  401d42:	f011 0f80 	tst.w	r1, #128	; 0x80
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  401d46:	f240 0308 	movw	r3, #8
  401d4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401d4e:	bf14      	ite	ne
  401d50:	f44f 4200 	movne.w	r2, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401d54:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  401d58:	601a      	str	r2, [r3, #0]
  401d5a:	e092      	b.n	401e82 <SystemCoreClockUpdate+0x166>
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  401d5c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401d60:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401d64:	6a18      	ldr	r0, [r3, #32]
  401d66:	f010 7f80 	tst.w	r0, #16777216	; 0x1000000
  401d6a:	d009      	beq.n	401d80 <SystemCoreClockUpdate+0x64>
			SystemCoreClock = CHIP_FREQ_XTAL;
  401d6c:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401d70:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401d74:	f240 0208 	movw	r2, #8
  401d78:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401d7c:	6013      	str	r3, [r2, #0]
  401d7e:	e080      	b.n	401e82 <SystemCoreClockUpdate+0x166>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401d80:	f44f 6110 	mov.w	r1, #2304	; 0x900
  401d84:	f2c0 013d 	movt	r1, #61	; 0x3d
  401d88:	f240 0208 	movw	r2, #8
  401d8c:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401d90:	6011      	str	r1, [r2, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  401d92:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401d96:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401d9a:	6a18      	ldr	r0, [r3, #32]
  401d9c:	f000 0170 	and.w	r1, r0, #112	; 0x70
  401da0:	2910      	cmp	r1, #16
  401da2:	d002      	beq.n	401daa <SystemCoreClockUpdate+0x8e>
  401da4:	2920      	cmp	r1, #32
  401da6:	d16c      	bne.n	401e82 <SystemCoreClockUpdate+0x166>
  401da8:	e009      	b.n	401dbe <SystemCoreClockUpdate+0xa2>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  401daa:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  401dae:	f2c0 007a 	movt	r0, #122	; 0x7a
  401db2:	f240 0108 	movw	r1, #8
  401db6:	f2c2 0100 	movt	r1, #8192	; 0x2000
  401dba:	6008      	str	r0, [r1, #0]
			break;
  401dbc:	e061      	b.n	401e82 <SystemCoreClockUpdate+0x166>
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  401dbe:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401dc2:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401dc6:	f240 0208 	movw	r2, #8
  401dca:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401dce:	6013      	str	r3, [r2, #0]
			break;
  401dd0:	e057      	b.n	401e82 <SystemCoreClockUpdate+0x166>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  401dd2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401dd6:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401dda:	6a13      	ldr	r3, [r2, #32]
  401ddc:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  401de0:	d009      	beq.n	401df6 <SystemCoreClockUpdate+0xda>
				SystemCoreClock = CHIP_FREQ_XTAL;
  401de2:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401de6:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401dea:	f240 0208 	movw	r2, #8
  401dee:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401df2:	6013      	str	r3, [r2, #0]
  401df4:	e027      	b.n	401e46 <SystemCoreClockUpdate+0x12a>
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401df6:	f44f 6310 	mov.w	r3, #2304	; 0x900
  401dfa:	f2c0 033d 	movt	r3, #61	; 0x3d
  401dfe:	f240 0208 	movw	r2, #8
  401e02:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401e06:	6013      	str	r3, [r2, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  401e08:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401e0c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401e10:	6a1a      	ldr	r2, [r3, #32]
  401e12:	f002 0370 	and.w	r3, r2, #112	; 0x70
  401e16:	2b10      	cmp	r3, #16
  401e18:	d002      	beq.n	401e20 <SystemCoreClockUpdate+0x104>
  401e1a:	2b20      	cmp	r3, #32
  401e1c:	d113      	bne.n	401e46 <SystemCoreClockUpdate+0x12a>
  401e1e:	e009      	b.n	401e34 <SystemCoreClockUpdate+0x118>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  401e20:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  401e24:	f2c0 037a 	movt	r3, #122	; 0x7a
  401e28:	f240 0208 	movw	r2, #8
  401e2c:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401e30:	6013      	str	r3, [r2, #0]
					break;
  401e32:	e008      	b.n	401e46 <SystemCoreClockUpdate+0x12a>
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  401e34:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401e38:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401e3c:	f240 0208 	movw	r2, #8
  401e40:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401e44:	6013      	str	r3, [r2, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  401e46:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401e4a:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401e4e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  401e50:	f002 0303 	and.w	r3, r2, #3
  401e54:	2b02      	cmp	r3, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  401e56:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401e5a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401e5e:	bf07      	ittee	eq
  401e60:	6a90      	ldreq	r0, [r2, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  401e62:	6a91      	ldreq	r1, [r2, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  401e64:	6ad0      	ldrne	r0, [r2, #44]	; 0x2c
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  401e66:	6ad1      	ldrne	r1, [r2, #44]	; 0x2c
  401e68:	f240 0308 	movw	r3, #8
  401e6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  401e70:	f3c0 400a 	ubfx	r0, r0, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  401e74:	681a      	ldr	r2, [r3, #0]
  401e76:	fb00 2002 	mla	r0, r0, r2, r2
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
						>> CKGR_PLLBR_DIVB_Pos));
  401e7a:	b2c9      	uxtb	r1, r1
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  401e7c:	fbb0 f2f1 	udiv	r2, r0, r1
  401e80:	601a      	str	r2, [r3, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  401e82:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401e86:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401e8a:	6b10      	ldr	r0, [r2, #48]	; 0x30
  401e8c:	f000 0170 	and.w	r1, r0, #112	; 0x70
  401e90:	2970      	cmp	r1, #112	; 0x70
  401e92:	d10e      	bne.n	401eb2 <SystemCoreClockUpdate+0x196>
		SystemCoreClock /= 3U;
  401e94:	f240 0308 	movw	r3, #8
  401e98:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401e9c:	6818      	ldr	r0, [r3, #0]
  401e9e:	f64a 22ab 	movw	r2, #43691	; 0xaaab
  401ea2:	f6ca 22aa 	movt	r2, #43690	; 0xaaaa
  401ea6:	fba2 0100 	umull	r0, r1, r2, r0
  401eaa:	ea4f 0051 	mov.w	r0, r1, lsr #1
  401eae:	6018      	str	r0, [r3, #0]
  401eb0:	4770      	bx	lr
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  401eb2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401eb6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401eba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  401ebc:	f240 0008 	movw	r0, #8
  401ec0:	f2c2 0000 	movt	r0, #8192	; 0x2000
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  401ec4:	f3c2 1102 	ubfx	r1, r2, #4, #3
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  401ec8:	6803      	ldr	r3, [r0, #0]
  401eca:	fa23 f301 	lsr.w	r3, r3, r1
  401ece:	6003      	str	r3, [r0, #0]
  401ed0:	4770      	bx	lr
  401ed2:	bf00      	nop

00401ed4 <system_init_flash>:
				}
			}
		}
	}
#else
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  401ed4:	f642 43ff 	movw	r3, #11519	; 0x2cff
  401ed8:	f2c0 1331 	movt	r3, #305	; 0x131
  401edc:	4298      	cmp	r0, r3
  401ede:	d80c      	bhi.n	401efa <system_init_flash+0x26>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  401ee0:	f44f 6120 	mov.w	r1, #2560	; 0xa00
  401ee4:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401ee8:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
  401eec:	6008      	str	r0, [r1, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  401eee:	f44f 6340 	mov.w	r3, #3072	; 0xc00
  401ef2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401ef6:	6018      	str	r0, [r3, #0]
  401ef8:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  401efa:	f645 11ff 	movw	r1, #23039	; 0x59ff
  401efe:	f2c0 2162 	movt	r1, #610	; 0x262
  401f02:	4288      	cmp	r0, r1
  401f04:	d80e      	bhi.n	401f24 <system_init_flash+0x50>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  401f06:	f44f 6020 	mov.w	r0, #2560	; 0xa00
  401f0a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f0e:	f44f 7380 	mov.w	r3, #256	; 0x100
  401f12:	f2c0 4300 	movt	r3, #1024	; 0x400
  401f16:	6003      	str	r3, [r0, #0]
			EFC1->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  401f18:	f44f 6240 	mov.w	r2, #3072	; 0xc00
  401f1c:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401f20:	6013      	str	r3, [r2, #0]
  401f22:	4770      	bx	lr
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  401f24:	f248 62ff 	movw	r2, #34559	; 0x86ff
  401f28:	f2c0 3293 	movt	r2, #915	; 0x393
  401f2c:	4290      	cmp	r0, r2
  401f2e:	d80e      	bhi.n	401f4e <system_init_flash+0x7a>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  401f30:	f44f 6220 	mov.w	r2, #2560	; 0xa00
  401f34:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401f38:	f44f 7300 	mov.w	r3, #512	; 0x200
  401f3c:	f2c0 4300 	movt	r3, #1024	; 0x400
  401f40:	6013      	str	r3, [r2, #0]
				EFC1->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  401f42:	f44f 6140 	mov.w	r1, #3072	; 0xc00
  401f46:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401f4a:	600b      	str	r3, [r1, #0]
  401f4c:	4770      	bx	lr
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  401f4e:	f24b 33ff 	movw	r3, #46079	; 0xb3ff
  401f52:	f2c0 43c4 	movt	r3, #1220	; 0x4c4
  401f56:	4298      	cmp	r0, r3
  401f58:	d80e      	bhi.n	401f78 <system_init_flash+0xa4>
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  401f5a:	f44f 6220 	mov.w	r2, #2560	; 0xa00
  401f5e:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401f62:	f44f 7140 	mov.w	r1, #768	; 0x300
  401f66:	f2c0 4100 	movt	r1, #1024	; 0x400
  401f6a:	6011      	str	r1, [r2, #0]
					EFC1->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  401f6c:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  401f70:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401f74:	6001      	str	r1, [r0, #0]
  401f76:	4770      	bx	lr
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  401f78:	f24e 01ff 	movw	r1, #57599	; 0xe0ff
  401f7c:	f2c0 51f5 	movt	r1, #1525	; 0x5f5
  401f80:	4288      	cmp	r0, r1
  401f82:	d80c      	bhi.n	401f9e <system_init_flash+0xca>
						EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401f84:	f44f 6120 	mov.w	r1, #2560	; 0xa00
  401f88:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401f8c:	f04f 2004 	mov.w	r0, #67109888	; 0x4000400
  401f90:	6008      	str	r0, [r1, #0]
						EFC1->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401f92:	f44f 6340 	mov.w	r3, #3072	; 0xc00
  401f96:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401f9a:	6018      	str	r0, [r3, #0]
  401f9c:	4770      	bx	lr
					} else {
						EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  401f9e:	f44f 6020 	mov.w	r0, #2560	; 0xa00
  401fa2:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401fa6:	f44f 63a0 	mov.w	r3, #1280	; 0x500
  401faa:	f2c0 4300 	movt	r3, #1024	; 0x400
  401fae:	6003      	str	r3, [r0, #0]
						EFC1->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  401fb0:	f44f 6240 	mov.w	r2, #3072	; 0xc00
  401fb4:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401fb8:	6013      	str	r3, [r2, #0]
  401fba:	4770      	bx	lr

00401fbc <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  401fbc:	f640 43a4 	movw	r3, #3236	; 0xca4
  401fc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401fc4:	6819      	ldr	r1, [r3, #0]
  401fc6:	b941      	cbnz	r1, 401fda <_sbrk+0x1e>
		heap = (unsigned char *)&_end;
  401fc8:	f640 43a4 	movw	r3, #3236	; 0xca4
  401fcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401fd0:	f643 5200 	movw	r2, #15616	; 0x3d00
  401fd4:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401fd8:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  401fda:	f640 41a4 	movw	r1, #3236	; 0xca4
  401fde:	f2c2 0100 	movt	r1, #8192	; 0x2000
  401fe2:	680b      	ldr	r3, [r1, #0]

	if (((int)prev_heap + incr) > ramend) {
  401fe4:	1818      	adds	r0, r3, r0
  401fe6:	f647 72fc 	movw	r2, #32764	; 0x7ffc
  401fea:	f2c2 0202 	movt	r2, #8194	; 0x2002
  401fee:	4282      	cmp	r2, r0
  401ff0:	db06      	blt.n	402000 <_sbrk+0x44>
		return (caddr_t) -1;	
	}

	heap += incr;
  401ff2:	4601      	mov	r1, r0
  401ff4:	f640 40a4 	movw	r0, #3236	; 0xca4
  401ff8:	f2c2 0000 	movt	r0, #8192	; 0x2000
  401ffc:	6001      	str	r1, [r0, #0]

	return (caddr_t) prev_heap;
  401ffe:	e001      	b.n	402004 <_sbrk+0x48>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  402000:	f04f 33ff 	mov.w	r3, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  402004:	4618      	mov	r0, r3
  402006:	4770      	bx	lr

00402008 <_close>:
}

extern int _close(int file)
{
	return -1;
}
  402008:	f04f 30ff 	mov.w	r0, #4294967295
  40200c:	4770      	bx	lr
  40200e:	bf00      	nop

00402010 <_lseek>:
}

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
  402010:	f04f 0000 	mov.w	r0, #0
  402014:	4770      	bx	lr
  402016:	bf00      	nop

00402018 <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  402018:	b5f0      	push	{r4, r5, r6, r7, lr}
  40201a:	b083      	sub	sp, #12
  40201c:	4604      	mov	r4, r0
  40201e:	460d      	mov	r5, r1
	uint32_t val = 0;
  402020:	f04f 0300 	mov.w	r3, #0
  402024:	9301      	str	r3, [sp, #4]
	if (UART == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  402026:	f44f 60c0 	mov.w	r0, #1536	; 0x600
  40202a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40202e:	4284      	cmp	r4, r0
  402030:	d10d      	bne.n	40204e <usart_serial_getchar+0x36>
		while (uart_read((Uart*)p_usart, data));
  402032:	f44f 66c0 	mov.w	r6, #1536	; 0x600
  402036:	f2c4 060e 	movt	r6, #16398	; 0x400e
  40203a:	f641 375d 	movw	r7, #7005	; 0x1b5d
  40203e:	f2c0 0740 	movt	r7, #64	; 0x40
  402042:	4630      	mov	r0, r6
  402044:	4629      	mov	r1, r5
  402046:	47b8      	blx	r7
  402048:	2800      	cmp	r0, #0
  40204a:	d1fa      	bne.n	402042 <usart_serial_getchar+0x2a>
  40204c:	e029      	b.n	4020a2 <usart_serial_getchar+0x8a>
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  40204e:	f44f 6100 	mov.w	r1, #2048	; 0x800
  402052:	f2c4 010e 	movt	r1, #16398	; 0x400e
  402056:	428c      	cmp	r4, r1
  402058:	d10d      	bne.n	402076 <usart_serial_getchar+0x5e>
		while (uart_read((Uart*)p_usart, data));
  40205a:	f44f 6400 	mov.w	r4, #2048	; 0x800
  40205e:	f2c4 040e 	movt	r4, #16398	; 0x400e
  402062:	f641 365d 	movw	r6, #7005	; 0x1b5d
  402066:	f2c0 0640 	movt	r6, #64	; 0x40
  40206a:	4620      	mov	r0, r4
  40206c:	4629      	mov	r1, r5
  40206e:	47b0      	blx	r6
  402070:	2800      	cmp	r0, #0
  402072:	d1fa      	bne.n	40206a <usart_serial_getchar+0x52>
  402074:	e02a      	b.n	4020cc <usart_serial_getchar+0xb4>
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  402076:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  40207a:	f2c4 0202 	movt	r2, #16386	; 0x4002
  40207e:	4294      	cmp	r4, r2
  402080:	d10f      	bne.n	4020a2 <usart_serial_getchar+0x8a>
		while (usart_read(p_usart, &val));
  402082:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  402086:	f2c4 0402 	movt	r4, #16386	; 0x4002
  40208a:	f641 3695 	movw	r6, #7061	; 0x1b95
  40208e:	f2c0 0640 	movt	r6, #64	; 0x40
  402092:	4620      	mov	r0, r4
  402094:	a901      	add	r1, sp, #4
  402096:	47b0      	blx	r6
  402098:	2800      	cmp	r0, #0
  40209a:	d1fa      	bne.n	402092 <usart_serial_getchar+0x7a>
		*data = (uint8_t)(val & 0xFF);
  40209c:	9b01      	ldr	r3, [sp, #4]
  40209e:	702b      	strb	r3, [r5, #0]
  4020a0:	e014      	b.n	4020cc <usart_serial_getchar+0xb4>
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  4020a2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4020a6:	f2c4 0002 	movt	r0, #16386	; 0x4002
  4020aa:	4284      	cmp	r4, r0
  4020ac:	d10e      	bne.n	4020cc <usart_serial_getchar+0xb4>
		while (usart_read(p_usart, &val));
  4020ae:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  4020b2:	f2c4 0402 	movt	r4, #16386	; 0x4002
  4020b6:	f641 3695 	movw	r6, #7061	; 0x1b95
  4020ba:	f2c0 0640 	movt	r6, #64	; 0x40
  4020be:	4620      	mov	r0, r4
  4020c0:	a901      	add	r1, sp, #4
  4020c2:	47b0      	blx	r6
  4020c4:	2800      	cmp	r0, #0
  4020c6:	d1fa      	bne.n	4020be <usart_serial_getchar+0xa6>
		*data = (uint8_t)(val & 0xFF);
  4020c8:	9901      	ldr	r1, [sp, #4]
  4020ca:	7029      	strb	r1, [r5, #0]
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  4020cc:	b003      	add	sp, #12
  4020ce:	bdf0      	pop	{r4, r5, r6, r7, pc}

004020d0 <usart_serial_putchar>:
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  4020d0:	b570      	push	{r4, r5, r6, lr}
  4020d2:	460c      	mov	r4, r1
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  4020d4:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  4020d8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4020dc:	4298      	cmp	r0, r3
  4020de:	d10f      	bne.n	402100 <usart_serial_putchar+0x30>
		while (uart_write((Uart*)p_usart, c)!=0);
  4020e0:	f44f 65c0 	mov.w	r5, #1536	; 0x600
  4020e4:	f2c4 050e 	movt	r5, #16398	; 0x400e
  4020e8:	f641 3645 	movw	r6, #6981	; 0x1b45
  4020ec:	f2c0 0640 	movt	r6, #64	; 0x40
  4020f0:	4628      	mov	r0, r5
  4020f2:	4621      	mov	r1, r4
  4020f4:	47b0      	blx	r6
  4020f6:	2800      	cmp	r0, #0
  4020f8:	d1fa      	bne.n	4020f0 <usart_serial_putchar+0x20>
		return 1;
  4020fa:	f04f 0001 	mov.w	r0, #1
  4020fe:	bd70      	pop	{r4, r5, r6, pc}
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  402100:	f44f 6100 	mov.w	r1, #2048	; 0x800
  402104:	f2c4 010e 	movt	r1, #16398	; 0x400e
  402108:	4288      	cmp	r0, r1
  40210a:	d10f      	bne.n	40212c <usart_serial_putchar+0x5c>
		while (uart_write((Uart*)p_usart, c)!=0);
  40210c:	f44f 6500 	mov.w	r5, #2048	; 0x800
  402110:	f2c4 050e 	movt	r5, #16398	; 0x400e
  402114:	f641 3645 	movw	r6, #6981	; 0x1b45
  402118:	f2c0 0640 	movt	r6, #64	; 0x40
  40211c:	4628      	mov	r0, r5
  40211e:	4621      	mov	r1, r4
  402120:	47b0      	blx	r6
  402122:	2800      	cmp	r0, #0
  402124:	d1fa      	bne.n	40211c <usart_serial_putchar+0x4c>
		return 1;
  402126:	f04f 0001 	mov.w	r0, #1
  40212a:	bd70      	pop	{r4, r5, r6, pc}
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  40212c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  402130:	f2c4 0202 	movt	r2, #16386	; 0x4002
  402134:	4290      	cmp	r0, r2
  402136:	d10f      	bne.n	402158 <usart_serial_putchar+0x88>
		while (usart_write(p_usart, c)!=0);
  402138:	f44f 4580 	mov.w	r5, #16384	; 0x4000
  40213c:	f2c4 0502 	movt	r5, #16386	; 0x4002
  402140:	f641 3675 	movw	r6, #7029	; 0x1b75
  402144:	f2c0 0640 	movt	r6, #64	; 0x40
  402148:	4628      	mov	r0, r5
  40214a:	4621      	mov	r1, r4
  40214c:	47b0      	blx	r6
  40214e:	2800      	cmp	r0, #0
  402150:	d1fa      	bne.n	402148 <usart_serial_putchar+0x78>
		return 1;
  402152:	f04f 0001 	mov.w	r0, #1
  402156:	bd70      	pop	{r4, r5, r6, pc}
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  402158:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40215c:	f2c4 0302 	movt	r3, #16386	; 0x4002
  402160:	4298      	cmp	r0, r3
  402162:	d10f      	bne.n	402184 <usart_serial_putchar+0xb4>
		while (usart_write(p_usart, c)!=0);
  402164:	f44f 4500 	mov.w	r5, #32768	; 0x8000
  402168:	f2c4 0502 	movt	r5, #16386	; 0x4002
  40216c:	f641 3675 	movw	r6, #7029	; 0x1b75
  402170:	f2c0 0640 	movt	r6, #64	; 0x40
  402174:	4628      	mov	r0, r5
  402176:	4621      	mov	r1, r4
  402178:	47b0      	blx	r6
  40217a:	2800      	cmp	r0, #0
  40217c:	d1fa      	bne.n	402174 <usart_serial_putchar+0xa4>
		return 1;
  40217e:	f04f 0001 	mov.w	r0, #1
  402182:	bd70      	pop	{r4, r5, r6, pc}
		return 1;
	}
# endif
#endif /* ifdef USART */

	return 0;
  402184:	f04f 0000 	mov.w	r0, #0
}
  402188:	bd70      	pop	{r4, r5, r6, pc}
  40218a:	bf00      	nop

0040218c <main>:
 * \brief Application entry point for smc_lcd example.
 *
 * \return Unused (ANSI-C compatibility).
 */
int main(void)
{
  40218c:	b580      	push	{r7, lr}
  40218e:	b084      	sub	sp, #16
	sysclk_init();
  402190:	f240 137d 	movw	r3, #381	; 0x17d
  402194:	f2c0 0340 	movt	r3, #64	; 0x40
  402198:	4798      	blx	r3
	board_init();
  40219a:	f240 301d 	movw	r0, #797	; 0x31d
  40219e:	f2c0 0040 	movt	r0, #64	; 0x40
  4021a2:	4780      	blx	r0
  4021a4:	f04f 0008 	mov.w	r0, #8
  4021a8:	f641 247d 	movw	r4, #6781	; 0x1a7d
  4021ac:	f2c0 0440 	movt	r4, #64	; 0x40
  4021b0:	47a0      	blx	r4
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
  4021b2:	f44f 65c0 	mov.w	r5, #1536	; 0x600
  4021b6:	f2c4 050e 	movt	r5, #16398	; 0x400e
  4021ba:	f640 41e4 	movw	r1, #3300	; 0xce4
  4021be:	f2c2 0100 	movt	r1, #8192	; 0x2000
  4021c2:	600d      	str	r5, [r1, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  4021c4:	f640 46e0 	movw	r6, #3296	; 0xce0
  4021c8:	f2c2 0600 	movt	r6, #8192	; 0x2000
  4021cc:	f242 02d1 	movw	r2, #8401	; 0x20d1
  4021d0:	f2c0 0240 	movt	r2, #64	; 0x40
  4021d4:	6032      	str	r2, [r6, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
  4021d6:	f640 47dc 	movw	r7, #3292	; 0xcdc
  4021da:	f2c2 0700 	movt	r7, #8192	; 0x2000
  4021de:	f242 0319 	movw	r3, #8217	; 0x2019
  4021e2:	f2c0 0340 	movt	r3, #64	; 0x40
  4021e6:	603b      	str	r3, [r7, #0]
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
#if (!SAM4L)
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  4021e8:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  4021ec:	f2c0 7027 	movt	r0, #1831	; 0x727
  4021f0:	9000      	str	r0, [sp, #0]
	uart_settings.ul_baudrate = opt->baudrate;
  4021f2:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
  4021f6:	9101      	str	r1, [sp, #4]
	uart_settings.ul_mode = opt->paritytype;
  4021f8:	f44f 6600 	mov.w	r6, #2048	; 0x800
  4021fc:	9602      	str	r6, [sp, #8]
  4021fe:	f04f 0008 	mov.w	r0, #8
  402202:	47a0      	blx	r4
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		sysclk_enable_peripheral_clock(ID_UART0);
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
  402204:	4628      	mov	r0, r5
  402206:	4669      	mov	r1, sp
  402208:	f641 3501 	movw	r5, #6913	; 0x1b01
  40220c:	f2c0 0540 	movt	r5, #64	; 0x40
  402210:	47a8      	blx	r5
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  402212:	f240 0710 	movw	r7, #16
  402216:	f2c2 0700 	movt	r7, #8192	; 0x2000
  40221a:	683a      	ldr	r2, [r7, #0]
  40221c:	6890      	ldr	r0, [r2, #8]
  40221e:	f04f 0100 	mov.w	r1, #0
  402222:	f242 46bd 	movw	r6, #9405	; 0x24bd
  402226:	f2c0 0640 	movt	r6, #64	; 0x40
  40222a:	47b0      	blx	r6
	setbuf(stdin, NULL);
  40222c:	683b      	ldr	r3, [r7, #0]
  40222e:	6858      	ldr	r0, [r3, #4]
  402230:	f04f 0100 	mov.w	r1, #0
  402234:	47b0      	blx	r6

	/** Initialize debug console */
	configure_console();

	/** Enable peripheral clock */
	pmc_enable_periph_clk(ID_SMC);
  402236:	f04f 000a 	mov.w	r0, #10
  40223a:	47a0      	blx	r4

	/** Configure SMC interface for Lcd */
	smc_set_setup_timing(SMC, ILI93XX_LCD_CS, SMC_SETUP_NWE_SETUP(2)
  40223c:	f04f 0400 	mov.w	r4, #0
  402240:	f2c4 040e 	movt	r4, #16398	; 0x400e
  402244:	4620      	mov	r0, r4
  402246:	f04f 0101 	mov.w	r1, #1
  40224a:	f04f 3202 	mov.w	r2, #33686018	; 0x2020202
  40224e:	f241 4581 	movw	r5, #5249	; 0x1481
  402252:	f2c0 0540 	movt	r5, #64	; 0x40
  402256:	47a8      	blx	r5
			| SMC_SETUP_NCS_WR_SETUP(2)
			| SMC_SETUP_NRD_SETUP(2)
			| SMC_SETUP_NCS_RD_SETUP(2));
	smc_set_pulse_timing(SMC, ILI93XX_LCD_CS, SMC_PULSE_NWE_PULSE(4)
  402258:	4620      	mov	r0, r4
  40225a:	f04f 0101 	mov.w	r1, #1
  40225e:	f240 4204 	movw	r2, #1028	; 0x404
  402262:	f6c0 220a 	movt	r2, #2570	; 0xa0a
  402266:	f241 4789 	movw	r7, #5257	; 0x1489
  40226a:	f2c0 0740 	movt	r7, #64	; 0x40
  40226e:	47b8      	blx	r7
			| SMC_PULSE_NCS_WR_PULSE(4)
			| SMC_PULSE_NRD_PULSE(10)
			| SMC_PULSE_NCS_RD_PULSE(10));
	smc_set_cycle_timing(SMC, ILI93XX_LCD_CS, SMC_CYCLE_NWE_CYCLE(10)
  402270:	4620      	mov	r0, r4
  402272:	f04f 0101 	mov.w	r1, #1
  402276:	f04f 020a 	mov.w	r2, #10
  40227a:	f2c0 0216 	movt	r2, #22
  40227e:	f241 4691 	movw	r6, #5265	; 0x1491
  402282:	f2c0 0640 	movt	r6, #64	; 0x40
  402286:	47b0      	blx	r6
#if ((!defined(SAM4S)) && (!defined(SAM4E)))
	smc_set_mode(SMC, ILI93XX_LCD_CS, SMC_MODE_READ_MODE
			| SMC_MODE_WRITE_MODE
			| SMC_MODE_DBW_8_BIT);
#else
	smc_set_mode(SMC, ILI93XX_LCD_CS, SMC_MODE_READ_MODE
  402288:	4620      	mov	r0, r4
  40228a:	f04f 0101 	mov.w	r1, #1
  40228e:	f04f 0203 	mov.w	r2, #3
  402292:	f241 4399 	movw	r3, #5273	; 0x1499
  402296:	f2c0 0340 	movt	r3, #64	; 0x40
  40229a:	4798      	blx	r3
			| SMC_MODE_WRITE_MODE);
#endif
	/** Initialize display parameter */
	g_ili93xx_display_opt.ul_width = ILI93XX_LCD_WIDTH;
  40229c:	f640 45ec 	movw	r5, #3308	; 0xcec
  4022a0:	f2c2 0500 	movt	r5, #8192	; 0x2000
  4022a4:	f04f 07f0 	mov.w	r7, #240	; 0xf0
  4022a8:	602f      	str	r7, [r5, #0]
	g_ili93xx_display_opt.ul_height = ILI93XX_LCD_HEIGHT;
  4022aa:	f44f 76a0 	mov.w	r6, #320	; 0x140
  4022ae:	606e      	str	r6, [r5, #4]
	g_ili93xx_display_opt.foreground_color = COLOR_BLACK;
  4022b0:	f04f 0400 	mov.w	r4, #0
  4022b4:	60ac      	str	r4, [r5, #8]
	g_ili93xx_display_opt.background_color = COLOR_WHITE;
  4022b6:	f06f 487f 	mvn.w	r8, #4278190080	; 0xff000000
  4022ba:	f8c5 800c 	str.w	r8, [r5, #12]

	/** Switch off backlight */
	aat31xx_disable_backlight();
  4022be:	f240 4079 	movw	r0, #1145	; 0x479
  4022c2:	f2c0 0040 	movt	r0, #64	; 0x40
  4022c6:	4780      	blx	r0

	/** Initialize LCD */
	ili93xx_init(&g_ili93xx_display_opt);
  4022c8:	4628      	mov	r0, r5
  4022ca:	f640 11bd 	movw	r1, #2493	; 0x9bd
  4022ce:	f2c0 0140 	movt	r1, #64	; 0x40
  4022d2:	4788      	blx	r1

	/** Set backlight level */
	aat31xx_set_backlight(AAT31XX_AVG_BACKLIGHT_LEVEL);
  4022d4:	f04f 0008 	mov.w	r0, #8
  4022d8:	f240 420d 	movw	r2, #1037	; 0x40d
  4022dc:	f2c0 0240 	movt	r2, #64	; 0x40
  4022e0:	4790      	blx	r2

	ili93xx_set_foreground_color(COLOR_WHITE);
  4022e2:	4640      	mov	r0, r8
  4022e4:	f640 0599 	movw	r5, #2201	; 0x899
  4022e8:	f2c0 0540 	movt	r5, #64	; 0x40
  4022ec:	47a8      	blx	r5
	ili93xx_draw_filled_rectangle(0, 0, ILI93XX_LCD_WIDTH,
  4022ee:	4620      	mov	r0, r4
  4022f0:	4621      	mov	r1, r4
  4022f2:	463a      	mov	r2, r7
  4022f4:	4633      	mov	r3, r6
  4022f6:	f640 7c5d 	movw	ip, #3933	; 0xf5d
  4022fa:	f2c0 0c40 	movt	ip, #64	; 0x40
  4022fe:	47e0      	blx	ip
			ILI93XX_LCD_HEIGHT);
	/** Turn on LCD */
	ili93xx_display_on();
  402300:	f640 0359 	movw	r3, #2137	; 0x859
  402304:	f2c0 0340 	movt	r3, #64	; 0x40
  402308:	4798      	blx	r3
	ili93xx_set_cursor_position(0, 0);
  40230a:	4620      	mov	r0, r4
  40230c:	4621      	mov	r1, r4
  40230e:	f640 128d 	movw	r2, #2445	; 0x98d
  402312:	f2c0 0240 	movt	r2, #64	; 0x40
  402316:	4790      	blx	r2

	/** Draw text, image and basic shapes on the LCD */
	ili93xx_set_foreground_color(COLOR_BLACK);
  402318:	4620      	mov	r0, r4
  40231a:	47a8      	blx	r5
	ili93xx_draw_string(10, 20, (uint8_t *)"ili93xx_lcd example");
  40231c:	f04f 000a 	mov.w	r0, #10
  402320:	f04f 0114 	mov.w	r1, #20
  402324:	f643 02c0 	movw	r2, #14528	; 0x38c0
  402328:	f2c0 0240 	movt	r2, #64	; 0x40
  40232c:	f241 23d9 	movw	r3, #4825	; 0x12d9
  402330:	f2c0 0340 	movt	r3, #64	; 0x40
  402334:	4798      	blx	r3

	ili93xx_set_foreground_color(COLOR_RED);
  402336:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
  40233a:	47a8      	blx	r5
	ili93xx_draw_circle(60, 160, 40);
  40233c:	f04f 003c 	mov.w	r0, #60	; 0x3c
  402340:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  402344:	f04f 0228 	mov.w	r2, #40	; 0x28
  402348:	f241 2825 	movw	r8, #4645	; 0x1225
  40234c:	f2c0 0840 	movt	r8, #64	; 0x40
  402350:	47c0      	blx	r8
	ili93xx_set_foreground_color(COLOR_GREEN);
  402352:	f44f 407f 	mov.w	r0, #65280	; 0xff00
  402356:	47a8      	blx	r5
	ili93xx_draw_circle(120, 160, 40);
  402358:	f04f 0078 	mov.w	r0, #120	; 0x78
  40235c:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  402360:	f04f 0228 	mov.w	r2, #40	; 0x28
  402364:	47c0      	blx	r8
	ili93xx_set_foreground_color(COLOR_BLUE);
  402366:	f04f 00ff 	mov.w	r0, #255	; 0xff
  40236a:	47a8      	blx	r5
	ili93xx_draw_circle(180, 160, 40);
  40236c:	f04f 00b4 	mov.w	r0, #180	; 0xb4
  402370:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  402374:	f04f 0228 	mov.w	r2, #40	; 0x28
  402378:	47c0      	blx	r8

	ili93xx_set_foreground_color(COLOR_VIOLET);
  40237a:	f248 20ee 	movw	r0, #33518	; 0x82ee
  40237e:	f2c0 00ee 	movt	r0, #238	; 0xee
  402382:	47a8      	blx	r5
	ili93xx_draw_line(0, 0, 240, 320);
  402384:	4620      	mov	r0, r4
  402386:	4621      	mov	r1, r4
  402388:	463a      	mov	r2, r7
  40238a:	4633      	mov	r3, r6
  40238c:	f241 0785 	movw	r7, #4229	; 0x1085
  402390:	f2c0 0740 	movt	r7, #64	; 0x40
  402394:	47b8      	blx	r7
  402396:	e7fe      	b.n	402396 <main+0x20a>

00402398 <__register_exitproc>:
  402398:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40239c:	4698      	mov	r8, r3
  40239e:	4b23      	ldr	r3, [pc, #140]	; (40242c <__register_exitproc+0x94>)
  4023a0:	681c      	ldr	r4, [r3, #0]
  4023a2:	4606      	mov	r6, r0
  4023a4:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
  4023a8:	460f      	mov	r7, r1
  4023aa:	4691      	mov	r9, r2
  4023ac:	b918      	cbnz	r0, 4023b6 <__register_exitproc+0x1e>
  4023ae:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  4023b2:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  4023b6:	6841      	ldr	r1, [r0, #4]
  4023b8:	291f      	cmp	r1, #31
  4023ba:	dd16      	ble.n	4023ea <__register_exitproc+0x52>
  4023bc:	481c      	ldr	r0, [pc, #112]	; (402430 <__register_exitproc+0x98>)
  4023be:	b918      	cbnz	r0, 4023c8 <__register_exitproc+0x30>
  4023c0:	f04f 30ff 	mov.w	r0, #4294967295
  4023c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4023c8:	f44f 70c8 	mov.w	r0, #400	; 0x190
  4023cc:	f000 fbbc 	bl	402b48 <malloc>
  4023d0:	2800      	cmp	r0, #0
  4023d2:	d0f5      	beq.n	4023c0 <__register_exitproc+0x28>
  4023d4:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  4023d8:	2500      	movs	r5, #0
  4023da:	6045      	str	r5, [r0, #4]
  4023dc:	6002      	str	r2, [r0, #0]
  4023de:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  4023e2:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
  4023e6:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
  4023ea:	b1b6      	cbz	r6, 40241a <__register_exitproc+0x82>
  4023ec:	6844      	ldr	r4, [r0, #4]
  4023ee:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
  4023f2:	2201      	movs	r2, #1
  4023f4:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  4023f8:	fa02 f204 	lsl.w	r2, r2, r4
  4023fc:	4311      	orrs	r1, r2
  4023fe:	2e02      	cmp	r6, #2
  402400:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
  402404:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  402408:	461c      	mov	r4, r3
  40240a:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
  40240e:	d104      	bne.n	40241a <__register_exitproc+0x82>
  402410:	f8d0 318c 	ldr.w	r3, [r0, #396]	; 0x18c
  402414:	431a      	orrs	r2, r3
  402416:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
  40241a:	6841      	ldr	r1, [r0, #4]
  40241c:	1c8b      	adds	r3, r1, #2
  40241e:	1c4a      	adds	r2, r1, #1
  402420:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
  402424:	6042      	str	r2, [r0, #4]
  402426:	2000      	movs	r0, #0
  402428:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40242c:	004038d4 	.word	0x004038d4
  402430:	00402b49 	.word	0x00402b49

00402434 <__libc_fini_array>:
  402434:	b570      	push	{r4, r5, r6, lr}
  402436:	4b08      	ldr	r3, [pc, #32]	; (402458 <__libc_fini_array+0x24>)
  402438:	4c08      	ldr	r4, [pc, #32]	; (40245c <__libc_fini_array+0x28>)
  40243a:	1ae0      	subs	r0, r4, r3
  40243c:	1084      	asrs	r4, r0, #2
  40243e:	eb03 0684 	add.w	r6, r3, r4, lsl #2
  402442:	2500      	movs	r5, #0
  402444:	3d04      	subs	r5, #4
  402446:	b11c      	cbz	r4, 402450 <__libc_fini_array+0x1c>
  402448:	5972      	ldr	r2, [r6, r5]
  40244a:	4790      	blx	r2
  40244c:	3c01      	subs	r4, #1
  40244e:	e7f9      	b.n	402444 <__libc_fini_array+0x10>
  402450:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  402454:	f001 ba4c 	b.w	4038f0 <_fini>
  402458:	004038fc 	.word	0x004038fc
  40245c:	00403900 	.word	0x00403900

00402460 <__libc_init_array>:
  402460:	b538      	push	{r3, r4, r5, lr}
  402462:	4d0e      	ldr	r5, [pc, #56]	; (40249c <__libc_init_array+0x3c>)
  402464:	4b0e      	ldr	r3, [pc, #56]	; (4024a0 <__libc_init_array+0x40>)
  402466:	1ae8      	subs	r0, r5, r3
  402468:	1085      	asrs	r5, r0, #2
  40246a:	2400      	movs	r4, #0
  40246c:	42ac      	cmp	r4, r5
  40246e:	d005      	beq.n	40247c <__libc_init_array+0x1c>
  402470:	490b      	ldr	r1, [pc, #44]	; (4024a0 <__libc_init_array+0x40>)
  402472:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
  402476:	4790      	blx	r2
  402478:	3401      	adds	r4, #1
  40247a:	e7f7      	b.n	40246c <__libc_init_array+0xc>
  40247c:	f001 fa2e 	bl	4038dc <_init>
  402480:	4908      	ldr	r1, [pc, #32]	; (4024a4 <__libc_init_array+0x44>)
  402482:	4a09      	ldr	r2, [pc, #36]	; (4024a8 <__libc_init_array+0x48>)
  402484:	1a54      	subs	r4, r2, r1
  402486:	10a5      	asrs	r5, r4, #2
  402488:	2400      	movs	r4, #0
  40248a:	42ac      	cmp	r4, r5
  40248c:	d005      	beq.n	40249a <__libc_init_array+0x3a>
  40248e:	4b05      	ldr	r3, [pc, #20]	; (4024a4 <__libc_init_array+0x44>)
  402490:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  402494:	4780      	blx	r0
  402496:	3401      	adds	r4, #1
  402498:	e7f7      	b.n	40248a <__libc_init_array+0x2a>
  40249a:	bd38      	pop	{r3, r4, r5, pc}
  40249c:	004038e8 	.word	0x004038e8
  4024a0:	004038e8 	.word	0x004038e8
  4024a4:	004038e8 	.word	0x004038e8
  4024a8:	004038f0 	.word	0x004038f0

004024ac <memset>:
  4024ac:	1882      	adds	r2, r0, r2
  4024ae:	4603      	mov	r3, r0
  4024b0:	4293      	cmp	r3, r2
  4024b2:	d002      	beq.n	4024ba <memset+0xe>
  4024b4:	f803 1b01 	strb.w	r1, [r3], #1
  4024b8:	e7fa      	b.n	4024b0 <memset+0x4>
  4024ba:	4770      	bx	lr

004024bc <setbuf>:
  4024bc:	2900      	cmp	r1, #0
  4024be:	bf0c      	ite	eq
  4024c0:	2202      	moveq	r2, #2
  4024c2:	2200      	movne	r2, #0
  4024c4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4024c8:	f000 b800 	b.w	4024cc <setvbuf>

004024cc <setvbuf>:
  4024cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4024d0:	461d      	mov	r5, r3
  4024d2:	4b37      	ldr	r3, [pc, #220]	; (4025b0 <setvbuf+0xe4>)
  4024d4:	4604      	mov	r4, r0
  4024d6:	6818      	ldr	r0, [r3, #0]
  4024d8:	460e      	mov	r6, r1
  4024da:	4617      	mov	r7, r2
  4024dc:	4698      	mov	r8, r3
  4024de:	b118      	cbz	r0, 4024e8 <setvbuf+0x1c>
  4024e0:	6b82      	ldr	r2, [r0, #56]	; 0x38
  4024e2:	b90a      	cbnz	r2, 4024e8 <setvbuf+0x1c>
  4024e4:	f000 f96c 	bl	4027c0 <__sinit>
  4024e8:	2f02      	cmp	r7, #2
  4024ea:	d85d      	bhi.n	4025a8 <setvbuf+0xdc>
  4024ec:	2d00      	cmp	r5, #0
  4024ee:	db5b      	blt.n	4025a8 <setvbuf+0xdc>
  4024f0:	4621      	mov	r1, r4
  4024f2:	f8d8 0000 	ldr.w	r0, [r8]
  4024f6:	f000 f86f 	bl	4025d8 <_fflush_r>
  4024fa:	89a1      	ldrh	r1, [r4, #12]
  4024fc:	f001 0380 	and.w	r3, r1, #128	; 0x80
  402500:	2000      	movs	r0, #0
  402502:	b21a      	sxth	r2, r3
  402504:	6060      	str	r0, [r4, #4]
  402506:	61a0      	str	r0, [r4, #24]
  402508:	b122      	cbz	r2, 402514 <setvbuf+0x48>
  40250a:	4829      	ldr	r0, [pc, #164]	; (4025b0 <setvbuf+0xe4>)
  40250c:	6921      	ldr	r1, [r4, #16]
  40250e:	6800      	ldr	r0, [r0, #0]
  402510:	f000 fa20 	bl	402954 <_free_r>
  402514:	89a1      	ldrh	r1, [r4, #12]
  402516:	2f02      	cmp	r7, #2
  402518:	f021 0383 	bic.w	r3, r1, #131	; 0x83
  40251c:	81a3      	strh	r3, [r4, #12]
  40251e:	d012      	beq.n	402546 <setvbuf+0x7a>
  402520:	bb36      	cbnz	r6, 402570 <setvbuf+0xa4>
  402522:	2d00      	cmp	r5, #0
  402524:	bf08      	it	eq
  402526:	f44f 6580 	moveq.w	r5, #1024	; 0x400
  40252a:	4628      	mov	r0, r5
  40252c:	f000 fb0c 	bl	402b48 <malloc>
  402530:	4606      	mov	r6, r0
  402532:	b9c8      	cbnz	r0, 402568 <setvbuf+0x9c>
  402534:	f44f 6080 	mov.w	r0, #1024	; 0x400
  402538:	f000 fb06 	bl	402b48 <malloc>
  40253c:	4606      	mov	r6, r0
  40253e:	b988      	cbnz	r0, 402564 <setvbuf+0x98>
  402540:	f04f 30ff 	mov.w	r0, #4294967295
  402544:	e000      	b.n	402548 <setvbuf+0x7c>
  402546:	2000      	movs	r0, #0
  402548:	89a1      	ldrh	r1, [r4, #12]
  40254a:	f041 0302 	orr.w	r3, r1, #2
  40254e:	81a3      	strh	r3, [r4, #12]
  402550:	f104 0143 	add.w	r1, r4, #67	; 0x43
  402554:	2200      	movs	r2, #0
  402556:	2301      	movs	r3, #1
  402558:	60a2      	str	r2, [r4, #8]
  40255a:	6021      	str	r1, [r4, #0]
  40255c:	6121      	str	r1, [r4, #16]
  40255e:	6163      	str	r3, [r4, #20]
  402560:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402564:	f44f 6580 	mov.w	r5, #1024	; 0x400
  402568:	89a2      	ldrh	r2, [r4, #12]
  40256a:	f042 0080 	orr.w	r0, r2, #128	; 0x80
  40256e:	81a0      	strh	r0, [r4, #12]
  402570:	2f01      	cmp	r7, #1
  402572:	d105      	bne.n	402580 <setvbuf+0xb4>
  402574:	89a1      	ldrh	r1, [r4, #12]
  402576:	426a      	negs	r2, r5
  402578:	f041 0301 	orr.w	r3, r1, #1
  40257c:	81a3      	strh	r3, [r4, #12]
  40257e:	61a2      	str	r2, [r4, #24]
  402580:	480b      	ldr	r0, [pc, #44]	; (4025b0 <setvbuf+0xe4>)
  402582:	89a2      	ldrh	r2, [r4, #12]
  402584:	6801      	ldr	r1, [r0, #0]
  402586:	4b0b      	ldr	r3, [pc, #44]	; (4025b4 <setvbuf+0xe8>)
  402588:	f002 0008 	and.w	r0, r2, #8
  40258c:	b200      	sxth	r0, r0
  40258e:	63cb      	str	r3, [r1, #60]	; 0x3c
  402590:	6026      	str	r6, [r4, #0]
  402592:	6126      	str	r6, [r4, #16]
  402594:	6165      	str	r5, [r4, #20]
  402596:	b148      	cbz	r0, 4025ac <setvbuf+0xe0>
  402598:	f012 0f03 	tst.w	r2, #3
  40259c:	bf18      	it	ne
  40259e:	2500      	movne	r5, #0
  4025a0:	60a5      	str	r5, [r4, #8]
  4025a2:	2000      	movs	r0, #0
  4025a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4025a8:	f04f 30ff 	mov.w	r0, #4294967295
  4025ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4025b0:	20000010 	.word	0x20000010
  4025b4:	00402735 	.word	0x00402735

004025b8 <register_fini>:
  4025b8:	4b02      	ldr	r3, [pc, #8]	; (4025c4 <register_fini+0xc>)
  4025ba:	b113      	cbz	r3, 4025c2 <register_fini+0xa>
  4025bc:	4802      	ldr	r0, [pc, #8]	; (4025c8 <register_fini+0x10>)
  4025be:	f000 b805 	b.w	4025cc <atexit>
  4025c2:	4770      	bx	lr
  4025c4:	00000000 	.word	0x00000000
  4025c8:	00402435 	.word	0x00402435

004025cc <atexit>:
  4025cc:	4601      	mov	r1, r0
  4025ce:	2000      	movs	r0, #0
  4025d0:	4602      	mov	r2, r0
  4025d2:	4603      	mov	r3, r0
  4025d4:	f7ff bee0 	b.w	402398 <__register_exitproc>

004025d8 <_fflush_r>:
  4025d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4025dc:	460c      	mov	r4, r1
  4025de:	4605      	mov	r5, r0
  4025e0:	b118      	cbz	r0, 4025ea <_fflush_r+0x12>
  4025e2:	6b83      	ldr	r3, [r0, #56]	; 0x38
  4025e4:	b90b      	cbnz	r3, 4025ea <_fflush_r+0x12>
  4025e6:	f000 f8eb 	bl	4027c0 <__sinit>
  4025ea:	89a2      	ldrh	r2, [r4, #12]
  4025ec:	b332      	cbz	r2, 40263c <_fflush_r+0x64>
  4025ee:	f002 0008 	and.w	r0, r2, #8
  4025f2:	b201      	sxth	r1, r0
  4025f4:	2900      	cmp	r1, #0
  4025f6:	d162      	bne.n	4026be <_fflush_r+0xe6>
  4025f8:	6861      	ldr	r1, [r4, #4]
  4025fa:	f442 6000 	orr.w	r0, r2, #2048	; 0x800
  4025fe:	2900      	cmp	r1, #0
  402600:	81a0      	strh	r0, [r4, #12]
  402602:	dc02      	bgt.n	40260a <_fflush_r+0x32>
  402604:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  402606:	2b00      	cmp	r3, #0
  402608:	dd18      	ble.n	40263c <_fflush_r+0x64>
  40260a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  40260c:	b1b6      	cbz	r6, 40263c <_fflush_r+0x64>
  40260e:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
  402612:	2000      	movs	r0, #0
  402614:	b212      	sxth	r2, r2
  402616:	682f      	ldr	r7, [r5, #0]
  402618:	6028      	str	r0, [r5, #0]
  40261a:	b10a      	cbz	r2, 402620 <_fflush_r+0x48>
  40261c:	6d22      	ldr	r2, [r4, #80]	; 0x50
  40261e:	e010      	b.n	402642 <_fflush_r+0x6a>
  402620:	2301      	movs	r3, #1
  402622:	4628      	mov	r0, r5
  402624:	69e1      	ldr	r1, [r4, #28]
  402626:	47b0      	blx	r6
  402628:	4602      	mov	r2, r0
  40262a:	3001      	adds	r0, #1
  40262c:	d109      	bne.n	402642 <_fflush_r+0x6a>
  40262e:	6829      	ldr	r1, [r5, #0]
  402630:	b139      	cbz	r1, 402642 <_fflush_r+0x6a>
  402632:	291d      	cmp	r1, #29
  402634:	d001      	beq.n	40263a <_fflush_r+0x62>
  402636:	2916      	cmp	r1, #22
  402638:	d14f      	bne.n	4026da <_fflush_r+0x102>
  40263a:	602f      	str	r7, [r5, #0]
  40263c:	2000      	movs	r0, #0
  40263e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402642:	89a6      	ldrh	r6, [r4, #12]
  402644:	f006 0104 	and.w	r1, r6, #4
  402648:	b20b      	sxth	r3, r1
  40264a:	b12b      	cbz	r3, 402658 <_fflush_r+0x80>
  40264c:	6860      	ldr	r0, [r4, #4]
  40264e:	6b26      	ldr	r6, [r4, #48]	; 0x30
  402650:	1a12      	subs	r2, r2, r0
  402652:	b10e      	cbz	r6, 402658 <_fflush_r+0x80>
  402654:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  402656:	1a52      	subs	r2, r2, r1
  402658:	69e1      	ldr	r1, [r4, #28]
  40265a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  40265c:	2300      	movs	r3, #0
  40265e:	4628      	mov	r0, r5
  402660:	47b0      	blx	r6
  402662:	1c41      	adds	r1, r0, #1
  402664:	d105      	bne.n	402672 <_fflush_r+0x9a>
  402666:	682a      	ldr	r2, [r5, #0]
  402668:	b11a      	cbz	r2, 402672 <_fflush_r+0x9a>
  40266a:	2a1d      	cmp	r2, #29
  40266c:	d001      	beq.n	402672 <_fflush_r+0x9a>
  40266e:	2a16      	cmp	r2, #22
  402670:	d11f      	bne.n	4026b2 <_fflush_r+0xda>
  402672:	89a3      	ldrh	r3, [r4, #12]
  402674:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
  402678:	2100      	movs	r1, #0
  40267a:	81a2      	strh	r2, [r4, #12]
  40267c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  402680:	6922      	ldr	r2, [r4, #16]
  402682:	6061      	str	r1, [r4, #4]
  402684:	b219      	sxth	r1, r3
  402686:	6022      	str	r2, [r4, #0]
  402688:	b121      	cbz	r1, 402694 <_fflush_r+0xbc>
  40268a:	1c42      	adds	r2, r0, #1
  40268c:	d101      	bne.n	402692 <_fflush_r+0xba>
  40268e:	682a      	ldr	r2, [r5, #0]
  402690:	b902      	cbnz	r2, 402694 <_fflush_r+0xbc>
  402692:	6520      	str	r0, [r4, #80]	; 0x50
  402694:	6b21      	ldr	r1, [r4, #48]	; 0x30
  402696:	602f      	str	r7, [r5, #0]
  402698:	2900      	cmp	r1, #0
  40269a:	d0cf      	beq.n	40263c <_fflush_r+0x64>
  40269c:	f104 0040 	add.w	r0, r4, #64	; 0x40
  4026a0:	4281      	cmp	r1, r0
  4026a2:	d002      	beq.n	4026aa <_fflush_r+0xd2>
  4026a4:	4628      	mov	r0, r5
  4026a6:	f000 f955 	bl	402954 <_free_r>
  4026aa:	2000      	movs	r0, #0
  4026ac:	6320      	str	r0, [r4, #48]	; 0x30
  4026ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4026b2:	89a3      	ldrh	r3, [r4, #12]
  4026b4:	f043 0140 	orr.w	r1, r3, #64	; 0x40
  4026b8:	81a1      	strh	r1, [r4, #12]
  4026ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4026be:	6926      	ldr	r6, [r4, #16]
  4026c0:	2e00      	cmp	r6, #0
  4026c2:	d0bb      	beq.n	40263c <_fflush_r+0x64>
  4026c4:	0792      	lsls	r2, r2, #30
  4026c6:	6823      	ldr	r3, [r4, #0]
  4026c8:	bf08      	it	eq
  4026ca:	6962      	ldreq	r2, [r4, #20]
  4026cc:	6026      	str	r6, [r4, #0]
  4026ce:	bf18      	it	ne
  4026d0:	2200      	movne	r2, #0
  4026d2:	ebc6 0803 	rsb	r8, r6, r3
  4026d6:	60a2      	str	r2, [r4, #8]
  4026d8:	e012      	b.n	402700 <_fflush_r+0x128>
  4026da:	89a3      	ldrh	r3, [r4, #12]
  4026dc:	f043 0040 	orr.w	r0, r3, #64	; 0x40
  4026e0:	81a0      	strh	r0, [r4, #12]
  4026e2:	f04f 30ff 	mov.w	r0, #4294967295
  4026e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4026ea:	6a67      	ldr	r7, [r4, #36]	; 0x24
  4026ec:	69e1      	ldr	r1, [r4, #28]
  4026ee:	4628      	mov	r0, r5
  4026f0:	4632      	mov	r2, r6
  4026f2:	4643      	mov	r3, r8
  4026f4:	47b8      	blx	r7
  4026f6:	2800      	cmp	r0, #0
  4026f8:	ddef      	ble.n	4026da <_fflush_r+0x102>
  4026fa:	1836      	adds	r6, r6, r0
  4026fc:	ebc0 0808 	rsb	r8, r0, r8
  402700:	f1b8 0f00 	cmp.w	r8, #0
  402704:	dcf1      	bgt.n	4026ea <_fflush_r+0x112>
  402706:	e799      	b.n	40263c <_fflush_r+0x64>

00402708 <fflush>:
  402708:	4601      	mov	r1, r0
  40270a:	b920      	cbnz	r0, 402716 <fflush+0xe>
  40270c:	4804      	ldr	r0, [pc, #16]	; (402720 <fflush+0x18>)
  40270e:	4905      	ldr	r1, [pc, #20]	; (402724 <fflush+0x1c>)
  402710:	6800      	ldr	r0, [r0, #0]
  402712:	f000 b9f6 	b.w	402b02 <_fwalk_reent>
  402716:	4b04      	ldr	r3, [pc, #16]	; (402728 <fflush+0x20>)
  402718:	6818      	ldr	r0, [r3, #0]
  40271a:	f7ff bf5d 	b.w	4025d8 <_fflush_r>
  40271e:	bf00      	nop
  402720:	004038d4 	.word	0x004038d4
  402724:	004025d9 	.word	0x004025d9
  402728:	20000010 	.word	0x20000010

0040272c <__fp_lock>:
  40272c:	2000      	movs	r0, #0
  40272e:	4770      	bx	lr

00402730 <__fp_unlock>:
  402730:	2000      	movs	r0, #0
  402732:	4770      	bx	lr

00402734 <_cleanup_r>:
  402734:	4901      	ldr	r1, [pc, #4]	; (40273c <_cleanup_r+0x8>)
  402736:	f000 b9c3 	b.w	402ac0 <_fwalk>
  40273a:	bf00      	nop
  40273c:	004030e9 	.word	0x004030e9

00402740 <std.isra.0>:
  402740:	2300      	movs	r3, #0
  402742:	b510      	push	{r4, lr}
  402744:	4604      	mov	r4, r0
  402746:	6003      	str	r3, [r0, #0]
  402748:	6043      	str	r3, [r0, #4]
  40274a:	6083      	str	r3, [r0, #8]
  40274c:	8181      	strh	r1, [r0, #12]
  40274e:	6643      	str	r3, [r0, #100]	; 0x64
  402750:	81c2      	strh	r2, [r0, #14]
  402752:	6103      	str	r3, [r0, #16]
  402754:	6143      	str	r3, [r0, #20]
  402756:	6183      	str	r3, [r0, #24]
  402758:	4619      	mov	r1, r3
  40275a:	2208      	movs	r2, #8
  40275c:	f100 005c 	add.w	r0, r0, #92	; 0x5c
  402760:	f7ff fea4 	bl	4024ac <memset>
  402764:	4804      	ldr	r0, [pc, #16]	; (402778 <std.isra.0+0x38>)
  402766:	4905      	ldr	r1, [pc, #20]	; (40277c <std.isra.0+0x3c>)
  402768:	4a05      	ldr	r2, [pc, #20]	; (402780 <std.isra.0+0x40>)
  40276a:	4b06      	ldr	r3, [pc, #24]	; (402784 <std.isra.0+0x44>)
  40276c:	61e4      	str	r4, [r4, #28]
  40276e:	6220      	str	r0, [r4, #32]
  402770:	6261      	str	r1, [r4, #36]	; 0x24
  402772:	62a2      	str	r2, [r4, #40]	; 0x28
  402774:	62e3      	str	r3, [r4, #44]	; 0x2c
  402776:	bd10      	pop	{r4, pc}
  402778:	00402f91 	.word	0x00402f91
  40277c:	00402fb7 	.word	0x00402fb7
  402780:	00402ff3 	.word	0x00402ff3
  402784:	00403017 	.word	0x00403017

00402788 <__sfmoreglue>:
  402788:	b570      	push	{r4, r5, r6, lr}
  40278a:	2568      	movs	r5, #104	; 0x68
  40278c:	434d      	muls	r5, r1
  40278e:	460e      	mov	r6, r1
  402790:	f105 010c 	add.w	r1, r5, #12
  402794:	f000 f9e8 	bl	402b68 <_malloc_r>
  402798:	4604      	mov	r4, r0
  40279a:	b140      	cbz	r0, 4027ae <__sfmoreglue+0x26>
  40279c:	f100 000c 	add.w	r0, r0, #12
  4027a0:	2100      	movs	r1, #0
  4027a2:	e884 0042 	stmia.w	r4, {r1, r6}
  4027a6:	60a0      	str	r0, [r4, #8]
  4027a8:	462a      	mov	r2, r5
  4027aa:	f7ff fe7f 	bl	4024ac <memset>
  4027ae:	4620      	mov	r0, r4
  4027b0:	bd70      	pop	{r4, r5, r6, pc}

004027b2 <_cleanup>:
  4027b2:	4b02      	ldr	r3, [pc, #8]	; (4027bc <_cleanup+0xa>)
  4027b4:	6818      	ldr	r0, [r3, #0]
  4027b6:	f7ff bfbd 	b.w	402734 <_cleanup_r>
  4027ba:	bf00      	nop
  4027bc:	004038d4 	.word	0x004038d4

004027c0 <__sinit>:
  4027c0:	b538      	push	{r3, r4, r5, lr}
  4027c2:	6b83      	ldr	r3, [r0, #56]	; 0x38
  4027c4:	4604      	mov	r4, r0
  4027c6:	b9eb      	cbnz	r3, 402804 <__sinit+0x44>
  4027c8:	4a0f      	ldr	r2, [pc, #60]	; (402808 <__sinit+0x48>)
  4027ca:	f8c0 32e0 	str.w	r3, [r0, #736]	; 0x2e0
  4027ce:	2501      	movs	r5, #1
  4027d0:	63c2      	str	r2, [r0, #60]	; 0x3c
  4027d2:	6385      	str	r5, [r0, #56]	; 0x38
  4027d4:	f504 713b 	add.w	r1, r4, #748	; 0x2ec
  4027d8:	2003      	movs	r0, #3
  4027da:	461a      	mov	r2, r3
  4027dc:	f8c4 02e4 	str.w	r0, [r4, #740]	; 0x2e4
  4027e0:	f8c4 12e8 	str.w	r1, [r4, #744]	; 0x2e8
  4027e4:	6860      	ldr	r0, [r4, #4]
  4027e6:	2104      	movs	r1, #4
  4027e8:	f7ff ffaa 	bl	402740 <std.isra.0>
  4027ec:	68a0      	ldr	r0, [r4, #8]
  4027ee:	2109      	movs	r1, #9
  4027f0:	462a      	mov	r2, r5
  4027f2:	f7ff ffa5 	bl	402740 <std.isra.0>
  4027f6:	68e0      	ldr	r0, [r4, #12]
  4027f8:	2112      	movs	r1, #18
  4027fa:	2202      	movs	r2, #2
  4027fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  402800:	f7ff bf9e 	b.w	402740 <std.isra.0>
  402804:	bd38      	pop	{r3, r4, r5, pc}
  402806:	bf00      	nop
  402808:	00402735 	.word	0x00402735

0040280c <__sfp>:
  40280c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40280e:	4b1d      	ldr	r3, [pc, #116]	; (402884 <__sfp+0x78>)
  402810:	681e      	ldr	r6, [r3, #0]
  402812:	4607      	mov	r7, r0
  402814:	6bb0      	ldr	r0, [r6, #56]	; 0x38
  402816:	b910      	cbnz	r0, 40281e <__sfp+0x12>
  402818:	4630      	mov	r0, r6
  40281a:	f7ff ffd1 	bl	4027c0 <__sinit>
  40281e:	f506 7638 	add.w	r6, r6, #736	; 0x2e0
  402822:	68b4      	ldr	r4, [r6, #8]
  402824:	6871      	ldr	r1, [r6, #4]
  402826:	3901      	subs	r1, #1
  402828:	d404      	bmi.n	402834 <__sfp+0x28>
  40282a:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  40282e:	b185      	cbz	r5, 402852 <__sfp+0x46>
  402830:	3468      	adds	r4, #104	; 0x68
  402832:	e7f8      	b.n	402826 <__sfp+0x1a>
  402834:	6832      	ldr	r2, [r6, #0]
  402836:	b10a      	cbz	r2, 40283c <__sfp+0x30>
  402838:	6836      	ldr	r6, [r6, #0]
  40283a:	e7f2      	b.n	402822 <__sfp+0x16>
  40283c:	4638      	mov	r0, r7
  40283e:	2104      	movs	r1, #4
  402840:	f7ff ffa2 	bl	402788 <__sfmoreglue>
  402844:	6030      	str	r0, [r6, #0]
  402846:	2800      	cmp	r0, #0
  402848:	d1f6      	bne.n	402838 <__sfp+0x2c>
  40284a:	240c      	movs	r4, #12
  40284c:	603c      	str	r4, [r7, #0]
  40284e:	4604      	mov	r4, r0
  402850:	e015      	b.n	40287e <__sfp+0x72>
  402852:	f64f 73ff 	movw	r3, #65535	; 0xffff
  402856:	2001      	movs	r0, #1
  402858:	81a0      	strh	r0, [r4, #12]
  40285a:	81e3      	strh	r3, [r4, #14]
  40285c:	6665      	str	r5, [r4, #100]	; 0x64
  40285e:	6025      	str	r5, [r4, #0]
  402860:	60a5      	str	r5, [r4, #8]
  402862:	6065      	str	r5, [r4, #4]
  402864:	6125      	str	r5, [r4, #16]
  402866:	6165      	str	r5, [r4, #20]
  402868:	61a5      	str	r5, [r4, #24]
  40286a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  40286e:	4629      	mov	r1, r5
  402870:	2208      	movs	r2, #8
  402872:	f7ff fe1b 	bl	4024ac <memset>
  402876:	6325      	str	r5, [r4, #48]	; 0x30
  402878:	6365      	str	r5, [r4, #52]	; 0x34
  40287a:	6465      	str	r5, [r4, #68]	; 0x44
  40287c:	64a5      	str	r5, [r4, #72]	; 0x48
  40287e:	4620      	mov	r0, r4
  402880:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402882:	bf00      	nop
  402884:	004038d4 	.word	0x004038d4

00402888 <__sfp_lock_acquire>:
  402888:	4770      	bx	lr

0040288a <__sfp_lock_release>:
  40288a:	4770      	bx	lr

0040288c <__sinit_lock_acquire>:
  40288c:	4770      	bx	lr

0040288e <__sinit_lock_release>:
  40288e:	4770      	bx	lr

00402890 <__fp_lock_all>:
  402890:	4b02      	ldr	r3, [pc, #8]	; (40289c <__fp_lock_all+0xc>)
  402892:	4903      	ldr	r1, [pc, #12]	; (4028a0 <__fp_lock_all+0x10>)
  402894:	6818      	ldr	r0, [r3, #0]
  402896:	f000 b913 	b.w	402ac0 <_fwalk>
  40289a:	bf00      	nop
  40289c:	20000010 	.word	0x20000010
  4028a0:	0040272d 	.word	0x0040272d

004028a4 <__fp_unlock_all>:
  4028a4:	4b02      	ldr	r3, [pc, #8]	; (4028b0 <__fp_unlock_all+0xc>)
  4028a6:	4903      	ldr	r1, [pc, #12]	; (4028b4 <__fp_unlock_all+0x10>)
  4028a8:	6818      	ldr	r0, [r3, #0]
  4028aa:	f000 b909 	b.w	402ac0 <_fwalk>
  4028ae:	bf00      	nop
  4028b0:	20000010 	.word	0x20000010
  4028b4:	00402731 	.word	0x00402731

004028b8 <_malloc_trim_r>:
  4028b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4028ba:	4d23      	ldr	r5, [pc, #140]	; (402948 <_malloc_trim_r+0x90>)
  4028bc:	460e      	mov	r6, r1
  4028be:	4604      	mov	r4, r0
  4028c0:	f000 fb54 	bl	402f6c <__malloc_lock>
  4028c4:	68ab      	ldr	r3, [r5, #8]
  4028c6:	685f      	ldr	r7, [r3, #4]
  4028c8:	f027 0703 	bic.w	r7, r7, #3
  4028cc:	f607 70ef 	addw	r0, r7, #4079	; 0xfef
  4028d0:	1b81      	subs	r1, r0, r6
  4028d2:	f421 627f 	bic.w	r2, r1, #4080	; 0xff0
  4028d6:	f022 060f 	bic.w	r6, r2, #15
  4028da:	f5a6 5680 	sub.w	r6, r6, #4096	; 0x1000
  4028de:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
  4028e2:	da04      	bge.n	4028ee <_malloc_trim_r+0x36>
  4028e4:	4620      	mov	r0, r4
  4028e6:	f000 fb42 	bl	402f6e <__malloc_unlock>
  4028ea:	2000      	movs	r0, #0
  4028ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4028ee:	2100      	movs	r1, #0
  4028f0:	4620      	mov	r0, r4
  4028f2:	f000 fb3d 	bl	402f70 <_sbrk_r>
  4028f6:	68ab      	ldr	r3, [r5, #8]
  4028f8:	19d9      	adds	r1, r3, r7
  4028fa:	4288      	cmp	r0, r1
  4028fc:	d1f2      	bne.n	4028e4 <_malloc_trim_r+0x2c>
  4028fe:	4271      	negs	r1, r6
  402900:	4620      	mov	r0, r4
  402902:	f000 fb35 	bl	402f70 <_sbrk_r>
  402906:	3001      	adds	r0, #1
  402908:	d110      	bne.n	40292c <_malloc_trim_r+0x74>
  40290a:	2100      	movs	r1, #0
  40290c:	4620      	mov	r0, r4
  40290e:	f000 fb2f 	bl	402f70 <_sbrk_r>
  402912:	68ab      	ldr	r3, [r5, #8]
  402914:	1ac2      	subs	r2, r0, r3
  402916:	2a0f      	cmp	r2, #15
  402918:	dde4      	ble.n	4028e4 <_malloc_trim_r+0x2c>
  40291a:	490c      	ldr	r1, [pc, #48]	; (40294c <_malloc_trim_r+0x94>)
  40291c:	6809      	ldr	r1, [r1, #0]
  40291e:	1a40      	subs	r0, r0, r1
  402920:	490b      	ldr	r1, [pc, #44]	; (402950 <_malloc_trim_r+0x98>)
  402922:	f042 0201 	orr.w	r2, r2, #1
  402926:	6008      	str	r0, [r1, #0]
  402928:	605a      	str	r2, [r3, #4]
  40292a:	e7db      	b.n	4028e4 <_malloc_trim_r+0x2c>
  40292c:	4b08      	ldr	r3, [pc, #32]	; (402950 <_malloc_trim_r+0x98>)
  40292e:	68a8      	ldr	r0, [r5, #8]
  402930:	681a      	ldr	r2, [r3, #0]
  402932:	1bbf      	subs	r7, r7, r6
  402934:	f047 0701 	orr.w	r7, r7, #1
  402938:	6047      	str	r7, [r0, #4]
  40293a:	1b96      	subs	r6, r2, r6
  40293c:	4620      	mov	r0, r4
  40293e:	601e      	str	r6, [r3, #0]
  402940:	f000 fb15 	bl	402f6e <__malloc_unlock>
  402944:	2001      	movs	r0, #1
  402946:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402948:	20000440 	.word	0x20000440
  40294c:	20000848 	.word	0x20000848
  402950:	20000cac 	.word	0x20000cac

00402954 <_free_r>:
  402954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402956:	4606      	mov	r6, r0
  402958:	460d      	mov	r5, r1
  40295a:	2900      	cmp	r1, #0
  40295c:	f000 80a6 	beq.w	402aac <_free_r+0x158>
  402960:	f000 fb04 	bl	402f6c <__malloc_lock>
  402964:	f855 cc04 	ldr.w	ip, [r5, #-4]
  402968:	4f51      	ldr	r7, [pc, #324]	; (402ab0 <_free_r+0x15c>)
  40296a:	f1a5 0308 	sub.w	r3, r5, #8
  40296e:	f02c 0201 	bic.w	r2, ip, #1
  402972:	189c      	adds	r4, r3, r2
  402974:	68b9      	ldr	r1, [r7, #8]
  402976:	6860      	ldr	r0, [r4, #4]
  402978:	428c      	cmp	r4, r1
  40297a:	f020 0003 	bic.w	r0, r0, #3
  40297e:	f00c 0101 	and.w	r1, ip, #1
  402982:	d11c      	bne.n	4029be <_free_r+0x6a>
  402984:	1882      	adds	r2, r0, r2
  402986:	b939      	cbnz	r1, 402998 <_free_r+0x44>
  402988:	f855 1c08 	ldr.w	r1, [r5, #-8]
  40298c:	1a5b      	subs	r3, r3, r1
  40298e:	1852      	adds	r2, r2, r1
  402990:	6898      	ldr	r0, [r3, #8]
  402992:	68d9      	ldr	r1, [r3, #12]
  402994:	60c1      	str	r1, [r0, #12]
  402996:	6088      	str	r0, [r1, #8]
  402998:	4845      	ldr	r0, [pc, #276]	; (402ab0 <_free_r+0x15c>)
  40299a:	f042 0101 	orr.w	r1, r2, #1
  40299e:	6059      	str	r1, [r3, #4]
  4029a0:	6083      	str	r3, [r0, #8]
  4029a2:	4b44      	ldr	r3, [pc, #272]	; (402ab4 <_free_r+0x160>)
  4029a4:	6819      	ldr	r1, [r3, #0]
  4029a6:	428a      	cmp	r2, r1
  4029a8:	d304      	bcc.n	4029b4 <_free_r+0x60>
  4029aa:	4a43      	ldr	r2, [pc, #268]	; (402ab8 <_free_r+0x164>)
  4029ac:	4630      	mov	r0, r6
  4029ae:	6811      	ldr	r1, [r2, #0]
  4029b0:	f7ff ff82 	bl	4028b8 <_malloc_trim_r>
  4029b4:	4630      	mov	r0, r6
  4029b6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  4029ba:	f000 bad8 	b.w	402f6e <__malloc_unlock>
  4029be:	6060      	str	r0, [r4, #4]
  4029c0:	b959      	cbnz	r1, 4029da <_free_r+0x86>
  4029c2:	f855 5c08 	ldr.w	r5, [r5, #-8]
  4029c6:	1b5b      	subs	r3, r3, r5
  4029c8:	1952      	adds	r2, r2, r5
  4029ca:	689d      	ldr	r5, [r3, #8]
  4029cc:	3708      	adds	r7, #8
  4029ce:	42bd      	cmp	r5, r7
  4029d0:	d005      	beq.n	4029de <_free_r+0x8a>
  4029d2:	68df      	ldr	r7, [r3, #12]
  4029d4:	60ef      	str	r7, [r5, #12]
  4029d6:	60bd      	str	r5, [r7, #8]
  4029d8:	e002      	b.n	4029e0 <_free_r+0x8c>
  4029da:	2100      	movs	r1, #0
  4029dc:	e000      	b.n	4029e0 <_free_r+0x8c>
  4029de:	2101      	movs	r1, #1
  4029e0:	1825      	adds	r5, r4, r0
  4029e2:	686d      	ldr	r5, [r5, #4]
  4029e4:	f015 0f01 	tst.w	r5, #1
  4029e8:	d10f      	bne.n	402a0a <_free_r+0xb6>
  4029ea:	1812      	adds	r2, r2, r0
  4029ec:	b949      	cbnz	r1, 402a02 <_free_r+0xae>
  4029ee:	68a0      	ldr	r0, [r4, #8]
  4029f0:	4d32      	ldr	r5, [pc, #200]	; (402abc <_free_r+0x168>)
  4029f2:	42a8      	cmp	r0, r5
  4029f4:	d105      	bne.n	402a02 <_free_r+0xae>
  4029f6:	60eb      	str	r3, [r5, #12]
  4029f8:	60ab      	str	r3, [r5, #8]
  4029fa:	60d8      	str	r0, [r3, #12]
  4029fc:	6098      	str	r0, [r3, #8]
  4029fe:	2101      	movs	r1, #1
  402a00:	e003      	b.n	402a0a <_free_r+0xb6>
  402a02:	68e0      	ldr	r0, [r4, #12]
  402a04:	68a4      	ldr	r4, [r4, #8]
  402a06:	60e0      	str	r0, [r4, #12]
  402a08:	6084      	str	r4, [r0, #8]
  402a0a:	f042 0001 	orr.w	r0, r2, #1
  402a0e:	6058      	str	r0, [r3, #4]
  402a10:	509a      	str	r2, [r3, r2]
  402a12:	2900      	cmp	r1, #0
  402a14:	d1ce      	bne.n	4029b4 <_free_r+0x60>
  402a16:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  402a1a:	d20c      	bcs.n	402a36 <_free_r+0xe2>
  402a1c:	4924      	ldr	r1, [pc, #144]	; (402ab0 <_free_r+0x15c>)
  402a1e:	08d2      	lsrs	r2, r2, #3
  402a20:	1090      	asrs	r0, r2, #2
  402a22:	2401      	movs	r4, #1
  402a24:	fa04 f400 	lsl.w	r4, r4, r0
  402a28:	6848      	ldr	r0, [r1, #4]
  402a2a:	4320      	orrs	r0, r4
  402a2c:	6048      	str	r0, [r1, #4]
  402a2e:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
  402a32:	6881      	ldr	r1, [r0, #8]
  402a34:	e035      	b.n	402aa2 <_free_r+0x14e>
  402a36:	0a54      	lsrs	r4, r2, #9
  402a38:	2c04      	cmp	r4, #4
  402a3a:	d802      	bhi.n	402a42 <_free_r+0xee>
  402a3c:	0994      	lsrs	r4, r2, #6
  402a3e:	3438      	adds	r4, #56	; 0x38
  402a40:	e016      	b.n	402a70 <_free_r+0x11c>
  402a42:	2c14      	cmp	r4, #20
  402a44:	d801      	bhi.n	402a4a <_free_r+0xf6>
  402a46:	345b      	adds	r4, #91	; 0x5b
  402a48:	e012      	b.n	402a70 <_free_r+0x11c>
  402a4a:	2c54      	cmp	r4, #84	; 0x54
  402a4c:	d802      	bhi.n	402a54 <_free_r+0x100>
  402a4e:	0b14      	lsrs	r4, r2, #12
  402a50:	346e      	adds	r4, #110	; 0x6e
  402a52:	e00d      	b.n	402a70 <_free_r+0x11c>
  402a54:	f5b4 7faa 	cmp.w	r4, #340	; 0x154
  402a58:	d802      	bhi.n	402a60 <_free_r+0x10c>
  402a5a:	0bd4      	lsrs	r4, r2, #15
  402a5c:	3477      	adds	r4, #119	; 0x77
  402a5e:	e007      	b.n	402a70 <_free_r+0x11c>
  402a60:	f240 5554 	movw	r5, #1364	; 0x554
  402a64:	42ac      	cmp	r4, r5
  402a66:	d802      	bhi.n	402a6e <_free_r+0x11a>
  402a68:	0c94      	lsrs	r4, r2, #18
  402a6a:	347c      	adds	r4, #124	; 0x7c
  402a6c:	e000      	b.n	402a70 <_free_r+0x11c>
  402a6e:	247e      	movs	r4, #126	; 0x7e
  402a70:	4d0f      	ldr	r5, [pc, #60]	; (402ab0 <_free_r+0x15c>)
  402a72:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
  402a76:	6881      	ldr	r1, [r0, #8]
  402a78:	4281      	cmp	r1, r0
  402a7a:	d10c      	bne.n	402a96 <_free_r+0x142>
  402a7c:	6868      	ldr	r0, [r5, #4]
  402a7e:	2201      	movs	r2, #1
  402a80:	10a4      	asrs	r4, r4, #2
  402a82:	fa02 f404 	lsl.w	r4, r2, r4
  402a86:	ea44 0200 	orr.w	r2, r4, r0
  402a8a:	606a      	str	r2, [r5, #4]
  402a8c:	4608      	mov	r0, r1
  402a8e:	e008      	b.n	402aa2 <_free_r+0x14e>
  402a90:	6889      	ldr	r1, [r1, #8]
  402a92:	4281      	cmp	r1, r0
  402a94:	d004      	beq.n	402aa0 <_free_r+0x14c>
  402a96:	684c      	ldr	r4, [r1, #4]
  402a98:	f024 0403 	bic.w	r4, r4, #3
  402a9c:	42a2      	cmp	r2, r4
  402a9e:	d3f7      	bcc.n	402a90 <_free_r+0x13c>
  402aa0:	68c8      	ldr	r0, [r1, #12]
  402aa2:	60d8      	str	r0, [r3, #12]
  402aa4:	6099      	str	r1, [r3, #8]
  402aa6:	6083      	str	r3, [r0, #8]
  402aa8:	60cb      	str	r3, [r1, #12]
  402aaa:	e783      	b.n	4029b4 <_free_r+0x60>
  402aac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402aae:	bf00      	nop
  402ab0:	20000440 	.word	0x20000440
  402ab4:	2000084c 	.word	0x2000084c
  402ab8:	20000ca8 	.word	0x20000ca8
  402abc:	20000448 	.word	0x20000448

00402ac0 <_fwalk>:
  402ac0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402ac4:	4604      	mov	r4, r0
  402ac6:	4688      	mov	r8, r1
  402ac8:	f7ff fede 	bl	402888 <__sfp_lock_acquire>
  402acc:	f504 7438 	add.w	r4, r4, #736	; 0x2e0
  402ad0:	2600      	movs	r6, #0
  402ad2:	b18c      	cbz	r4, 402af8 <_fwalk+0x38>
  402ad4:	68a5      	ldr	r5, [r4, #8]
  402ad6:	6867      	ldr	r7, [r4, #4]
  402ad8:	3f01      	subs	r7, #1
  402ada:	d40b      	bmi.n	402af4 <_fwalk+0x34>
  402adc:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
  402ae0:	b133      	cbz	r3, 402af0 <_fwalk+0x30>
  402ae2:	f9b5 000e 	ldrsh.w	r0, [r5, #14]
  402ae6:	1c43      	adds	r3, r0, #1
  402ae8:	d002      	beq.n	402af0 <_fwalk+0x30>
  402aea:	4628      	mov	r0, r5
  402aec:	47c0      	blx	r8
  402aee:	4306      	orrs	r6, r0
  402af0:	3568      	adds	r5, #104	; 0x68
  402af2:	e7f1      	b.n	402ad8 <_fwalk+0x18>
  402af4:	6824      	ldr	r4, [r4, #0]
  402af6:	e7ec      	b.n	402ad2 <_fwalk+0x12>
  402af8:	f7ff fec7 	bl	40288a <__sfp_lock_release>
  402afc:	4630      	mov	r0, r6
  402afe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00402b02 <_fwalk_reent>:
  402b02:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  402b06:	4680      	mov	r8, r0
  402b08:	4689      	mov	r9, r1
  402b0a:	f7ff febd 	bl	402888 <__sfp_lock_acquire>
  402b0e:	f508 7438 	add.w	r4, r8, #736	; 0x2e0
  402b12:	2600      	movs	r6, #0
  402b14:	b194      	cbz	r4, 402b3c <_fwalk_reent+0x3a>
  402b16:	68a5      	ldr	r5, [r4, #8]
  402b18:	6867      	ldr	r7, [r4, #4]
  402b1a:	3f01      	subs	r7, #1
  402b1c:	d40c      	bmi.n	402b38 <_fwalk_reent+0x36>
  402b1e:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
  402b22:	b13b      	cbz	r3, 402b34 <_fwalk_reent+0x32>
  402b24:	f9b5 000e 	ldrsh.w	r0, [r5, #14]
  402b28:	1c43      	adds	r3, r0, #1
  402b2a:	d003      	beq.n	402b34 <_fwalk_reent+0x32>
  402b2c:	4640      	mov	r0, r8
  402b2e:	4629      	mov	r1, r5
  402b30:	47c8      	blx	r9
  402b32:	4306      	orrs	r6, r0
  402b34:	3568      	adds	r5, #104	; 0x68
  402b36:	e7f0      	b.n	402b1a <_fwalk_reent+0x18>
  402b38:	6824      	ldr	r4, [r4, #0]
  402b3a:	e7eb      	b.n	402b14 <_fwalk_reent+0x12>
  402b3c:	f7ff fea5 	bl	40288a <__sfp_lock_release>
  402b40:	4630      	mov	r0, r6
  402b42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

00402b48 <malloc>:
  402b48:	4b02      	ldr	r3, [pc, #8]	; (402b54 <malloc+0xc>)
  402b4a:	4601      	mov	r1, r0
  402b4c:	6818      	ldr	r0, [r3, #0]
  402b4e:	f000 b80b 	b.w	402b68 <_malloc_r>
  402b52:	bf00      	nop
  402b54:	20000010 	.word	0x20000010

00402b58 <free>:
  402b58:	4b02      	ldr	r3, [pc, #8]	; (402b64 <free+0xc>)
  402b5a:	4601      	mov	r1, r0
  402b5c:	6818      	ldr	r0, [r3, #0]
  402b5e:	f7ff bef9 	b.w	402954 <_free_r>
  402b62:	bf00      	nop
  402b64:	20000010 	.word	0x20000010

00402b68 <_malloc_r>:
  402b68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402b6c:	f101 040b 	add.w	r4, r1, #11
  402b70:	2c16      	cmp	r4, #22
  402b72:	4606      	mov	r6, r0
  402b74:	d903      	bls.n	402b7e <_malloc_r+0x16>
  402b76:	f034 0407 	bics.w	r4, r4, #7
  402b7a:	d501      	bpl.n	402b80 <_malloc_r+0x18>
  402b7c:	e002      	b.n	402b84 <_malloc_r+0x1c>
  402b7e:	2410      	movs	r4, #16
  402b80:	428c      	cmp	r4, r1
  402b82:	d202      	bcs.n	402b8a <_malloc_r+0x22>
  402b84:	250c      	movs	r5, #12
  402b86:	6035      	str	r5, [r6, #0]
  402b88:	e1d9      	b.n	402f3e <_malloc_r+0x3d6>
  402b8a:	4630      	mov	r0, r6
  402b8c:	f000 f9ee 	bl	402f6c <__malloc_lock>
  402b90:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
  402b94:	d214      	bcs.n	402bc0 <_malloc_r+0x58>
  402b96:	4da0      	ldr	r5, [pc, #640]	; (402e18 <_malloc_r+0x2b0>)
  402b98:	08e1      	lsrs	r1, r4, #3
  402b9a:	eb05 00c1 	add.w	r0, r5, r1, lsl #3
  402b9e:	68c5      	ldr	r5, [r0, #12]
  402ba0:	4285      	cmp	r5, r0
  402ba2:	d105      	bne.n	402bb0 <_malloc_r+0x48>
  402ba4:	f105 0308 	add.w	r3, r5, #8
  402ba8:	696d      	ldr	r5, [r5, #20]
  402baa:	1c8a      	adds	r2, r1, #2
  402bac:	429d      	cmp	r5, r3
  402bae:	d044      	beq.n	402c3a <_malloc_r+0xd2>
  402bb0:	68e8      	ldr	r0, [r5, #12]
  402bb2:	68a9      	ldr	r1, [r5, #8]
  402bb4:	686a      	ldr	r2, [r5, #4]
  402bb6:	60c8      	str	r0, [r1, #12]
  402bb8:	f022 0303 	bic.w	r3, r2, #3
  402bbc:	6081      	str	r1, [r0, #8]
  402bbe:	e059      	b.n	402c74 <_malloc_r+0x10c>
  402bc0:	0a62      	lsrs	r2, r4, #9
  402bc2:	d101      	bne.n	402bc8 <_malloc_r+0x60>
  402bc4:	08e2      	lsrs	r2, r4, #3
  402bc6:	e01b      	b.n	402c00 <_malloc_r+0x98>
  402bc8:	2a04      	cmp	r2, #4
  402bca:	d802      	bhi.n	402bd2 <_malloc_r+0x6a>
  402bcc:	09a2      	lsrs	r2, r4, #6
  402bce:	3238      	adds	r2, #56	; 0x38
  402bd0:	e016      	b.n	402c00 <_malloc_r+0x98>
  402bd2:	2a14      	cmp	r2, #20
  402bd4:	d801      	bhi.n	402bda <_malloc_r+0x72>
  402bd6:	325b      	adds	r2, #91	; 0x5b
  402bd8:	e012      	b.n	402c00 <_malloc_r+0x98>
  402bda:	2a54      	cmp	r2, #84	; 0x54
  402bdc:	d802      	bhi.n	402be4 <_malloc_r+0x7c>
  402bde:	0b22      	lsrs	r2, r4, #12
  402be0:	326e      	adds	r2, #110	; 0x6e
  402be2:	e00d      	b.n	402c00 <_malloc_r+0x98>
  402be4:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  402be8:	d802      	bhi.n	402bf0 <_malloc_r+0x88>
  402bea:	0be2      	lsrs	r2, r4, #15
  402bec:	3277      	adds	r2, #119	; 0x77
  402bee:	e007      	b.n	402c00 <_malloc_r+0x98>
  402bf0:	f240 5354 	movw	r3, #1364	; 0x554
  402bf4:	429a      	cmp	r2, r3
  402bf6:	d802      	bhi.n	402bfe <_malloc_r+0x96>
  402bf8:	0ca2      	lsrs	r2, r4, #18
  402bfa:	327c      	adds	r2, #124	; 0x7c
  402bfc:	e000      	b.n	402c00 <_malloc_r+0x98>
  402bfe:	227e      	movs	r2, #126	; 0x7e
  402c00:	4885      	ldr	r0, [pc, #532]	; (402e18 <_malloc_r+0x2b0>)
  402c02:	eb00 03c2 	add.w	r3, r0, r2, lsl #3
  402c06:	68dd      	ldr	r5, [r3, #12]
  402c08:	429d      	cmp	r5, r3
  402c0a:	d015      	beq.n	402c38 <_malloc_r+0xd0>
  402c0c:	6869      	ldr	r1, [r5, #4]
  402c0e:	f021 0103 	bic.w	r1, r1, #3
  402c12:	1b08      	subs	r0, r1, r4
  402c14:	280f      	cmp	r0, #15
  402c16:	dd01      	ble.n	402c1c <_malloc_r+0xb4>
  402c18:	3a01      	subs	r2, #1
  402c1a:	e00d      	b.n	402c38 <_malloc_r+0xd0>
  402c1c:	2800      	cmp	r0, #0
  402c1e:	db09      	blt.n	402c34 <_malloc_r+0xcc>
  402c20:	68eb      	ldr	r3, [r5, #12]
  402c22:	68aa      	ldr	r2, [r5, #8]
  402c24:	60d3      	str	r3, [r2, #12]
  402c26:	609a      	str	r2, [r3, #8]
  402c28:	186b      	adds	r3, r5, r1
  402c2a:	685a      	ldr	r2, [r3, #4]
  402c2c:	f042 0001 	orr.w	r0, r2, #1
  402c30:	6058      	str	r0, [r3, #4]
  402c32:	e190      	b.n	402f56 <_malloc_r+0x3ee>
  402c34:	68ed      	ldr	r5, [r5, #12]
  402c36:	e7e7      	b.n	402c08 <_malloc_r+0xa0>
  402c38:	3201      	adds	r2, #1
  402c3a:	4977      	ldr	r1, [pc, #476]	; (402e18 <_malloc_r+0x2b0>)
  402c3c:	690d      	ldr	r5, [r1, #16]
  402c3e:	f101 0708 	add.w	r7, r1, #8
  402c42:	42bd      	cmp	r5, r7
  402c44:	d068      	beq.n	402d18 <_malloc_r+0x1b0>
  402c46:	6868      	ldr	r0, [r5, #4]
  402c48:	f020 0303 	bic.w	r3, r0, #3
  402c4c:	1b18      	subs	r0, r3, r4
  402c4e:	280f      	cmp	r0, #15
  402c50:	dd0c      	ble.n	402c6c <_malloc_r+0x104>
  402c52:	192b      	adds	r3, r5, r4
  402c54:	614b      	str	r3, [r1, #20]
  402c56:	610b      	str	r3, [r1, #16]
  402c58:	f044 0401 	orr.w	r4, r4, #1
  402c5c:	f040 0101 	orr.w	r1, r0, #1
  402c60:	606c      	str	r4, [r5, #4]
  402c62:	60df      	str	r7, [r3, #12]
  402c64:	609f      	str	r7, [r3, #8]
  402c66:	6059      	str	r1, [r3, #4]
  402c68:	5018      	str	r0, [r3, r0]
  402c6a:	e174      	b.n	402f56 <_malloc_r+0x3ee>
  402c6c:	2800      	cmp	r0, #0
  402c6e:	614f      	str	r7, [r1, #20]
  402c70:	610f      	str	r7, [r1, #16]
  402c72:	db01      	blt.n	402c78 <_malloc_r+0x110>
  402c74:	18eb      	adds	r3, r5, r3
  402c76:	e7d8      	b.n	402c2a <_malloc_r+0xc2>
  402c78:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  402c7c:	d20f      	bcs.n	402c9e <_malloc_r+0x136>
  402c7e:	08db      	lsrs	r3, r3, #3
  402c80:	1098      	asrs	r0, r3, #2
  402c82:	2701      	movs	r7, #1
  402c84:	fa07 f700 	lsl.w	r7, r7, r0
  402c88:	6848      	ldr	r0, [r1, #4]
  402c8a:	4307      	orrs	r7, r0
  402c8c:	604f      	str	r7, [r1, #4]
  402c8e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
  402c92:	60e9      	str	r1, [r5, #12]
  402c94:	688b      	ldr	r3, [r1, #8]
  402c96:	60ab      	str	r3, [r5, #8]
  402c98:	60dd      	str	r5, [r3, #12]
  402c9a:	608d      	str	r5, [r1, #8]
  402c9c:	e03c      	b.n	402d18 <_malloc_r+0x1b0>
  402c9e:	0a58      	lsrs	r0, r3, #9
  402ca0:	2804      	cmp	r0, #4
  402ca2:	d802      	bhi.n	402caa <_malloc_r+0x142>
  402ca4:	0998      	lsrs	r0, r3, #6
  402ca6:	3038      	adds	r0, #56	; 0x38
  402ca8:	e016      	b.n	402cd8 <_malloc_r+0x170>
  402caa:	2814      	cmp	r0, #20
  402cac:	d801      	bhi.n	402cb2 <_malloc_r+0x14a>
  402cae:	305b      	adds	r0, #91	; 0x5b
  402cb0:	e012      	b.n	402cd8 <_malloc_r+0x170>
  402cb2:	2854      	cmp	r0, #84	; 0x54
  402cb4:	d802      	bhi.n	402cbc <_malloc_r+0x154>
  402cb6:	0b18      	lsrs	r0, r3, #12
  402cb8:	306e      	adds	r0, #110	; 0x6e
  402cba:	e00d      	b.n	402cd8 <_malloc_r+0x170>
  402cbc:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
  402cc0:	d802      	bhi.n	402cc8 <_malloc_r+0x160>
  402cc2:	0bd8      	lsrs	r0, r3, #15
  402cc4:	3077      	adds	r0, #119	; 0x77
  402cc6:	e007      	b.n	402cd8 <_malloc_r+0x170>
  402cc8:	f240 5754 	movw	r7, #1364	; 0x554
  402ccc:	42b8      	cmp	r0, r7
  402cce:	d802      	bhi.n	402cd6 <_malloc_r+0x16e>
  402cd0:	0c98      	lsrs	r0, r3, #18
  402cd2:	307c      	adds	r0, #124	; 0x7c
  402cd4:	e000      	b.n	402cd8 <_malloc_r+0x170>
  402cd6:	207e      	movs	r0, #126	; 0x7e
  402cd8:	f8df e13c 	ldr.w	lr, [pc, #316]	; 402e18 <_malloc_r+0x2b0>
  402cdc:	eb0e 07c0 	add.w	r7, lr, r0, lsl #3
  402ce0:	68b9      	ldr	r1, [r7, #8]
  402ce2:	42b9      	cmp	r1, r7
  402ce4:	d10e      	bne.n	402d04 <_malloc_r+0x19c>
  402ce6:	1087      	asrs	r7, r0, #2
  402ce8:	2301      	movs	r3, #1
  402cea:	fa03 f007 	lsl.w	r0, r3, r7
  402cee:	f8de 7004 	ldr.w	r7, [lr, #4]
  402cf2:	ea40 0307 	orr.w	r3, r0, r7
  402cf6:	f8ce 3004 	str.w	r3, [lr, #4]
  402cfa:	4608      	mov	r0, r1
  402cfc:	e008      	b.n	402d10 <_malloc_r+0x1a8>
  402cfe:	6889      	ldr	r1, [r1, #8]
  402d00:	42b9      	cmp	r1, r7
  402d02:	d004      	beq.n	402d0e <_malloc_r+0x1a6>
  402d04:	6848      	ldr	r0, [r1, #4]
  402d06:	f020 0003 	bic.w	r0, r0, #3
  402d0a:	4283      	cmp	r3, r0
  402d0c:	d3f7      	bcc.n	402cfe <_malloc_r+0x196>
  402d0e:	68c8      	ldr	r0, [r1, #12]
  402d10:	60e8      	str	r0, [r5, #12]
  402d12:	60a9      	str	r1, [r5, #8]
  402d14:	60cd      	str	r5, [r1, #12]
  402d16:	6085      	str	r5, [r0, #8]
  402d18:	4f3f      	ldr	r7, [pc, #252]	; (402e18 <_malloc_r+0x2b0>)
  402d1a:	1095      	asrs	r5, r2, #2
  402d1c:	2001      	movs	r0, #1
  402d1e:	6879      	ldr	r1, [r7, #4]
  402d20:	fa00 f305 	lsl.w	r3, r0, r5
  402d24:	428b      	cmp	r3, r1
  402d26:	d85d      	bhi.n	402de4 <_malloc_r+0x27c>
  402d28:	420b      	tst	r3, r1
  402d2a:	d105      	bne.n	402d38 <_malloc_r+0x1d0>
  402d2c:	f022 0203 	bic.w	r2, r2, #3
  402d30:	005b      	lsls	r3, r3, #1
  402d32:	3204      	adds	r2, #4
  402d34:	420b      	tst	r3, r1
  402d36:	d0fb      	beq.n	402d30 <_malloc_r+0x1c8>
  402d38:	4d37      	ldr	r5, [pc, #220]	; (402e18 <_malloc_r+0x2b0>)
  402d3a:	eb05 0ec2 	add.w	lr, r5, r2, lsl #3
  402d3e:	4677      	mov	r7, lr
  402d40:	4610      	mov	r0, r2
  402d42:	68fd      	ldr	r5, [r7, #12]
  402d44:	42bd      	cmp	r5, r7
  402d46:	d02d      	beq.n	402da4 <_malloc_r+0x23c>
  402d48:	6869      	ldr	r1, [r5, #4]
  402d4a:	f021 0c03 	bic.w	ip, r1, #3
  402d4e:	ebc4 010c 	rsb	r1, r4, ip
  402d52:	290f      	cmp	r1, #15
  402d54:	dd13      	ble.n	402d7e <_malloc_r+0x216>
  402d56:	192b      	adds	r3, r5, r4
  402d58:	f044 0401 	orr.w	r4, r4, #1
  402d5c:	68ea      	ldr	r2, [r5, #12]
  402d5e:	606c      	str	r4, [r5, #4]
  402d60:	f855 0f08 	ldr.w	r0, [r5, #8]!
  402d64:	5059      	str	r1, [r3, r1]
  402d66:	60c2      	str	r2, [r0, #12]
  402d68:	6090      	str	r0, [r2, #8]
  402d6a:	4a2b      	ldr	r2, [pc, #172]	; (402e18 <_malloc_r+0x2b0>)
  402d6c:	f041 0001 	orr.w	r0, r1, #1
  402d70:	6153      	str	r3, [r2, #20]
  402d72:	6113      	str	r3, [r2, #16]
  402d74:	3208      	adds	r2, #8
  402d76:	60da      	str	r2, [r3, #12]
  402d78:	609a      	str	r2, [r3, #8]
  402d7a:	6058      	str	r0, [r3, #4]
  402d7c:	e00c      	b.n	402d98 <_malloc_r+0x230>
  402d7e:	2900      	cmp	r1, #0
  402d80:	db0e      	blt.n	402da0 <_malloc_r+0x238>
  402d82:	eb05 000c 	add.w	r0, r5, ip
  402d86:	68e9      	ldr	r1, [r5, #12]
  402d88:	6842      	ldr	r2, [r0, #4]
  402d8a:	f042 0301 	orr.w	r3, r2, #1
  402d8e:	6043      	str	r3, [r0, #4]
  402d90:	f855 0f08 	ldr.w	r0, [r5, #8]!
  402d94:	60c1      	str	r1, [r0, #12]
  402d96:	6088      	str	r0, [r1, #8]
  402d98:	4630      	mov	r0, r6
  402d9a:	f000 f8e8 	bl	402f6e <__malloc_unlock>
  402d9e:	e0de      	b.n	402f5e <_malloc_r+0x3f6>
  402da0:	68ed      	ldr	r5, [r5, #12]
  402da2:	e7cf      	b.n	402d44 <_malloc_r+0x1dc>
  402da4:	3001      	adds	r0, #1
  402da6:	0781      	lsls	r1, r0, #30
  402da8:	f105 0708 	add.w	r7, r5, #8
  402dac:	d1c9      	bne.n	402d42 <_malloc_r+0x1da>
  402dae:	4671      	mov	r1, lr
  402db0:	0795      	lsls	r5, r2, #30
  402db2:	d105      	bne.n	402dc0 <_malloc_r+0x258>
  402db4:	4a18      	ldr	r2, [pc, #96]	; (402e18 <_malloc_r+0x2b0>)
  402db6:	6855      	ldr	r5, [r2, #4]
  402db8:	ea25 0503 	bic.w	r5, r5, r3
  402dbc:	6055      	str	r5, [r2, #4]
  402dbe:	e005      	b.n	402dcc <_malloc_r+0x264>
  402dc0:	f1a1 0708 	sub.w	r7, r1, #8
  402dc4:	6809      	ldr	r1, [r1, #0]
  402dc6:	3a01      	subs	r2, #1
  402dc8:	42b9      	cmp	r1, r7
  402dca:	d0f1      	beq.n	402db0 <_malloc_r+0x248>
  402dcc:	4f12      	ldr	r7, [pc, #72]	; (402e18 <_malloc_r+0x2b0>)
  402dce:	687f      	ldr	r7, [r7, #4]
  402dd0:	005b      	lsls	r3, r3, #1
  402dd2:	42bb      	cmp	r3, r7
  402dd4:	d806      	bhi.n	402de4 <_malloc_r+0x27c>
  402dd6:	b12b      	cbz	r3, 402de4 <_malloc_r+0x27c>
  402dd8:	4602      	mov	r2, r0
  402dda:	423b      	tst	r3, r7
  402ddc:	d1ac      	bne.n	402d38 <_malloc_r+0x1d0>
  402dde:	3204      	adds	r2, #4
  402de0:	005b      	lsls	r3, r3, #1
  402de2:	e7fa      	b.n	402dda <_malloc_r+0x272>
  402de4:	4b0c      	ldr	r3, [pc, #48]	; (402e18 <_malloc_r+0x2b0>)
  402de6:	689f      	ldr	r7, [r3, #8]
  402de8:	6878      	ldr	r0, [r7, #4]
  402dea:	f020 0903 	bic.w	r9, r0, #3
  402dee:	45a1      	cmp	r9, r4
  402df0:	4619      	mov	r1, r3
  402df2:	d304      	bcc.n	402dfe <_malloc_r+0x296>
  402df4:	ebc4 0009 	rsb	r0, r4, r9
  402df8:	280f      	cmp	r0, #15
  402dfa:	f300 80a2 	bgt.w	402f42 <_malloc_r+0x3da>
  402dfe:	4a07      	ldr	r2, [pc, #28]	; (402e1c <_malloc_r+0x2b4>)
  402e00:	f8d1 3408 	ldr.w	r3, [r1, #1032]	; 0x408
  402e04:	6815      	ldr	r5, [r2, #0]
  402e06:	3301      	adds	r3, #1
  402e08:	eb07 0a09 	add.w	sl, r7, r9
  402e0c:	eb04 0805 	add.w	r8, r4, r5
  402e10:	d106      	bne.n	402e20 <_malloc_r+0x2b8>
  402e12:	f108 0810 	add.w	r8, r8, #16
  402e16:	e00b      	b.n	402e30 <_malloc_r+0x2c8>
  402e18:	20000440 	.word	0x20000440
  402e1c:	20000ca8 	.word	0x20000ca8
  402e20:	f508 5080 	add.w	r0, r8, #4096	; 0x1000
  402e24:	f100 010f 	add.w	r1, r0, #15
  402e28:	f421 627f 	bic.w	r2, r1, #4080	; 0xff0
  402e2c:	f022 080f 	bic.w	r8, r2, #15
  402e30:	4630      	mov	r0, r6
  402e32:	4641      	mov	r1, r8
  402e34:	f000 f89c 	bl	402f70 <_sbrk_r>
  402e38:	1c42      	adds	r2, r0, #1
  402e3a:	4605      	mov	r5, r0
  402e3c:	d071      	beq.n	402f22 <_malloc_r+0x3ba>
  402e3e:	4550      	cmp	r0, sl
  402e40:	d202      	bcs.n	402e48 <_malloc_r+0x2e0>
  402e42:	4b48      	ldr	r3, [pc, #288]	; (402f64 <_malloc_r+0x3fc>)
  402e44:	429f      	cmp	r7, r3
  402e46:	d16c      	bne.n	402f22 <_malloc_r+0x3ba>
  402e48:	4847      	ldr	r0, [pc, #284]	; (402f68 <_malloc_r+0x400>)
  402e4a:	4a46      	ldr	r2, [pc, #280]	; (402f64 <_malloc_r+0x3fc>)
  402e4c:	6841      	ldr	r1, [r0, #4]
  402e4e:	4555      	cmp	r5, sl
  402e50:	eb08 0301 	add.w	r3, r8, r1
  402e54:	6043      	str	r3, [r0, #4]
  402e56:	d107      	bne.n	402e68 <_malloc_r+0x300>
  402e58:	0529      	lsls	r1, r5, #20
  402e5a:	d105      	bne.n	402e68 <_malloc_r+0x300>
  402e5c:	6895      	ldr	r5, [r2, #8]
  402e5e:	44c8      	add	r8, r9
  402e60:	f048 0001 	orr.w	r0, r8, #1
  402e64:	6068      	str	r0, [r5, #4]
  402e66:	e051      	b.n	402f0c <_malloc_r+0x3a4>
  402e68:	f8d2 0408 	ldr.w	r0, [r2, #1032]	; 0x408
  402e6c:	1c42      	adds	r2, r0, #1
  402e6e:	d103      	bne.n	402e78 <_malloc_r+0x310>
  402e70:	4a3c      	ldr	r2, [pc, #240]	; (402f64 <_malloc_r+0x3fc>)
  402e72:	f8c2 5408 	str.w	r5, [r2, #1032]	; 0x408
  402e76:	e005      	b.n	402e84 <_malloc_r+0x31c>
  402e78:	ebca 0a05 	rsb	sl, sl, r5
  402e7c:	eb03 010a 	add.w	r1, r3, sl
  402e80:	4b39      	ldr	r3, [pc, #228]	; (402f68 <_malloc_r+0x400>)
  402e82:	6059      	str	r1, [r3, #4]
  402e84:	f015 0007 	ands.w	r0, r5, #7
  402e88:	bf1c      	itt	ne
  402e8a:	f1c0 0008 	rsbne	r0, r0, #8
  402e8e:	182d      	addne	r5, r5, r0
  402e90:	eb05 0c08 	add.w	ip, r5, r8
  402e94:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
  402e98:	ea4f 5e0c 	mov.w	lr, ip, lsl #20
  402e9c:	eba1 581e 	sub.w	r8, r1, lr, lsr #20
  402ea0:	4641      	mov	r1, r8
  402ea2:	4630      	mov	r0, r6
  402ea4:	f000 f864 	bl	402f70 <_sbrk_r>
  402ea8:	4a2f      	ldr	r2, [pc, #188]	; (402f68 <_malloc_r+0x400>)
  402eaa:	1c43      	adds	r3, r0, #1
  402eac:	6853      	ldr	r3, [r2, #4]
  402eae:	bf08      	it	eq
  402eb0:	f04f 0800 	moveq.w	r8, #0
  402eb4:	eb08 0103 	add.w	r1, r8, r3
  402eb8:	bf08      	it	eq
  402eba:	4628      	moveq	r0, r5
  402ebc:	6051      	str	r1, [r2, #4]
  402ebe:	1b40      	subs	r0, r0, r5
  402ec0:	4a28      	ldr	r2, [pc, #160]	; (402f64 <_malloc_r+0x3fc>)
  402ec2:	eb00 0308 	add.w	r3, r0, r8
  402ec6:	f043 0101 	orr.w	r1, r3, #1
  402eca:	4297      	cmp	r7, r2
  402ecc:	6095      	str	r5, [r2, #8]
  402ece:	6069      	str	r1, [r5, #4]
  402ed0:	d01c      	beq.n	402f0c <_malloc_r+0x3a4>
  402ed2:	f1b9 0f0f 	cmp.w	r9, #15
  402ed6:	d802      	bhi.n	402ede <_malloc_r+0x376>
  402ed8:	2201      	movs	r2, #1
  402eda:	606a      	str	r2, [r5, #4]
  402edc:	e021      	b.n	402f22 <_malloc_r+0x3ba>
  402ede:	687d      	ldr	r5, [r7, #4]
  402ee0:	f1a9 090c 	sub.w	r9, r9, #12
  402ee4:	f029 0907 	bic.w	r9, r9, #7
  402ee8:	eb07 0309 	add.w	r3, r7, r9
  402eec:	f005 0201 	and.w	r2, r5, #1
  402ef0:	2105      	movs	r1, #5
  402ef2:	ea49 0002 	orr.w	r0, r9, r2
  402ef6:	f1b9 0f0f 	cmp.w	r9, #15
  402efa:	6078      	str	r0, [r7, #4]
  402efc:	6059      	str	r1, [r3, #4]
  402efe:	6099      	str	r1, [r3, #8]
  402f00:	d904      	bls.n	402f0c <_malloc_r+0x3a4>
  402f02:	4630      	mov	r0, r6
  402f04:	f107 0108 	add.w	r1, r7, #8
  402f08:	f7ff fd24 	bl	402954 <_free_r>
  402f0c:	4a16      	ldr	r2, [pc, #88]	; (402f68 <_malloc_r+0x400>)
  402f0e:	6853      	ldr	r3, [r2, #4]
  402f10:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  402f12:	6b15      	ldr	r5, [r2, #48]	; 0x30
  402f14:	428b      	cmp	r3, r1
  402f16:	bf88      	it	hi
  402f18:	62d3      	strhi	r3, [r2, #44]	; 0x2c
  402f1a:	42ab      	cmp	r3, r5
  402f1c:	bf84      	itt	hi
  402f1e:	4d12      	ldrhi	r5, [pc, #72]	; (402f68 <_malloc_r+0x400>)
  402f20:	632b      	strhi	r3, [r5, #48]	; 0x30
  402f22:	4810      	ldr	r0, [pc, #64]	; (402f64 <_malloc_r+0x3fc>)
  402f24:	6882      	ldr	r2, [r0, #8]
  402f26:	6853      	ldr	r3, [r2, #4]
  402f28:	f023 0103 	bic.w	r1, r3, #3
  402f2c:	42a1      	cmp	r1, r4
  402f2e:	ebc4 0001 	rsb	r0, r4, r1
  402f32:	d301      	bcc.n	402f38 <_malloc_r+0x3d0>
  402f34:	280f      	cmp	r0, #15
  402f36:	dc04      	bgt.n	402f42 <_malloc_r+0x3da>
  402f38:	4630      	mov	r0, r6
  402f3a:	f000 f818 	bl	402f6e <__malloc_unlock>
  402f3e:	2500      	movs	r5, #0
  402f40:	e00d      	b.n	402f5e <_malloc_r+0x3f6>
  402f42:	4a08      	ldr	r2, [pc, #32]	; (402f64 <_malloc_r+0x3fc>)
  402f44:	6895      	ldr	r5, [r2, #8]
  402f46:	f044 0301 	orr.w	r3, r4, #1
  402f4a:	192c      	adds	r4, r5, r4
  402f4c:	f040 0101 	orr.w	r1, r0, #1
  402f50:	606b      	str	r3, [r5, #4]
  402f52:	6094      	str	r4, [r2, #8]
  402f54:	6061      	str	r1, [r4, #4]
  402f56:	4630      	mov	r0, r6
  402f58:	f000 f809 	bl	402f6e <__malloc_unlock>
  402f5c:	3508      	adds	r5, #8
  402f5e:	4628      	mov	r0, r5
  402f60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402f64:	20000440 	.word	0x20000440
  402f68:	20000ca8 	.word	0x20000ca8

00402f6c <__malloc_lock>:
  402f6c:	4770      	bx	lr

00402f6e <__malloc_unlock>:
  402f6e:	4770      	bx	lr

00402f70 <_sbrk_r>:
  402f70:	b538      	push	{r3, r4, r5, lr}
  402f72:	4c06      	ldr	r4, [pc, #24]	; (402f8c <_sbrk_r+0x1c>)
  402f74:	2300      	movs	r3, #0
  402f76:	4605      	mov	r5, r0
  402f78:	4608      	mov	r0, r1
  402f7a:	6023      	str	r3, [r4, #0]
  402f7c:	f7ff f81e 	bl	401fbc <_sbrk>
  402f80:	1c43      	adds	r3, r0, #1
  402f82:	d102      	bne.n	402f8a <_sbrk_r+0x1a>
  402f84:	6821      	ldr	r1, [r4, #0]
  402f86:	b101      	cbz	r1, 402f8a <_sbrk_r+0x1a>
  402f88:	6029      	str	r1, [r5, #0]
  402f8a:	bd38      	pop	{r3, r4, r5, pc}
  402f8c:	20000cfc 	.word	0x20000cfc

00402f90 <__sread>:
  402f90:	b510      	push	{r4, lr}
  402f92:	460c      	mov	r4, r1
  402f94:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402f98:	f000 f8c0 	bl	40311c <_read_r>
  402f9c:	2800      	cmp	r0, #0
  402f9e:	db03      	blt.n	402fa8 <__sread+0x18>
  402fa0:	6d22      	ldr	r2, [r4, #80]	; 0x50
  402fa2:	1813      	adds	r3, r2, r0
  402fa4:	6523      	str	r3, [r4, #80]	; 0x50
  402fa6:	bd10      	pop	{r4, pc}
  402fa8:	89a3      	ldrh	r3, [r4, #12]
  402faa:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
  402fae:	81a1      	strh	r1, [r4, #12]
  402fb0:	bd10      	pop	{r4, pc}

00402fb2 <__seofread>:
  402fb2:	2000      	movs	r0, #0
  402fb4:	4770      	bx	lr

00402fb6 <__swrite>:
  402fb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402fba:	461d      	mov	r5, r3
  402fbc:	898b      	ldrh	r3, [r1, #12]
  402fbe:	460c      	mov	r4, r1
  402fc0:	f403 7180 	and.w	r1, r3, #256	; 0x100
  402fc4:	4616      	mov	r6, r2
  402fc6:	b20a      	sxth	r2, r1
  402fc8:	4607      	mov	r7, r0
  402fca:	b12a      	cbz	r2, 402fd8 <__swrite+0x22>
  402fcc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  402fd0:	2200      	movs	r2, #0
  402fd2:	2302      	movs	r3, #2
  402fd4:	f000 f890 	bl	4030f8 <_lseek_r>
  402fd8:	89a0      	ldrh	r0, [r4, #12]
  402fda:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  402fde:	f420 5380 	bic.w	r3, r0, #4096	; 0x1000
  402fe2:	81a3      	strh	r3, [r4, #12]
  402fe4:	4638      	mov	r0, r7
  402fe6:	4632      	mov	r2, r6
  402fe8:	462b      	mov	r3, r5
  402fea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  402fee:	f000 b817 	b.w	403020 <_write_r>

00402ff2 <__sseek>:
  402ff2:	b510      	push	{r4, lr}
  402ff4:	460c      	mov	r4, r1
  402ff6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402ffa:	f000 f87d 	bl	4030f8 <_lseek_r>
  402ffe:	1c43      	adds	r3, r0, #1
  403000:	89a3      	ldrh	r3, [r4, #12]
  403002:	d103      	bne.n	40300c <__sseek+0x1a>
  403004:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
  403008:	81a2      	strh	r2, [r4, #12]
  40300a:	bd10      	pop	{r4, pc}
  40300c:	f443 5180 	orr.w	r1, r3, #4096	; 0x1000
  403010:	81a1      	strh	r1, [r4, #12]
  403012:	6520      	str	r0, [r4, #80]	; 0x50
  403014:	bd10      	pop	{r4, pc}

00403016 <__sclose>:
  403016:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40301a:	f000 b813 	b.w	403044 <_close_r>
	...

00403020 <_write_r>:
  403020:	b538      	push	{r3, r4, r5, lr}
  403022:	4c07      	ldr	r4, [pc, #28]	; (403040 <_write_r+0x20>)
  403024:	4605      	mov	r5, r0
  403026:	2000      	movs	r0, #0
  403028:	6020      	str	r0, [r4, #0]
  40302a:	4608      	mov	r0, r1
  40302c:	4611      	mov	r1, r2
  40302e:	461a      	mov	r2, r3
  403030:	f7fd f924 	bl	40027c <_write>
  403034:	1c43      	adds	r3, r0, #1
  403036:	d102      	bne.n	40303e <_write_r+0x1e>
  403038:	6823      	ldr	r3, [r4, #0]
  40303a:	b103      	cbz	r3, 40303e <_write_r+0x1e>
  40303c:	602b      	str	r3, [r5, #0]
  40303e:	bd38      	pop	{r3, r4, r5, pc}
  403040:	20000cfc 	.word	0x20000cfc

00403044 <_close_r>:
  403044:	b538      	push	{r3, r4, r5, lr}
  403046:	4c06      	ldr	r4, [pc, #24]	; (403060 <_close_r+0x1c>)
  403048:	2300      	movs	r3, #0
  40304a:	4605      	mov	r5, r0
  40304c:	4608      	mov	r0, r1
  40304e:	6023      	str	r3, [r4, #0]
  403050:	f7fe ffda 	bl	402008 <_close>
  403054:	1c43      	adds	r3, r0, #1
  403056:	d102      	bne.n	40305e <_close_r+0x1a>
  403058:	6821      	ldr	r1, [r4, #0]
  40305a:	b101      	cbz	r1, 40305e <_close_r+0x1a>
  40305c:	6029      	str	r1, [r5, #0]
  40305e:	bd38      	pop	{r3, r4, r5, pc}
  403060:	20000cfc 	.word	0x20000cfc

00403064 <_fclose_r>:
  403064:	b570      	push	{r4, r5, r6, lr}
  403066:	4605      	mov	r5, r0
  403068:	460c      	mov	r4, r1
  40306a:	2900      	cmp	r1, #0
  40306c:	d039      	beq.n	4030e2 <_fclose_r+0x7e>
  40306e:	f7ff fc0b 	bl	402888 <__sfp_lock_acquire>
  403072:	b125      	cbz	r5, 40307e <_fclose_r+0x1a>
  403074:	6bab      	ldr	r3, [r5, #56]	; 0x38
  403076:	b913      	cbnz	r3, 40307e <_fclose_r+0x1a>
  403078:	4628      	mov	r0, r5
  40307a:	f7ff fba1 	bl	4027c0 <__sinit>
  40307e:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
  403082:	b35e      	cbz	r6, 4030dc <_fclose_r+0x78>
  403084:	4628      	mov	r0, r5
  403086:	4621      	mov	r1, r4
  403088:	f7ff faa6 	bl	4025d8 <_fflush_r>
  40308c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  40308e:	4606      	mov	r6, r0
  403090:	b13a      	cbz	r2, 4030a2 <_fclose_r+0x3e>
  403092:	4628      	mov	r0, r5
  403094:	69e1      	ldr	r1, [r4, #28]
  403096:	4790      	blx	r2
  403098:	ea36 0620 	bics.w	r6, r6, r0, asr #32
  40309c:	bf28      	it	cs
  40309e:	f04f 36ff 	movcs.w	r6, #4294967295
  4030a2:	89a0      	ldrh	r0, [r4, #12]
  4030a4:	f000 0180 	and.w	r1, r0, #128	; 0x80
  4030a8:	b20b      	sxth	r3, r1
  4030aa:	b11b      	cbz	r3, 4030b4 <_fclose_r+0x50>
  4030ac:	4628      	mov	r0, r5
  4030ae:	6921      	ldr	r1, [r4, #16]
  4030b0:	f7ff fc50 	bl	402954 <_free_r>
  4030b4:	6b21      	ldr	r1, [r4, #48]	; 0x30
  4030b6:	b141      	cbz	r1, 4030ca <_fclose_r+0x66>
  4030b8:	f104 0240 	add.w	r2, r4, #64	; 0x40
  4030bc:	4291      	cmp	r1, r2
  4030be:	d002      	beq.n	4030c6 <_fclose_r+0x62>
  4030c0:	4628      	mov	r0, r5
  4030c2:	f7ff fc47 	bl	402954 <_free_r>
  4030c6:	2000      	movs	r0, #0
  4030c8:	6320      	str	r0, [r4, #48]	; 0x30
  4030ca:	6c61      	ldr	r1, [r4, #68]	; 0x44
  4030cc:	b121      	cbz	r1, 4030d8 <_fclose_r+0x74>
  4030ce:	4628      	mov	r0, r5
  4030d0:	f7ff fc40 	bl	402954 <_free_r>
  4030d4:	2100      	movs	r1, #0
  4030d6:	6461      	str	r1, [r4, #68]	; 0x44
  4030d8:	2300      	movs	r3, #0
  4030da:	81a3      	strh	r3, [r4, #12]
  4030dc:	f7ff fbd5 	bl	40288a <__sfp_lock_release>
  4030e0:	e000      	b.n	4030e4 <_fclose_r+0x80>
  4030e2:	460e      	mov	r6, r1
  4030e4:	4630      	mov	r0, r6
  4030e6:	bd70      	pop	{r4, r5, r6, pc}

004030e8 <fclose>:
  4030e8:	4b02      	ldr	r3, [pc, #8]	; (4030f4 <fclose+0xc>)
  4030ea:	4601      	mov	r1, r0
  4030ec:	6818      	ldr	r0, [r3, #0]
  4030ee:	f7ff bfb9 	b.w	403064 <_fclose_r>
  4030f2:	bf00      	nop
  4030f4:	20000010 	.word	0x20000010

004030f8 <_lseek_r>:
  4030f8:	b538      	push	{r3, r4, r5, lr}
  4030fa:	4c07      	ldr	r4, [pc, #28]	; (403118 <_lseek_r+0x20>)
  4030fc:	4605      	mov	r5, r0
  4030fe:	2000      	movs	r0, #0
  403100:	6020      	str	r0, [r4, #0]
  403102:	4608      	mov	r0, r1
  403104:	4611      	mov	r1, r2
  403106:	461a      	mov	r2, r3
  403108:	f7fe ff82 	bl	402010 <_lseek>
  40310c:	1c43      	adds	r3, r0, #1
  40310e:	d102      	bne.n	403116 <_lseek_r+0x1e>
  403110:	6823      	ldr	r3, [r4, #0]
  403112:	b103      	cbz	r3, 403116 <_lseek_r+0x1e>
  403114:	602b      	str	r3, [r5, #0]
  403116:	bd38      	pop	{r3, r4, r5, pc}
  403118:	20000cfc 	.word	0x20000cfc

0040311c <_read_r>:
  40311c:	b538      	push	{r3, r4, r5, lr}
  40311e:	4c07      	ldr	r4, [pc, #28]	; (40313c <_read_r+0x20>)
  403120:	4605      	mov	r5, r0
  403122:	2000      	movs	r0, #0
  403124:	6020      	str	r0, [r4, #0]
  403126:	4608      	mov	r0, r1
  403128:	4611      	mov	r1, r2
  40312a:	461a      	mov	r2, r3
  40312c:	f7fd f862 	bl	4001f4 <_read>
  403130:	1c43      	adds	r3, r0, #1
  403132:	d102      	bne.n	40313a <_read_r+0x1e>
  403134:	6823      	ldr	r3, [r4, #0]
  403136:	b103      	cbz	r3, 40313a <_read_r+0x1e>
  403138:	602b      	str	r3, [r5, #0]
  40313a:	bd38      	pop	{r3, r4, r5, pc}
  40313c:	20000cfc 	.word	0x20000cfc

00403140 <p_uc_charset10x14>:
	...
  40315c:	ccffccff 00000000 00000000 00000000     ................
  40316c:	00f000f0 00000000 00f000f0 00000000     ................
  40317c:	c00cc00c fcfffcff c00cc00c fcfffcff     ................
  40318c:	c00cc00c 701e600c 3033303f fcfffcff     .....`.p?030....
  40319c:	f0333033 c018e039 0cf00060 f0603cf0     303.9...`....<`.
  4031ac:	000fc003 3cf0183c 18003cc0 f87ff03c     ....<..<.<..<...
  4031bc:	8cc71cc3 ecdccccf 30307878 cc00fc00     ........xx00....
  4031cc:	00000000 00440000 00f800ec 00000070     ......D.....p...
	...
  4031e4:	f03fc00f 18607878 0cc00cc0 00000000     ..?.xx`.........
  4031f4:	00000000 0cc00cc0 78781860 c00ff03f     ........`.xx?...
  403204:	00000000 e00e600c 8003c007 f83ff83f     .....`......?.?.
  403214:	c0078003 600ce00e 00030003 00030003     .......`........
  403224:	f03ff03f 00030003 00030003 ec004400     ?.?..........D..
  403234:	7000f800 00000000 00000000 00000000     ...p............
  403244:	00030003 00030003 00030003 00030003     ................
  403254:	00030003 3c001800 18003c00 00000000     .......<.<......
	...
  40326c:	0c000000 f0003c00 000fc003 00f0003c     .....<......<...
  40327c:	000000c0 f87ff03f ccc1fce0 0cc78cc3     ....?...........
  40328c:	1cfc0cce f03ff87f 00000000 0c700c30     ......?.....0.p.
  40329c:	fcfffcff 0c000c00 00000000 1c700c30     ............0.p.
  4032ac:	7cc03ce0 ccc1ecc0 0ce78cc3 0c3c0c7e     .<.|........~.<.
  4032bc:	38703030 0cc01ce0 0cc30cc0 1ce30cc3     00p8............
  4032cc:	f03cf87f c007c003 c01cc00e c070c038     ..<.........8.p.
  4032dc:	fcfffcff c000c000 38fc30fc 0ccc1ccc     .........0.8....
  4032ec:	0ccc0ccc 1cce0ccc f0c3f8c7 f87ff03f     ............?...
  4032fc:	0cc31ce3 0cc30cc3 9ce30cc3 f030f871     ............q.0.
  40330c:	00c000c0 00c000c0 fcc7fcc3 00dc00ce     ................
  40331c:	00f000f8 f87ff03c 0cc39ce7 0cc30cc3     ....<...........
  40332c:	9ce70cc3 f03cf87f 007e003c 0cc30ce7     ......<.<.~.....
  40333c:	38c31cc3 e0e770c3 803fc07f 00000000     ...8.p....?.....
  40334c:	60180000 f03cf03c 00006018 00000000     ...`<.<..`......
  40335c:	00000000 44180000 f83cec3c 00007018     .......D<.<..p..
  40336c:	00000000 00030000 c00f8007 7038e01c     ..............8p
  40337c:	1ce03870 00000cc0 c00cc00c c00cc00c     p8..............
  40338c:	c00cc00c c00cc00c c00cc00c 0cc00000     ................
  40339c:	38701ce0 e01c7038 8007c00f 00000003     ..p88p..........
  4033ac:	00700030 00c000e0 ecc3ecc1 00e600c3     0.p.............
  4033bc:	003c007e f871f030 0cc39ce3 fcc3fcc3     ~.<.0.q.........
  4033cc:	1ce00cc0 f03ff87f fc7ffc3f c0c0c0e0     ......?.?.......
  4033dc:	c0c0c0c0 c0e0c0c0 fc3ffc7f fcfffcff     ..........?.....
  4033ec:	0cc30cc3 0cc30cc3 9ce70cc3 f03cf87f     ..............<.
  4033fc:	f87ff03f 0cc01ce0 0cc00cc0 1ce00cc0     ?...............
  40340c:	30303870 fcfffcff 0cc00cc0 0cc00cc0     p800............
  40341c:	1ce00cc0 f03ff87f fcfffcff 0cc30cc3     ......?.........
  40342c:	0cc30cc3 0cc30cc3 0cc00cc0 fcfffcff     ................
  40343c:	00c300c3 00c300c3 00c300c3 00c000c0     ................
  40344c:	f87ff03f 0cc01ce0 0cc30cc0 1ce30cc3     ?...............
  40345c:	f033f873 fcfffcff 00030003 00030003     s.3.............
  40346c:	00030003 fcfffcff 00000000 0cc00cc0     ................
  40347c:	fcfffcff 0cc00cc0 00000000 38003000     .............0.8
  40348c:	0cc01cc0 1cc00cc0 f0fff8ff 00c000c0     ................
  40349c:	fcfffcff 80078007 e01cc00f 38707038     ............8pp8
  4034ac:	0cc01ce0 fcfffcff 0c000c00 0c000c00     ................
  4034bc:	0c000c00 0c000c00 fcfffcff 00380070     ............p.8.
  4034cc:	001f001f 00700038 fcfffcff fcfffcff     ....8.p.........
  4034dc:	000e001c 80030007 e000c001 fcfffcff     ................
  4034ec:	f87ff03f 0cc01ce0 0cc00cc0 1ce00cc0     ?...............
  4034fc:	f03ff87f fcfffcff 00c300c3 00c300c3     ..?.............
  40350c:	00e700c3 003c007e f87ff03f 0cc01ce0     ....~.<.?.......
  40351c:	ecc0ccc0 38e07cc0 ec3ffc7f fcfffcff     .....|.8..?.....
  40352c:	80c300c3 c0c380c3 70e7c0c3 1c3c3c7e     ...........p~<<.
  40353c:	1c7e183c 0cc30ce7 0cc30cc3 9cc30cc3     <.~.............
  40354c:	f060f8e1 00c000c0 00c000c0 fcfffcff     ..`.............
  40355c:	00c000c0 00c000c0 f8fff0ff 0c001c00     ................
  40356c:	0c000c00 1c000c00 f0fff8ff e0ffc0ff     ................
  40357c:	38007000 1c001c00 70003800 c0ffe0ff     .p.8.....8.p....
  40358c:	f8fff0ff 3c001c00 f800f800 1c003c00     .......<.....<..
  40359c:	f0fff8ff 7cf83cf0 c00fe01c 80078007     .....<.|........
  4035ac:	e01cc00f 3cf07cf8 00fe00fc 80030007     .....|.<........
  4035bc:	fc01fc01 00078003 00fc00fe 7cc03cc0     .............<.|
  4035cc:	ccc1ecc0 0cc78cc3 0cdc0cce 0cf00cf8     ................
  4035dc:	00000000 fcfffcff 0cc00cc0 00000cc0     ................
  4035ec:	00000000 00300030 000c000c 00030003     ....0.0.........
  4035fc:	c000c000 30003000 00000000 0cc00cc0     .....0.0........
  40360c:	fcff0cc0 0000fcff 00000000 001c000c     ................
  40361c:	00700038 00e000e0 00380070 000c001c     8.p.....p.8.....
  40362c:	0c000c00 0c000c00 0c000c00 0c000c00     ................
  40363c:	0c000c00 00000000 00e000c0 00380070     ............p.8.
  40364c:	00000018 00000000 78063000 cc0cfc0e     .........0.x....
  40365c:	cc0ccc0c cc0ecc0c f803fc07 fcfffcff     ................
  40366c:	0c030c03 0c030c03 9c030c03 f000f801     ................
  40367c:	f807f003 0c0c1c0e 0c0c0c0c 1c0e0c0c     ................
  40368c:	30033807 f801f000 0c039c03 0c030c03     .8.0............
  40369c:	0c030c03 fcfffcff f807f003 cc0cdc0e     ................
  4036ac:	cc0ccc0c dc0ecc0c 9003d807 00030000     ................
  4036bc:	fc7ffc3f 00e300e3 00300070 00000000     ?.......p.0.....
  4036cc:	9c071803 cc0ccc0f cc0ccc0c dc0ccc0c     ................
  4036dc:	f007f80f fcfffcff 00030003 00030003     ................
  4036ec:	fc018003 0000fc00 00000000 00000000     ................
  4036fc:	fc1bfc1b 00000000 00000000 30000000     ...............0
  40370c:	1c003800 0c000c00 f8cf1c00 0000f0cf     .8..............
  40371c:	fcff0000 e000fcff f003e001 1c0e3807     .............8..
  40372c:	00000c0c 00000000 0cc00cc0 fcfffcff     ................
  40373c:	0c000c00 00000000 fc0ffc0f 0007000e     ................
  40374c:	c003c003 000e0007 fc0ffc0f fc0ffc0f     ................
  40375c:	00070003 000c000e 000e000c fc03fc07     ................
  40376c:	f807f003 0c0c1c0e 0c0c0c0c 1c0e0c0c     ................
  40377c:	f003f807 fc0ffc0f c00cc00c c00cc00c     ................
  40378c:	c00fc00c 00038007 80070003 c00cc00f     ................
  40379c:	c00cc00c c00cc00c fc0ffc0f fc0ffc0f     ................
  4037ac:	00078003 000c000e 000e000c 00030007     ................
  4037bc:	9c071803 cc0ccc0f cc0ccc0c fc0ccc0c     ................
  4037cc:	3006780e 000c0000 f0ff000c 1c0cf8ff     .x.0............
  4037dc:	380c1c0c 0000300c f80ff00f 0c001c00     ...8.0..........
  4037ec:	0c000c00 1c000c00 f00ff80f e00fc00f     ................
  4037fc:	38007000 1c001c00 70003800 c00fe00f     .p.8.....8.p....
  40380c:	f80ff00f 1c001c00 f800f800 1c001c00     ................
  40381c:	f00ff80f 1c0e0c0c f0033807 e001e001     .........8......
  40382c:	3807f003 0c0c1c0e 000e000c 9c030c07     ...8............
  40383c:	f001f801 00078003 000c000e 1c0c0c0c     ................
  40384c:	7c0c3c0c cc0dec0c 0c0f8c0f 0c0c0c0e     .<.|............
  40385c:	00030000 f03f8007 1ce0f87c 0cc00cc0     ......?.|.......
  40386c:	00000cc0 0c030c03 fc7ffc3f 0cc30ce3     ........?.......
  40387c:	0ce00cc0 0c300c70 0cc00000 0cc00cc0     ....p.0.........
  40388c:	f87c1ce0 8007f03f 00000003 00c000c0     ..|.?...........
  40389c:	00c000c0 00c000c0 00c000c0 00c000c0     ................
  4038ac:	fcfffcff fcfffcff fcfffcff fcfffcff     ................
  4038bc:	fcfffcff 39696c69 5f787833 2064636c     ....ili93xx_lcd 
  4038cc:	6d617865 00656c70                       example.

004038d4 <_global_impure_ptr>:
  4038d4:	20000018 00000043                       ... C...

004038dc <_init>:
  4038dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4038de:	bf00      	nop
  4038e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4038e2:	bc08      	pop	{r3}
  4038e4:	469e      	mov	lr, r3
  4038e6:	4770      	bx	lr

004038e8 <__init_array_start>:
  4038e8:	004025b9 	.word	0x004025b9

004038ec <__frame_dummy_init_array_entry>:
  4038ec:	00400145                                E.@.

004038f0 <_fini>:
  4038f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4038f2:	bf00      	nop
  4038f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4038f6:	bc08      	pop	{r3}
  4038f8:	469e      	mov	lr, r3
  4038fa:	4770      	bx	lr

004038fc <__fini_array_start>:
  4038fc:	0040011d 	.word	0x0040011d
