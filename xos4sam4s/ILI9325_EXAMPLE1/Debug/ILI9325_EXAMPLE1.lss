
ILI9325_EXAMPLE1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000033a0  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000848  20000000  004033a0  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004ac  20000848  00403be8  00010848  2**2
                  ALLOC
  3 .stack        00003004  20000cf4  00404094  00010848  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00010848  2**0
                  CONTENTS, READONLY
  5 .comment      00000071  00000000  00000000  00010872  2**0
                  CONTENTS, READONLY
  6 .debug_info   00019acd  00000000  00000000  000108e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004a1d  00000000  00000000  0002a3b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00006e8f  00000000  00000000  0002edcd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000d10  00000000  00000000  00035c5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000c68  00000000  00000000  0003696c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001357b  00000000  00000000  000375d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000f9bd  00000000  00000000  0004ab4f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00054e64  00000000  00000000  0005a50c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001b94  00000000  00000000  000af370  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20003cf8 	.word	0x20003cf8
  400004:	00401665 	.word	0x00401665
  400008:	00401661 	.word	0x00401661
  40000c:	00401661 	.word	0x00401661
  400010:	00401661 	.word	0x00401661
  400014:	00401661 	.word	0x00401661
  400018:	00401661 	.word	0x00401661
	...
  40002c:	00401661 	.word	0x00401661
  400030:	00401661 	.word	0x00401661
  400034:	00000000 	.word	0x00000000
  400038:	00401661 	.word	0x00401661
  40003c:	00401661 	.word	0x00401661
  400040:	00401661 	.word	0x00401661
  400044:	00401661 	.word	0x00401661
  400048:	00401661 	.word	0x00401661
  40004c:	00401661 	.word	0x00401661
  400050:	00401661 	.word	0x00401661
  400054:	00401661 	.word	0x00401661
  400058:	00401661 	.word	0x00401661
  40005c:	00401661 	.word	0x00401661
  400060:	00401661 	.word	0x00401661
  400064:	00401661 	.word	0x00401661
  400068:	00000000 	.word	0x00000000
  40006c:	00401395 	.word	0x00401395
  400070:	004013b1 	.word	0x004013b1
  400074:	004013cd 	.word	0x004013cd
  400078:	00401661 	.word	0x00401661
  40007c:	00401661 	.word	0x00401661
	...
  400088:	00401661 	.word	0x00401661
  40008c:	00401661 	.word	0x00401661
  400090:	00401661 	.word	0x00401661
  400094:	00401661 	.word	0x00401661
  400098:	00401661 	.word	0x00401661
  40009c:	00401661 	.word	0x00401661
  4000a0:	00401661 	.word	0x00401661
  4000a4:	00401661 	.word	0x00401661
  4000a8:	00401661 	.word	0x00401661
  4000ac:	00401661 	.word	0x00401661
  4000b0:	00401661 	.word	0x00401661
  4000b4:	00401661 	.word	0x00401661
  4000b8:	00401661 	.word	0x00401661
  4000bc:	00401661 	.word	0x00401661
  4000c0:	00401661 	.word	0x00401661
  4000c4:	00401661 	.word	0x00401661
  4000c8:	00401661 	.word	0x00401661

004000cc <deregister_tm_clones>:
  4000cc:	b508      	push	{r3, lr}
  4000ce:	4805      	ldr	r0, [pc, #20]	; (4000e4 <deregister_tm_clones+0x18>)
  4000d0:	4b05      	ldr	r3, [pc, #20]	; (4000e8 <deregister_tm_clones+0x1c>)
  4000d2:	1a19      	subs	r1, r3, r0
  4000d4:	2906      	cmp	r1, #6
  4000d6:	d800      	bhi.n	4000da <deregister_tm_clones+0xe>
  4000d8:	bd08      	pop	{r3, pc}
  4000da:	4a04      	ldr	r2, [pc, #16]	; (4000ec <deregister_tm_clones+0x20>)
  4000dc:	2a00      	cmp	r2, #0
  4000de:	d0fb      	beq.n	4000d8 <deregister_tm_clones+0xc>
  4000e0:	4790      	blx	r2
  4000e2:	e7f9      	b.n	4000d8 <deregister_tm_clones+0xc>
  4000e4:	004033a0 	.word	0x004033a0
  4000e8:	004033a3 	.word	0x004033a3
  4000ec:	00000000 	.word	0x00000000

004000f0 <register_tm_clones>:
  4000f0:	b508      	push	{r3, lr}
  4000f2:	4807      	ldr	r0, [pc, #28]	; (400110 <register_tm_clones+0x20>)
  4000f4:	4b07      	ldr	r3, [pc, #28]	; (400114 <register_tm_clones+0x24>)
  4000f6:	1a19      	subs	r1, r3, r0
  4000f8:	108a      	asrs	r2, r1, #2
  4000fa:	eb02 73d2 	add.w	r3, r2, r2, lsr #31
  4000fe:	1059      	asrs	r1, r3, #1
  400100:	d100      	bne.n	400104 <register_tm_clones+0x14>
  400102:	bd08      	pop	{r3, pc}
  400104:	4a04      	ldr	r2, [pc, #16]	; (400118 <register_tm_clones+0x28>)
  400106:	2a00      	cmp	r2, #0
  400108:	d0fb      	beq.n	400102 <register_tm_clones+0x12>
  40010a:	4790      	blx	r2
  40010c:	e7f9      	b.n	400102 <register_tm_clones+0x12>
  40010e:	bf00      	nop
  400110:	004033a0 	.word	0x004033a0
  400114:	004033a0 	.word	0x004033a0
  400118:	00000000 	.word	0x00000000

0040011c <__do_global_dtors_aux>:
  40011c:	b510      	push	{r4, lr}
  40011e:	4c06      	ldr	r4, [pc, #24]	; (400138 <__do_global_dtors_aux+0x1c>)
  400120:	7823      	ldrb	r3, [r4, #0]
  400122:	b943      	cbnz	r3, 400136 <__do_global_dtors_aux+0x1a>
  400124:	f7ff ffd2 	bl	4000cc <deregister_tm_clones>
  400128:	4804      	ldr	r0, [pc, #16]	; (40013c <__do_global_dtors_aux+0x20>)
  40012a:	b110      	cbz	r0, 400132 <__do_global_dtors_aux+0x16>
  40012c:	4804      	ldr	r0, [pc, #16]	; (400140 <__do_global_dtors_aux+0x24>)
  40012e:	f3af 8000 	nop.w
  400132:	2101      	movs	r1, #1
  400134:	7021      	strb	r1, [r4, #0]
  400136:	bd10      	pop	{r4, pc}
  400138:	20000848 	.word	0x20000848
  40013c:	00000000 	.word	0x00000000
  400140:	004033a0 	.word	0x004033a0

00400144 <frame_dummy>:
  400144:	b508      	push	{r3, lr}
  400146:	4b08      	ldr	r3, [pc, #32]	; (400168 <frame_dummy+0x24>)
  400148:	b11b      	cbz	r3, 400152 <frame_dummy+0xe>
  40014a:	4808      	ldr	r0, [pc, #32]	; (40016c <frame_dummy+0x28>)
  40014c:	4908      	ldr	r1, [pc, #32]	; (400170 <frame_dummy+0x2c>)
  40014e:	f3af 8000 	nop.w
  400152:	4808      	ldr	r0, [pc, #32]	; (400174 <frame_dummy+0x30>)
  400154:	6801      	ldr	r1, [r0, #0]
  400156:	b111      	cbz	r1, 40015e <frame_dummy+0x1a>
  400158:	4a07      	ldr	r2, [pc, #28]	; (400178 <frame_dummy+0x34>)
  40015a:	b102      	cbz	r2, 40015e <frame_dummy+0x1a>
  40015c:	4790      	blx	r2
  40015e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400162:	f7ff bfc5 	b.w	4000f0 <register_tm_clones>
  400166:	bf00      	nop
  400168:	00000000 	.word	0x00000000
  40016c:	004033a0 	.word	0x004033a0
  400170:	2000084c 	.word	0x2000084c
  400174:	004033a0 	.word	0x004033a0
  400178:	00000000 	.word	0x00000000

0040017c <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  40017c:	b510      	push	{r4, lr}
	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40017e:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  400182:	f2c0 7027 	movt	r0, #1831	; 0x727
  400186:	f641 1381 	movw	r3, #6529	; 0x1981
  40018a:	f2c0 0340 	movt	r3, #64	; 0x40
  40018e:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  400190:	f04f 0000 	mov.w	r0, #0
  400194:	f04f 013e 	mov.w	r1, #62	; 0x3e
  400198:	f241 4289 	movw	r2, #5257	; 0x1489
  40019c:	f2c0 0240 	movt	r2, #64	; 0x40
  4001a0:	4790      	blx	r2
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  4001a2:	f241 44f9 	movw	r4, #5369	; 0x14f9
  4001a6:	f2c0 0440 	movt	r4, #64	; 0x40
  4001aa:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4001ac:	2800      	cmp	r0, #0
  4001ae:	d0fc      	beq.n	4001aa <sysclk_init+0x2e>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4001b0:	f241 5009 	movw	r0, #5385	; 0x1509
  4001b4:	f2c0 0040 	movt	r0, #64	; 0x40
  4001b8:	4780      	blx	r0
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4001ba:	f44f 6180 	mov.w	r1, #1024	; 0x400
  4001be:	f2c4 010e 	movt	r1, #16398	; 0x400e
  4001c2:	f643 7301 	movw	r3, #16129	; 0x3f01
  4001c6:	f2c2 0313 	movt	r3, #8211	; 0x2013
  4001ca:	628b      	str	r3, [r1, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  4001cc:	f241 5419 	movw	r4, #5401	; 0x1519
  4001d0:	f2c0 0440 	movt	r4, #64	; 0x40
  4001d4:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  4001d6:	2800      	cmp	r0, #0
  4001d8:	d0fc      	beq.n	4001d4 <sysclk_init+0x58>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  4001da:	f04f 0010 	mov.w	r0, #16
  4001de:	f241 32e9 	movw	r2, #5097	; 0x13e9
  4001e2:	f2c0 0240 	movt	r2, #64	; 0x40
  4001e6:	4790      	blx	r2
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  4001e8:	f241 70c9 	movw	r0, #6089	; 0x17c9
  4001ec:	f2c0 0040 	movt	r0, #64	; 0x40
  4001f0:	4780      	blx	r0
  4001f2:	bd10      	pop	{r4, pc}

004001f4 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
  4001f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4001f8:	460c      	mov	r4, r1
  4001fa:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
  4001fc:	bb48      	cbnz	r0, 400252 <_read+0x5e>
		return -1;
	}

	for (; len > 0; --len) {
  4001fe:	2a00      	cmp	r2, #0
  400200:	dd2b      	ble.n	40025a <_read+0x66>

int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
  400202:	188f      	adds	r7, r1, r2
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  400204:	f640 46d8 	movw	r6, #3288	; 0xcd8
  400208:	f2c2 0600 	movt	r6, #8192	; 0x2000
  40020c:	f640 45d0 	movw	r5, #3280	; 0xcd0
  400210:	f2c2 0500 	movt	r5, #8192	; 0x2000
  400214:	ea6f 0901 	mvn.w	r9, r1
  400218:	eb07 0009 	add.w	r0, r7, r9
  40021c:	f000 0901 	and.w	r9, r0, #1
  400220:	6830      	ldr	r0, [r6, #0]
  400222:	682b      	ldr	r3, [r5, #0]
  400224:	4798      	blx	r3
		ptr++;
  400226:	f104 0401 	add.w	r4, r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  40022a:	42bc      	cmp	r4, r7
  40022c:	d119      	bne.n	400262 <_read+0x6e>
  40022e:	e00d      	b.n	40024c <_read+0x58>
		ptr_get(stdio_base, ptr);
  400230:	6830      	ldr	r0, [r6, #0]
  400232:	682b      	ldr	r3, [r5, #0]
  400234:	4621      	mov	r1, r4
  400236:	4798      	blx	r3
		ptr++;
  400238:	f104 0401 	add.w	r4, r4, #1
  40023c:	4621      	mov	r1, r4
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  40023e:	6830      	ldr	r0, [r6, #0]
  400240:	682a      	ldr	r2, [r5, #0]
  400242:	4790      	blx	r2
		ptr++;
  400244:	f104 0401 	add.w	r4, r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  400248:	42bc      	cmp	r4, r7
  40024a:	d1f1      	bne.n	400230 <_read+0x3c>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
  40024c:	4640      	mov	r0, r8
  40024e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
  400252:	f04f 30ff 	mov.w	r0, #4294967295
  400256:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	}

	for (; len > 0; --len) {
  40025a:	f04f 0000 	mov.w	r0, #0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
  40025e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  400262:	f1b9 0f00 	cmp.w	r9, #0
  400266:	d0e3      	beq.n	400230 <_read+0x3c>
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  400268:	6830      	ldr	r0, [r6, #0]
  40026a:	682a      	ldr	r2, [r5, #0]
  40026c:	4621      	mov	r1, r4
  40026e:	4790      	blx	r2
		ptr++;
  400270:	f104 0401 	add.w	r4, r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  400274:	42bc      	cmp	r4, r7
  400276:	d1db      	bne.n	400230 <_read+0x3c>
  400278:	e7e8      	b.n	40024c <_read+0x58>
  40027a:	bf00      	nop

0040027c <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len);

int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
  40027c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  400280:	460d      	mov	r5, r1
  400282:	4690      	mov	r8, r2
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
  400284:	f100 30ff 	add.w	r0, r0, #4294967295
  400288:	2802      	cmp	r0, #2
  40028a:	d824      	bhi.n	4002d6 <_write+0x5a>
		return -1;
	}

	for (; len != 0; --len) {
  40028c:	b332      	cbz	r2, 4002dc <_write+0x60>
		if (ptr_put(stdio_base, *ptr++) < 0) {
  40028e:	f640 46d8 	movw	r6, #3288	; 0xcd8
  400292:	f2c2 0600 	movt	r6, #8192	; 0x2000
  400296:	f640 47d4 	movw	r7, #3284	; 0xcd4
  40029a:	f2c2 0700 	movt	r7, #8192	; 0x2000
  40029e:	f04f 0400 	mov.w	r4, #0
  4002a2:	f102 39ff 	add.w	r9, r2, #4294967295
  4002a6:	f009 0901 	and.w	r9, r9, #1
  4002aa:	6830      	ldr	r0, [r6, #0]
  4002ac:	683b      	ldr	r3, [r7, #0]
  4002ae:	5d09      	ldrb	r1, [r1, r4]
  4002b0:	4798      	blx	r3
  4002b2:	42a0      	cmp	r0, r4
  4002b4:	da1a      	bge.n	4002ec <_write+0x70>
  4002b6:	e014      	b.n	4002e2 <_write+0x66>
  4002b8:	6830      	ldr	r0, [r6, #0]
  4002ba:	683b      	ldr	r3, [r7, #0]
  4002bc:	5d29      	ldrb	r1, [r5, r4]
  4002be:	4798      	blx	r3
  4002c0:	2800      	cmp	r0, #0
  4002c2:	db0e      	blt.n	4002e2 <_write+0x66>
			return -1;
		}
		++nChars;
  4002c4:	f104 0401 	add.w	r4, r4, #1
	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
  4002c8:	6830      	ldr	r0, [r6, #0]
  4002ca:	683a      	ldr	r2, [r7, #0]
  4002cc:	5d29      	ldrb	r1, [r5, r4]
  4002ce:	4790      	blx	r2
  4002d0:	2800      	cmp	r0, #0
  4002d2:	da1d      	bge.n	400310 <_write+0x94>
  4002d4:	e005      	b.n	4002e2 <_write+0x66>
_write (int file, const char *ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
  4002d6:	f04f 34ff 	mov.w	r4, #4294967295
  4002da:	e004      	b.n	4002e6 <_write+0x6a>
	}

	for (; len != 0; --len) {
  4002dc:	f04f 0400 	mov.w	r4, #0
  4002e0:	e001      	b.n	4002e6 <_write+0x6a>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
  4002e2:	f04f 34ff 	mov.w	r4, #4294967295
		}
		++nChars;
	}
	return nChars;
}
  4002e6:	4620      	mov	r0, r4
  4002e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
  4002ec:	f104 0401 	add.w	r4, r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  4002f0:	45a0      	cmp	r8, r4
  4002f2:	d0f8      	beq.n	4002e6 <_write+0x6a>
  4002f4:	f1b9 0f00 	cmp.w	r9, #0
  4002f8:	d0de      	beq.n	4002b8 <_write+0x3c>
		if (ptr_put(stdio_base, *ptr++) < 0) {
  4002fa:	6830      	ldr	r0, [r6, #0]
  4002fc:	683a      	ldr	r2, [r7, #0]
  4002fe:	5d29      	ldrb	r1, [r5, r4]
  400300:	4790      	blx	r2
  400302:	2800      	cmp	r0, #0
  400304:	dbed      	blt.n	4002e2 <_write+0x66>
			return -1;
		}
		++nChars;
  400306:	f104 0401 	add.w	r4, r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  40030a:	45a0      	cmp	r8, r4
  40030c:	d1d4      	bne.n	4002b8 <_write+0x3c>
  40030e:	e7ea      	b.n	4002e6 <_write+0x6a>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
  400310:	f104 0401 	add.w	r4, r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
  400314:	45a0      	cmp	r8, r4
  400316:	d1cf      	bne.n	4002b8 <_write+0x3c>
  400318:	e7e5      	b.n	4002e6 <_write+0x6a>
  40031a:	bf00      	nop

0040031c <board_init>:
#include "conf_board.h"
#include "gpio.h"
#include "ioport.h"

void board_init(void)
{
  40031c:	b538      	push	{r3, r4, r5, lr}
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  40031e:	f241 4350 	movw	r3, #5200	; 0x1450
  400322:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400326:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40032a:	605a      	str	r2, [r3, #4]
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  40032c:	f04f 000b 	mov.w	r0, #11
  400330:	f241 5429 	movw	r4, #5417	; 0x1529
  400334:	f2c0 0440 	movt	r4, #64	; 0x40
  400338:	47a0      	blx	r4
  40033a:	f04f 000c 	mov.w	r0, #12
  40033e:	47a0      	blx	r4
  400340:	f04f 000d 	mov.w	r0, #13
  400344:	47a0      	blx	r4
	 * Here IOPORT must be initialized for others to use before setting up IO.
	 */
	ioport_init();

	/* Configure LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
  400346:	f04f 0013 	mov.w	r0, #19
  40034a:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  40034e:	f241 0485 	movw	r4, #4229	; 0x1085
  400352:	f2c0 0440 	movt	r4, #64	; 0x40
  400356:	47a0      	blx	r4
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
  400358:	f04f 0014 	mov.w	r0, #20
  40035c:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  400360:	47a0      	blx	r4

	/* Configure Push Button pins */
	gpio_configure_pin(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS);
  400362:	f04f 0023 	mov.w	r0, #35	; 0x23
  400366:	f04f 0179 	mov.w	r1, #121	; 0x79
  40036a:	f6c2 0100 	movt	r1, #10240	; 0x2800
  40036e:	47a0      	blx	r4
	gpio_configure_pin(GPIO_PUSH_BUTTON_2, GPIO_PUSH_BUTTON_2_FLAGS);
  400370:	f04f 004c 	mov.w	r0, #76	; 0x4c
  400374:	f04f 0159 	mov.w	r1, #89	; 0x59
  400378:	f6c2 0100 	movt	r1, #10240	; 0x2800
  40037c:	47a0      	blx	r4

#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART0_PIO, PINS_UART0, PINS_UART0_FLAGS);
  40037e:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  400382:	f2c4 000e 	movt	r0, #16398	; 0x400e
  400386:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  40038a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  40038e:	f241 15fd 	movw	r5, #4605	; 0x11fd
  400392:	f2c0 0540 	movt	r5, #64	; 0x40
  400396:	47a8      	blx	r5
	gpio_set_pin_low(PIN_RE_IDX);
#endif

#if defined(CONF_BOARD_ILI9325) || defined(CONF_BOARD_ILI93XX)
	/* Configure LCD EBI pins */
	gpio_configure_pin(PIN_EBI_DATA_BUS_D0, PIN_EBI_DATA_BUS_FLAGS);
  400398:	f04f 0501 	mov.w	r5, #1
  40039c:	f6c0 0500 	movt	r5, #2048	; 0x800
  4003a0:	f04f 0040 	mov.w	r0, #64	; 0x40
  4003a4:	4629      	mov	r1, r5
  4003a6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D1, PIN_EBI_DATA_BUS_FLAGS);
  4003a8:	f04f 0041 	mov.w	r0, #65	; 0x41
  4003ac:	4629      	mov	r1, r5
  4003ae:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D2, PIN_EBI_DATA_BUS_FLAGS);
  4003b0:	f04f 0042 	mov.w	r0, #66	; 0x42
  4003b4:	4629      	mov	r1, r5
  4003b6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D3, PIN_EBI_DATA_BUS_FLAGS);
  4003b8:	f04f 0043 	mov.w	r0, #67	; 0x43
  4003bc:	4629      	mov	r1, r5
  4003be:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D4, PIN_EBI_DATA_BUS_FLAGS);
  4003c0:	f04f 0044 	mov.w	r0, #68	; 0x44
  4003c4:	4629      	mov	r1, r5
  4003c6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D5, PIN_EBI_DATA_BUS_FLAGS);
  4003c8:	f04f 0045 	mov.w	r0, #69	; 0x45
  4003cc:	4629      	mov	r1, r5
  4003ce:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D6, PIN_EBI_DATA_BUS_FLAGS);
  4003d0:	f04f 0046 	mov.w	r0, #70	; 0x46
  4003d4:	4629      	mov	r1, r5
  4003d6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_DATA_BUS_D7, PIN_EBI_DATA_BUS_FLAGS);
  4003d8:	f04f 0047 	mov.w	r0, #71	; 0x47
  4003dc:	4629      	mov	r1, r5
  4003de:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_NRD, PIN_EBI_NRD_FLAGS);
  4003e0:	f04f 004b 	mov.w	r0, #75	; 0x4b
  4003e4:	4629      	mov	r1, r5
  4003e6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_NWE, PIN_EBI_NWE_FLAGS);
  4003e8:	f04f 0048 	mov.w	r0, #72	; 0x48
  4003ec:	4629      	mov	r1, r5
  4003ee:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_NCS1, PIN_EBI_NCS1_FLAGS);
  4003f0:	f04f 004f 	mov.w	r0, #79	; 0x4f
  4003f4:	4629      	mov	r1, r5
  4003f6:	47a0      	blx	r4
	gpio_configure_pin(PIN_EBI_LCD_RS, PIN_EBI_LCD_RS_FLAGS);
  4003f8:	f04f 0053 	mov.w	r0, #83	; 0x53
  4003fc:	4629      	mov	r1, r5
  4003fe:	47a0      	blx	r4
#endif

#ifdef CONF_BOARD_AAT3155
	/* Configure Backlight control pin */
	gpio_configure_pin(BOARD_AAT31XX_SET_GPIO, BOARD_AAT31XX_SET_FLAGS);
  400400:	f04f 004d 	mov.w	r0, #77	; 0x4d
  400404:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  400408:	47a0      	blx	r4
  40040a:	bd38      	pop	{r3, r4, r5, pc}

0040040c <aat31xx_set_backlight>:
 * \param ul_level backlight level.
 *
 * \note pin BOARD_AAT31XX_SET_GPIO must be configured before calling aat31xx_set_backlight.
 */
void aat31xx_set_backlight(uint32_t ul_level)
{
  40040c:	b470      	push	{r4, r5, r6}
  40040e:	b083      	sub	sp, #12
	volatile uint32_t ul_delay;
	uint32_t i;

#ifdef CONF_BOARD_AAT3155
	ul_level = AAT31XX_MAX_BACKLIGHT_LEVEL - ul_level + 1;
  400410:	f1c0 0011 	rsb	r0, r0, #17
#ifdef CONF_BOARD_AAT3193
	ul_level = AAT31XX_MAX_BACKLIGHT_LEVEL - ul_level + 1;
#endif

	/* Ensure valid level */
	ul_level = (ul_level > AAT31XX_MAX_BACKLIGHT_LEVEL) ? AAT31XX_MAX_BACKLIGHT_LEVEL : ul_level;
  400414:	2810      	cmp	r0, #16
  400416:	bf34      	ite	cc
  400418:	4606      	movcc	r6, r0
  40041a:	2610      	movcs	r6, #16
	ul_level = (ul_level < AAT31XX_MIN_BACKLIGHT_LEVEL) ? AAT31XX_MIN_BACKLIGHT_LEVEL : ul_level;
  40041c:	2e00      	cmp	r6, #0
  40041e:	bf08      	it	eq
  400420:	2601      	moveq	r6, #1

	/* Set new backlight level */
	for (i = 0; i < ul_level; i++) {
  400422:	f04f 0100 	mov.w	r1, #0
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  400426:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  40042a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40042e:	f44f 5500 	mov.w	r5, #8192	; 0x2000
		ioport_set_pin_level(BOARD_AAT31XX_SET_GPIO, IOPORT_PIN_LEVEL_LOW);
		ul_delay = DELAY_PULSE;
  400432:	f04f 0418 	mov.w	r4, #24
  400436:	6345      	str	r5, [r0, #52]	; 0x34
  400438:	9401      	str	r4, [sp, #4]
		while (ul_delay--) {
  40043a:	9b01      	ldr	r3, [sp, #4]
  40043c:	f103 32ff 	add.w	r2, r3, #4294967295
  400440:	9201      	str	r2, [sp, #4]
  400442:	2b00      	cmp	r3, #0
  400444:	d1f9      	bne.n	40043a <aat31xx_set_backlight+0x2e>
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  400446:	6305      	str	r5, [r0, #48]	; 0x30
		}

		ioport_set_pin_level(BOARD_AAT31XX_SET_GPIO, IOPORT_PIN_LEVEL_HIGH);

		ul_delay = DELAY_PULSE;
  400448:	9401      	str	r4, [sp, #4]
		while (ul_delay--) {
  40044a:	9b01      	ldr	r3, [sp, #4]
  40044c:	f103 32ff 	add.w	r2, r3, #4294967295
  400450:	9201      	str	r2, [sp, #4]
  400452:	2b00      	cmp	r3, #0
  400454:	d1f9      	bne.n	40044a <aat31xx_set_backlight+0x3e>
	/* Ensure valid level */
	ul_level = (ul_level > AAT31XX_MAX_BACKLIGHT_LEVEL) ? AAT31XX_MAX_BACKLIGHT_LEVEL : ul_level;
	ul_level = (ul_level < AAT31XX_MIN_BACKLIGHT_LEVEL) ? AAT31XX_MIN_BACKLIGHT_LEVEL : ul_level;

	/* Set new backlight level */
	for (i = 0; i < ul_level; i++) {
  400456:	f101 0101 	add.w	r1, r1, #1
  40045a:	42b1      	cmp	r1, r6
  40045c:	d3eb      	bcc.n	400436 <aat31xx_set_backlight+0x2a>
		ul_delay = DELAY_PULSE;
		while (ul_delay--) {
		}
	}

	ul_delay = DELAY_ENABLE;
  40045e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  400462:	9101      	str	r1, [sp, #4]
	while (ul_delay--) {
  400464:	9801      	ldr	r0, [sp, #4]
  400466:	f100 33ff 	add.w	r3, r0, #4294967295
  40046a:	9301      	str	r3, [sp, #4]
  40046c:	2800      	cmp	r0, #0
  40046e:	d1f9      	bne.n	400464 <aat31xx_set_backlight+0x58>
	}
}
  400470:	b003      	add	sp, #12
  400472:	bc70      	pop	{r4, r5, r6}
  400474:	4770      	bx	lr
  400476:	bf00      	nop

00400478 <aat31xx_disable_backlight>:

/**
 * \brief Switch off backlight.
 */
void aat31xx_disable_backlight(void)
{
  400478:	b082      	sub	sp, #8
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40047a:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  40047e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  400482:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  400486:	635a      	str	r2, [r3, #52]	; 0x34
	volatile uint32_t ul_delay;

	ioport_set_pin_level(BOARD_AAT31XX_SET_GPIO, IOPORT_PIN_LEVEL_LOW);

	ul_delay = DELAY_DISABLE;
  400488:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  40048c:	9001      	str	r0, [sp, #4]
	while (ul_delay--) {
  40048e:	9901      	ldr	r1, [sp, #4]
  400490:	f101 33ff 	add.w	r3, r1, #4294967295
  400494:	9301      	str	r3, [sp, #4]
  400496:	2900      	cmp	r1, #0
  400498:	d1f9      	bne.n	40048e <aat31xx_disable_backlight+0x16>
	}
}
  40049a:	b002      	add	sp, #8
  40049c:	4770      	bx	lr
  40049e:	bf00      	nop

004004a0 <ili9325_write_ram_prepare>:

/* Define EBI access for ILI9325 8-bit System Interface.*/
#if defined(BOARD_ILI9325_ADDR) && defined (BOARD_ILI9325_RS)
	static inline void LCD_IR(uint8_t lcd_index)
	{
		*((volatile uint8_t *)(BOARD_ILI9325_ADDR)) = lcd_index; /* ILI9325 index register address */
  4004a0:	f04f 43c2 	mov.w	r3, #1627389952	; 0x61000000
  4004a4:	f04f 0200 	mov.w	r2, #0
  4004a8:	701a      	strb	r2, [r3, #0]
  4004aa:	f04f 0022 	mov.w	r0, #34	; 0x22
  4004ae:	7018      	strb	r0, [r3, #0]
  4004b0:	4770      	bx	lr
  4004b2:	bf00      	nop

004004b4 <ili9325_write_ram>:
 *
 * \param ul_color 24-bits RGB color.
 */
static void ili9325_write_ram(ili9325_color_t ul_color)
{
	LCD_WD((ul_color >> 16) & 0xFF);
  4004b4:	f3c0 4207 	ubfx	r2, r0, #16, #8
	}
	static inline void LCD_WD(uint8_t lcd_data)
	{
		*((volatile uint8_t *)((BOARD_ILI9325_ADDR) | (BOARD_ILI9325_RS))) = lcd_data;
  4004b8:	f04f 0302 	mov.w	r3, #2
  4004bc:	f2c6 1300 	movt	r3, #24832	; 0x6100
  4004c0:	701a      	strb	r2, [r3, #0]
	LCD_WD((ul_color >> 8) & 0xFF);
  4004c2:	f3c0 2107 	ubfx	r1, r0, #8, #8
  4004c6:	7019      	strb	r1, [r3, #0]
	LCD_WD(ul_color & 0xFF);
  4004c8:	b2c0      	uxtb	r0, r0
  4004ca:	7018      	strb	r0, [r3, #0]
  4004cc:	4770      	bx	lr
  4004ce:	bf00      	nop

004004d0 <ili9325_write_ram_buffer>:
 *
 * \param p_ul_buf data buffer.
 * \param ul_size size in pixels.
 */
static void ili9325_write_ram_buffer(const ili9325_color_t *p_ul_buf, uint32_t ul_size)
{
  4004d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4004d4:	4681      	mov	r9, r0
  4004d6:	4688      	mov	r8, r1
	uint32_t ul_addr;

	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  4004d8:	f031 0a07 	bics.w	sl, r1, #7
  4004dc:	d04f      	beq.n	40057e <ili9325_write_ram_buffer+0xae>
  4004de:	4605      	mov	r5, r0
		ili9325_write_ram(p_ul_buf[ul_addr]);
  4004e0:	f240 44b5 	movw	r4, #1205	; 0x4b5
  4004e4:	f2c0 0440 	movt	r4, #64	; 0x40
  4004e8:	f10a 33ff 	add.w	r3, sl, #4294967295
  4004ec:	f3c3 06c0 	ubfx	r6, r3, #3, #1
  4004f0:	6800      	ldr	r0, [r0, #0]
  4004f2:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 1]);
  4004f4:	f8d9 0004 	ldr.w	r0, [r9, #4]
  4004f8:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 2]);
  4004fa:	f8d9 0008 	ldr.w	r0, [r9, #8]
  4004fe:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 3]);
  400500:	f8d9 000c 	ldr.w	r0, [r9, #12]
  400504:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
  400506:	f8d9 0010 	ldr.w	r0, [r9, #16]
  40050a:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
  40050c:	f8d9 0014 	ldr.w	r0, [r9, #20]
  400510:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
  400512:	f8d9 0018 	ldr.w	r0, [r9, #24]
  400516:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
  400518:	f8d9 001c 	ldr.w	r0, [r9, #28]
  40051c:	47a0      	blx	r4
 */
static void ili9325_write_ram_buffer(const ili9325_color_t *p_ul_buf, uint32_t ul_size)
{
	uint32_t ul_addr;

	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  40051e:	f04f 0708 	mov.w	r7, #8
  400522:	f105 0520 	add.w	r5, r5, #32
  400526:	4557      	cmp	r7, sl
  400528:	d35d      	bcc.n	4005e6 <ili9325_write_ram_buffer+0x116>
  40052a:	e02a      	b.n	400582 <ili9325_write_ram_buffer+0xb2>
		ili9325_write_ram(p_ul_buf[ul_addr]);
  40052c:	6828      	ldr	r0, [r5, #0]
  40052e:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 1]);
  400530:	6868      	ldr	r0, [r5, #4]
  400532:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 2]);
  400534:	68a8      	ldr	r0, [r5, #8]
  400536:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 3]);
  400538:	68e8      	ldr	r0, [r5, #12]
  40053a:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
  40053c:	6928      	ldr	r0, [r5, #16]
  40053e:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
  400540:	6968      	ldr	r0, [r5, #20]
  400542:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
  400544:	69a8      	ldr	r0, [r5, #24]
  400546:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
  400548:	69e8      	ldr	r0, [r5, #28]
  40054a:	47a0      	blx	r4
  40054c:	f105 0620 	add.w	r6, r5, #32
static void ili9325_write_ram_buffer(const ili9325_color_t *p_ul_buf, uint32_t ul_size)
{
	uint32_t ul_addr;

	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
		ili9325_write_ram(p_ul_buf[ul_addr]);
  400550:	6a28      	ldr	r0, [r5, #32]
  400552:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 1]);
  400554:	6a68      	ldr	r0, [r5, #36]	; 0x24
  400556:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 2]);
  400558:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  40055a:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 3]);
  40055c:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
  40055e:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
  400560:	6b28      	ldr	r0, [r5, #48]	; 0x30
  400562:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
  400564:	6b68      	ldr	r0, [r5, #52]	; 0x34
  400566:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
  400568:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  40056a:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
  40056c:	6be8      	ldr	r0, [r5, #60]	; 0x3c
  40056e:	47a0      	blx	r4
 */
static void ili9325_write_ram_buffer(const ili9325_color_t *p_ul_buf, uint32_t ul_size)
{
	uint32_t ul_addr;

	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  400570:	f107 0710 	add.w	r7, r7, #16
  400574:	f105 0540 	add.w	r5, r5, #64	; 0x40
  400578:	4557      	cmp	r7, sl
  40057a:	d3d7      	bcc.n	40052c <ili9325_write_ram_buffer+0x5c>
  40057c:	e001      	b.n	400582 <ili9325_write_ram_buffer+0xb2>
  40057e:	f04f 0700 	mov.w	r7, #0
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  400582:	45b8      	cmp	r8, r7
  400584:	d922      	bls.n	4005cc <ili9325_write_ram_buffer+0xfc>
 * \brief Write multiple data in buffer to LCD controller.
 *
 * \param p_ul_buf data buffer.
 * \param ul_size size in pixels.
 */
static void ili9325_write_ram_buffer(const ili9325_color_t *p_ul_buf, uint32_t ul_size)
  400586:	f107 34ff 	add.w	r4, r7, #4294967295
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
		ili9325_write_ram(p_ul_buf[ul_addr]);
  40058a:	f240 46b5 	movw	r6, #1205	; 0x4b5
  40058e:	f2c0 0640 	movt	r6, #64	; 0x40
  400592:	ea6f 0007 	mvn.w	r0, r7
  400596:	eb00 0108 	add.w	r1, r0, r8
  40059a:	f001 0501 	and.w	r5, r1, #1
  40059e:	eb09 0484 	add.w	r4, r9, r4, lsl #2
  4005a2:	f854 0f04 	ldr.w	r0, [r4, #4]!
  4005a6:	47b0      	blx	r6
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  4005a8:	f107 0701 	add.w	r7, r7, #1
  4005ac:	45b8      	cmp	r8, r7
  4005ae:	d80f      	bhi.n	4005d0 <ili9325_write_ram_buffer+0x100>
  4005b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4005b4:	f104 0504 	add.w	r5, r4, #4
		ili9325_write_ram(p_ul_buf[ul_addr]);
  4005b8:	6860      	ldr	r0, [r4, #4]
  4005ba:	47b0      	blx	r6
  4005bc:	f104 0408 	add.w	r4, r4, #8
  4005c0:	6868      	ldr	r0, [r5, #4]
  4005c2:	47b0      	blx	r6
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  4005c4:	f107 0702 	add.w	r7, r7, #2
  4005c8:	45b8      	cmp	r8, r7
  4005ca:	d8f3      	bhi.n	4005b4 <ili9325_write_ram_buffer+0xe4>
  4005cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4005d0:	2d00      	cmp	r5, #0
  4005d2:	d0ef      	beq.n	4005b4 <ili9325_write_ram_buffer+0xe4>
		ili9325_write_ram(p_ul_buf[ul_addr]);
  4005d4:	f854 0f04 	ldr.w	r0, [r4, #4]!
  4005d8:	47b0      	blx	r6
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
	}
	for (; ul_addr < ul_size; ul_addr++) {
  4005da:	f107 0701 	add.w	r7, r7, #1
  4005de:	45b8      	cmp	r8, r7
  4005e0:	d8e8      	bhi.n	4005b4 <ili9325_write_ram_buffer+0xe4>
  4005e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4005e6:	2e00      	cmp	r6, #0
  4005e8:	d0a0      	beq.n	40052c <ili9325_write_ram_buffer+0x5c>
static void ili9325_write_ram_buffer(const ili9325_color_t *p_ul_buf, uint32_t ul_size)
{
	uint32_t ul_addr;

	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
		ili9325_write_ram(p_ul_buf[ul_addr]);
  4005ea:	6828      	ldr	r0, [r5, #0]
  4005ec:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 1]);
  4005ee:	6868      	ldr	r0, [r5, #4]
  4005f0:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 2]);
  4005f2:	68a8      	ldr	r0, [r5, #8]
  4005f4:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 3]);
  4005f6:	68e8      	ldr	r0, [r5, #12]
  4005f8:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 4]);
  4005fa:	6928      	ldr	r0, [r5, #16]
  4005fc:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 5]);
  4005fe:	6968      	ldr	r0, [r5, #20]
  400600:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 6]);
  400602:	69a8      	ldr	r0, [r5, #24]
  400604:	47a0      	blx	r4
		ili9325_write_ram(p_ul_buf[ul_addr + 7]);
  400606:	69e8      	ldr	r0, [r5, #28]
  400608:	47a0      	blx	r4
 */
static void ili9325_write_ram_buffer(const ili9325_color_t *p_ul_buf, uint32_t ul_size)
{
	uint32_t ul_addr;

	for (ul_addr = 0; ul_addr < (ul_size - ul_size % 8); ul_addr += 8) {
  40060a:	f107 0708 	add.w	r7, r7, #8
  40060e:	f105 0520 	add.w	r5, r5, #32
  400612:	4557      	cmp	r7, sl
  400614:	d38a      	bcc.n	40052c <ili9325_write_ram_buffer+0x5c>
  400616:	e7b4      	b.n	400582 <ili9325_write_ram_buffer+0xb2>

00400618 <ili9325_write_register>:

/* Define EBI access for ILI9325 8-bit System Interface.*/
#if defined(BOARD_ILI9325_ADDR) && defined (BOARD_ILI9325_RS)
	static inline void LCD_IR(uint8_t lcd_index)
	{
		*((volatile uint8_t *)(BOARD_ILI9325_ADDR)) = lcd_index; /* ILI9325 index register address */
  400618:	f04f 43c2 	mov.w	r3, #1627389952	; 0x61000000
  40061c:	f04f 0200 	mov.w	r2, #0
  400620:	701a      	strb	r2, [r3, #0]
  400622:	7018      	strb	r0, [r3, #0]
 */
static void ili9325_write_register(uint8_t uc_reg, uint16_t us_data)
{
	LCD_IR(0);
	LCD_IR(uc_reg);
	LCD_WD((us_data >> 8) & 0xFF);
  400624:	ea4f 2011 	mov.w	r0, r1, lsr #8
	}
	static inline void LCD_WD(uint8_t lcd_data)
	{
		*((volatile uint8_t *)((BOARD_ILI9325_ADDR) | (BOARD_ILI9325_RS))) = lcd_data;
  400628:	f04f 0302 	mov.w	r3, #2
  40062c:	f2c6 1300 	movt	r3, #24832	; 0x6100
  400630:	7018      	strb	r0, [r3, #0]
	LCD_WD(us_data & 0xFF);
  400632:	b2c9      	uxtb	r1, r1
  400634:	7019      	strb	r1, [r3, #0]
  400636:	4770      	bx	lr

00400638 <ili9325_delay>:

/**
 * \brief Delay function.
 */
static void ili9325_delay(uint32_t ul_ms)
{
  400638:	b082      	sub	sp, #8
	volatile uint32_t i;

	for(i = 0; i < ul_ms; i++) {
  40063a:	f04f 0300 	mov.w	r3, #0
  40063e:	9301      	str	r3, [sp, #4]
  400640:	9901      	ldr	r1, [sp, #4]
  400642:	4288      	cmp	r0, r1
  400644:	d917      	bls.n	400676 <ili9325_delay+0x3e>
		for(i = 0; i < 100000; i++) {
  400646:	f04f 0100 	mov.w	r1, #0
  40064a:	f248 629f 	movw	r2, #34463	; 0x869f
  40064e:	f2c0 0201 	movt	r2, #1
  400652:	9101      	str	r1, [sp, #4]
  400654:	9b01      	ldr	r3, [sp, #4]
  400656:	4293      	cmp	r3, r2
  400658:	d806      	bhi.n	400668 <ili9325_delay+0x30>
  40065a:	9b01      	ldr	r3, [sp, #4]
  40065c:	f103 0301 	add.w	r3, r3, #1
  400660:	9301      	str	r3, [sp, #4]
  400662:	9b01      	ldr	r3, [sp, #4]
  400664:	4293      	cmp	r3, r2
  400666:	d9f8      	bls.n	40065a <ili9325_delay+0x22>
 */
static void ili9325_delay(uint32_t ul_ms)
{
	volatile uint32_t i;

	for(i = 0; i < ul_ms; i++) {
  400668:	9b01      	ldr	r3, [sp, #4]
  40066a:	f103 0301 	add.w	r3, r3, #1
  40066e:	9301      	str	r3, [sp, #4]
  400670:	9b01      	ldr	r3, [sp, #4]
  400672:	4283      	cmp	r3, r0
  400674:	d3ed      	bcc.n	400652 <ili9325_delay+0x1a>
		for(i = 0; i < 100000; i++) {
		}
	}
}
  400676:	b002      	add	sp, #8
  400678:	4770      	bx	lr
  40067a:	bf00      	nop

0040067c <ili9325_check_box_coordinates>:
 * \param p_ul_x2 X coordinate of lower-right corner on LCD.
 * \param p_ul_y2 Y coordinate of lower-right corner on LCD.
 */
static void ili9325_check_box_coordinates(uint32_t *p_ul_x1, uint32_t *p_ul_y1,
		uint32_t *p_ul_x2, uint32_t *p_ul_y2)
{
  40067c:	b430      	push	{r4, r5}
	uint32_t dw;

	if (*p_ul_x1 >= ILI9325_LCD_WIDTH) {
  40067e:	6804      	ldr	r4, [r0, #0]
  400680:	2cef      	cmp	r4, #239	; 0xef
		*p_ul_x1 = ILI9325_LCD_WIDTH - 1;
  400682:	bf84      	itt	hi
  400684:	24ef      	movhi	r4, #239	; 0xef
  400686:	6004      	strhi	r4, [r0, #0]
	}

	if (*p_ul_x2 >= ILI9325_LCD_WIDTH) {
  400688:	6815      	ldr	r5, [r2, #0]
  40068a:	2def      	cmp	r5, #239	; 0xef
		*p_ul_x2 = ILI9325_LCD_WIDTH - 1;
  40068c:	bf84      	itt	hi
  40068e:	25ef      	movhi	r5, #239	; 0xef
  400690:	6015      	strhi	r5, [r2, #0]
	}

	if (*p_ul_y1 >= ILI9325_LCD_HEIGHT) {
  400692:	680c      	ldr	r4, [r1, #0]
  400694:	f5b4 7fa0 	cmp.w	r4, #320	; 0x140
		*p_ul_y1 = ILI9325_LCD_HEIGHT - 1;
  400698:	bf24      	itt	cs
  40069a:	f240 143f 	movwcs	r4, #319	; 0x13f
  40069e:	600c      	strcs	r4, [r1, #0]
	}

	if (*p_ul_y2 >= ILI9325_LCD_HEIGHT) {
  4006a0:	681d      	ldr	r5, [r3, #0]
  4006a2:	f5b5 7fa0 	cmp.w	r5, #320	; 0x140
		*p_ul_y2 = ILI9325_LCD_HEIGHT - 1;
  4006a6:	bf24      	itt	cs
  4006a8:	f240 153f 	movwcs	r5, #319	; 0x13f
  4006ac:	601d      	strcs	r5, [r3, #0]
	}

	if (*p_ul_x1 > *p_ul_x2) {
  4006ae:	6804      	ldr	r4, [r0, #0]
  4006b0:	6815      	ldr	r5, [r2, #0]
  4006b2:	42ac      	cmp	r4, r5
		dw = *p_ul_x1;
		*p_ul_x1 = *p_ul_x2;
  4006b4:	bf84      	itt	hi
  4006b6:	6005      	strhi	r5, [r0, #0]
		*p_ul_x2 = dw;
  4006b8:	6014      	strhi	r4, [r2, #0]
	}

	if (*p_ul_y1 > *p_ul_y2) {
  4006ba:	680a      	ldr	r2, [r1, #0]
  4006bc:	6818      	ldr	r0, [r3, #0]
  4006be:	4282      	cmp	r2, r0
		dw = *p_ul_y1;
		*p_ul_y1 = *p_ul_y2;
  4006c0:	bf84      	itt	hi
  4006c2:	6008      	strhi	r0, [r1, #0]
		*p_ul_y2 = dw;
  4006c4:	601a      	strhi	r2, [r3, #0]
	}
}
  4006c6:	bc30      	pop	{r4, r5}
  4006c8:	4770      	bx	lr
  4006ca:	bf00      	nop

004006cc <ili9325_display_on>:

/**
 * \brief Turn on the LCD.
 */
void ili9325_display_on(void)
{
  4006cc:	b508      	push	{r3, lr}
	ili9325_write_register(ILI9325_DISP_CTRL1,
  4006ce:	f04f 0007 	mov.w	r0, #7
  4006d2:	f240 1133 	movw	r1, #307	; 0x133
  4006d6:	f240 6319 	movw	r3, #1561	; 0x619
  4006da:	f2c0 0340 	movt	r3, #64	; 0x40
  4006de:	4798      	blx	r3
  4006e0:	bd08      	pop	{r3, pc}
  4006e2:	bf00      	nop

004006e4 <ili9325_set_foreground_color>:
 * \brief Set foreground color.
 *
 * \param ul_color foreground color.
 */
void ili9325_set_foreground_color(ili9325_color_t ul_color)
{
  4006e4:	f640 0164 	movw	r1, #2148	; 0x864
  4006e8:	f2c2 0100 	movt	r1, #8192	; 0x2000
  4006ec:	f1a1 0304 	sub.w	r3, r1, #4
/**
 * \brief Set foreground color.
 *
 * \param ul_color foreground color.
 */
void ili9325_set_foreground_color(ili9325_color_t ul_color)
  4006f0:	f501 716f 	add.w	r1, r1, #956	; 0x3bc
  4006f4:	f103 0204 	add.w	r2, r3, #4
{
	uint32_t i;

	/* Fill the cache with selected color */
	for (i = 0; i < LCD_DATA_CACHE_SIZE; ++i) {
		g_ul_pixel_cache[i] = ul_color;
  4006f8:	6058      	str	r0, [r3, #4]
  4006fa:	f103 0308 	add.w	r3, r3, #8
  4006fe:	6050      	str	r0, [r2, #4]
void ili9325_set_foreground_color(ili9325_color_t ul_color)
{
	uint32_t i;

	/* Fill the cache with selected color */
	for (i = 0; i < LCD_DATA_CACHE_SIZE; ++i) {
  400700:	428b      	cmp	r3, r1
  400702:	d1f7      	bne.n	4006f4 <ili9325_set_foreground_color+0x10>
		g_ul_pixel_cache[i] = ul_color;
	}
}
  400704:	4770      	bx	lr
  400706:	bf00      	nop

00400708 <ili9325_set_window>:
 * \param ul_width The width of the window.
 * \param ul_height The height of the window.
 */
void ili9325_set_window(uint32_t ul_x, uint32_t ul_y, uint32_t ul_width,
		uint32_t ul_height)
{
  400708:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40070c:	460d      	mov	r5, r1
  40070e:	4690      	mov	r8, r2
  400710:	461f      	mov	r7, r3
	Assert(ul_y <= 0x13f);
	Assert(ul_width <= (0xF0 - ul_x));
	Assert(ul_height <= (0x140 - ul_y));

	/* Set Horizontal Address Start Position */
	ili9325_write_register(ILI9325_HORIZONTAL_ADDR_START, (uint16_t)ul_x);
  400712:	b286      	uxth	r6, r0
  400714:	f04f 0050 	mov.w	r0, #80	; 0x50
  400718:	4631      	mov	r1, r6
  40071a:	f240 6419 	movw	r4, #1561	; 0x619
  40071e:	f2c0 0440 	movt	r4, #64	; 0x40
  400722:	47a0      	blx	r4

	/* Set Horizontal Address End Position */
	ili9325_write_register(ILI9325_HORIZONTAL_ADDR_END, (uint16_t)(ul_x + ul_width - 1));
  400724:	f106 36ff 	add.w	r6, r6, #4294967295
  400728:	eb06 0108 	add.w	r1, r6, r8
  40072c:	f04f 0051 	mov.w	r0, #81	; 0x51
  400730:	b289      	uxth	r1, r1
  400732:	47a0      	blx	r4

	/* Set Vertical Address Start Position */
	ili9325_write_register(ILI9325_VERTICAL_ADDR_START, (uint16_t)ul_y);
  400734:	b2ad      	uxth	r5, r5
  400736:	f04f 0052 	mov.w	r0, #82	; 0x52
  40073a:	4629      	mov	r1, r5
  40073c:	47a0      	blx	r4

	/* Set Vertical Address End Position */
	ili9325_write_register(ILI9325_VERTICAL_ADDR_END, (uint16_t)(ul_y + ul_height - 1));
  40073e:	f105 35ff 	add.w	r5, r5, #4294967295
  400742:	19ea      	adds	r2, r5, r7
  400744:	f04f 0053 	mov.w	r0, #83	; 0x53
  400748:	b291      	uxth	r1, r2
  40074a:	47a0      	blx	r4
  40074c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00400750 <ili9325_set_cursor_position>:
 *
 * \param us_x X coordinate of upper-left corner on LCD.
 * \param us_y Y coordinate of upper-left corner on LCD.
 */
void ili9325_set_cursor_position(uint16_t us_x, uint16_t us_y)
{
  400750:	b538      	push	{r3, r4, r5, lr}
  400752:	4603      	mov	r3, r0
  400754:	460d      	mov	r5, r1
	/* GRAM Horizontal/Vertical Address Set (R20h, R21h) */
	ili9325_write_register(ILI9325_HORIZONTAL_GRAM_ADDR_SET, us_x); /* column */
  400756:	f04f 0020 	mov.w	r0, #32
  40075a:	4619      	mov	r1, r3
  40075c:	f240 6419 	movw	r4, #1561	; 0x619
  400760:	f2c0 0440 	movt	r4, #64	; 0x40
  400764:	47a0      	blx	r4
	ili9325_write_register(ILI9325_VERTICAL_GRAM_ADDR_SET, us_y); /* row */
  400766:	f04f 0021 	mov.w	r0, #33	; 0x21
  40076a:	4629      	mov	r1, r5
  40076c:	47a0      	blx	r4
  40076e:	bd38      	pop	{r3, r4, r5, pc}

00400770 <ili9325_init>:
 * \param p_opt pointer to ILI9325 option structure.
 *
 * \return 0 if initialization succeeds, otherwise fails.
 */
uint32_t ili9325_init(struct ili9325_opt_t *p_opt)
{
  400770:	b570      	push	{r4, r5, r6, lr}
  400772:	4605      	mov	r5, r0

/* Define EBI access for ILI9325 8-bit System Interface.*/
#if defined(BOARD_ILI9325_ADDR) && defined (BOARD_ILI9325_RS)
	static inline void LCD_IR(uint8_t lcd_index)
	{
		*((volatile uint8_t *)(BOARD_ILI9325_ADDR)) = lcd_index; /* ILI9325 index register address */
  400774:	f04f 43c2 	mov.w	r3, #1627389952	; 0x61000000
  400778:	f04f 0200 	mov.w	r2, #0
  40077c:	701a      	strb	r2, [r3, #0]
  40077e:	701a      	strb	r2, [r3, #0]
	{
		*((volatile uint8_t *)((BOARD_ILI9325_ADDR) | (BOARD_ILI9325_RS))) = lcd_data;
	}
	static inline uint8_t LCD_RD(void)
	{
		return *((volatile uint8_t *)((BOARD_ILI9325_ADDR) | (BOARD_ILI9325_RS)));
  400780:	f04f 0002 	mov.w	r0, #2
  400784:	f2c6 1000 	movt	r0, #24832	; 0x6100
  400788:	7801      	ldrb	r1, [r0, #0]
  40078a:	7803      	ldrb	r3, [r0, #0]
static uint16_t ili9325_lcd_get_16(void)
{
	uint16_t us_value;

	us_value = LCD_RD();
	us_value = (us_value << 8) | LCD_RD();
  40078c:	ea43 2201 	orr.w	r2, r3, r1, lsl #8
uint32_t ili9325_init(struct ili9325_opt_t *p_opt)
{
	/* Check ILI9325 chipid */
	uint16_t chipid = ili9325_read_register(ILI9325_DEVICE_CODE_REG); /* Driver Code Read (R00h) */

	if (chipid != ILI9325_DEVICE_CODE) {
  400790:	b210      	sxth	r0, r2
  400792:	f249 3125 	movw	r1, #37669	; 0x9325
  400796:	f6cf 71ff 	movt	r1, #65535	; 0xffff
  40079a:	4288      	cmp	r0, r1
  40079c:	f040 8110 	bne.w	4009c0 <ili9325_init+0x250>
		return 1;
	}

	/* Turn off LCD */
	ili9325_write_register(ILI9325_DISP_CTRL1, ILI9325_DISP_CTRL1_GON |
  4007a0:	f04f 0007 	mov.w	r0, #7
  4007a4:	f04f 0133 	mov.w	r1, #51	; 0x33
  4007a8:	f240 6419 	movw	r4, #1561	; 0x619
  4007ac:	f2c0 0440 	movt	r4, #64	; 0x40
  4007b0:	47a0      	blx	r4
			ILI9325_DISP_CTRL1_DTE | ILI9325_DISP_CTRL1_D(0x03));

	/* Start initial sequence */
	/* Disable sleep and standby mode*/
	ili9325_write_register(ILI9325_POWER_CTRL1, 0x0000);
  4007b2:	f04f 0010 	mov.w	r0, #16
  4007b6:	f04f 0100 	mov.w	r1, #0
  4007ba:	47a0      	blx	r4
	/* Start internal OSC */
	ili9325_write_register(ILI9325_START_OSC_CTRL, ILI9325_START_OSC_CTRL_EN);
  4007bc:	f04f 0000 	mov.w	r0, #0
  4007c0:	f04f 0101 	mov.w	r1, #1
  4007c4:	47a0      	blx	r4
	/* Set SS bit and direction output from S720 to S1 */
	ili9325_write_register(ILI9325_DRIVER_OUTPUT_CTRL1, ILI9325_DRIVER_OUTPUT_CTRL1_SS);
  4007c6:	f04f 0001 	mov.w	r0, #1
  4007ca:	f44f 7180 	mov.w	r1, #256	; 0x100
  4007ce:	47a0      	blx	r4
	/* Set 1 line inversion */
	ili9325_write_register(ILI9325_LCD_DRIVING_CTRL, ILI9325_LCD_DRIVING_CTRL_BIT10 |
  4007d0:	f04f 0002 	mov.w	r0, #2
  4007d4:	f44f 61e0 	mov.w	r1, #1792	; 0x700
  4007d8:	47a0      	blx	r4
			ILI9325_LCD_DRIVING_CTRL_EOR | ILI9325_LCD_DRIVING_CTRL_BC0);
	/* Disable resizing feature */
	ili9325_write_register(ILI9325_RESIZE_CTRL, 0x0000);
  4007da:	f04f 0004 	mov.w	r0, #4
  4007de:	f04f 0100 	mov.w	r1, #0
  4007e2:	47a0      	blx	r4
	/* Set the back porch and front porch */
	ili9325_write_register(ILI9325_DISP_CTRL2, ILI9325_DISP_CTRL2_BP(0x07) |
  4007e4:	f04f 0008 	mov.w	r0, #8
  4007e8:	f240 2107 	movw	r1, #519	; 0x207
  4007ec:	47a0      	blx	r4
			ILI9325_DISP_CTRL2_FP(0x02));
	/* Set non-display area refresh cycle ISC[3:0] */
	ili9325_write_register(ILI9325_DISP_CTRL3, 0x0000);
  4007ee:	f04f 0009 	mov.w	r0, #9
  4007f2:	f04f 0100 	mov.w	r1, #0
  4007f6:	47a0      	blx	r4
	/* Disable FMARK function */
	ili9325_write_register(ILI9325_DISP_CTRL4, 0x0000);
  4007f8:	f04f 000a 	mov.w	r0, #10
  4007fc:	f04f 0100 	mov.w	r1, #0
  400800:	47a0      	blx	r4
	/* 18-bit RGB interface and writing display data by the system interface */
	ili9325_write_register(ILI9325_RGB_DISP_INTERFACE_CTRL1, 0x0000);
  400802:	f04f 000c 	mov.w	r0, #12
  400806:	f04f 0100 	mov.w	r1, #0
  40080a:	47a0      	blx	r4
	/* Set the output position of frame cycle */
	ili9325_write_register(ILI9325_FRAME_MAKER_POS, 0x0000);
  40080c:	f04f 000d 	mov.w	r0, #13
  400810:	f04f 0100 	mov.w	r1, #0
  400814:	47a0      	blx	r4
	/* RGB interface polarity */
	ili9325_write_register(ILI9325_RGB_DISP_INTERFACE_CTRL2, 0x0000);
  400816:	f04f 000f 	mov.w	r0, #15
  40081a:	f04f 0100 	mov.w	r1, #0
  40081e:	47a0      	blx	r4

	/* Power on sequence */
	/* Disable sleep and standby mode */
	ili9325_write_register(ILI9325_POWER_CTRL1, 0x0000);
  400820:	f04f 0010 	mov.w	r0, #16
  400824:	f04f 0100 	mov.w	r1, #0
  400828:	47a0      	blx	r4
	/* Selects the operating frequency of the step-up circuit 1,2 and Sets the ratio factor of Vci */
	ili9325_write_register(ILI9325_POWER_CTRL2, 0x0000);
  40082a:	f04f 0011 	mov.w	r0, #17
  40082e:	f04f 0100 	mov.w	r1, #0
  400832:	47a0      	blx	r4
	/* Set VREG1OUT voltage */
	ili9325_write_register(ILI9325_POWER_CTRL3, 0x0000);
  400834:	f04f 0012 	mov.w	r0, #18
  400838:	f04f 0100 	mov.w	r1, #0
  40083c:	47a0      	blx	r4
	/* Set VCOM amplitude */
	ili9325_write_register(ILI9325_POWER_CTRL4, 0x0000);
  40083e:	f04f 0013 	mov.w	r0, #19
  400842:	f04f 0100 	mov.w	r1, #0
  400846:	47a0      	blx	r4
	ili9325_delay(200);
  400848:	f04f 00c8 	mov.w	r0, #200	; 0xc8
  40084c:	f240 6639 	movw	r6, #1593	; 0x639
  400850:	f2c0 0640 	movt	r6, #64	; 0x40
  400854:	47b0      	blx	r6

	/* Enable power supply and source driver */
	/* Adjusts the constant current and Sets the factor used in the step-up circuits.*/
	ili9325_write_register(ILI9325_POWER_CTRL1, ILI9325_POWER_CTRL1_SAP |
  400856:	f04f 0010 	mov.w	r0, #16
  40085a:	f241 2190 	movw	r1, #4752	; 0x1290
  40085e:	47a0      	blx	r4
			ILI9325_POWER_CTRL1_BT(0x02) | ILI9325_POWER_CTRL1_APE | ILI9325_POWER_CTRL1_AP(0x01));
	/* Select the operating frequency of the step-up circuit 1,2 and Sets the ratio factor of Vci */
	ili9325_write_register(ILI9325_POWER_CTRL2, ILI9325_POWER_CTRL2_DC1(0x02) |
  400860:	f04f 0011 	mov.w	r0, #17
  400864:	f240 2127 	movw	r1, #551	; 0x227
  400868:	47a0      	blx	r4
			ILI9325_POWER_CTRL2_DC0(0x02) | ILI9325_POWER_CTRL2_VC(0x07));
	ili9325_delay(50);
  40086a:	f04f 0032 	mov.w	r0, #50	; 0x32
  40086e:	47b0      	blx	r6
	/* Internal reference voltage= Vci */
	ili9325_write_register(ILI9325_POWER_CTRL3, ILI9325_POWER_CTRL3_PON |
  400870:	f04f 0012 	mov.w	r0, #18
  400874:	f04f 011b 	mov.w	r1, #27
  400878:	47a0      	blx	r4
			ILI9325_POWER_CTRL3_VRH(0x0B));
	ili9325_delay(50);
  40087a:	f04f 0032 	mov.w	r0, #50	; 0x32
  40087e:	47b0      	blx	r6
	/* Set VDV[4:0] for VCOM amplitude */
	ili9325_write_register(ILI9325_POWER_CTRL4, ILI9325_POWER_CTRL4_VDV(0x11));
  400880:	f04f 0013 	mov.w	r0, #19
  400884:	f44f 5188 	mov.w	r1, #4352	; 0x1100
  400888:	47a0      	blx	r4
	/* Set VCM[5:0] for VCOMH */
	ili9325_write_register(ILI9325_POWER_CTRL7, ILI9325_POWER_CTRL7_VCM(0x19));
  40088a:	f04f 0029 	mov.w	r0, #41	; 0x29
  40088e:	f04f 0119 	mov.w	r1, #25
  400892:	47a0      	blx	r4
	/* Set Frame Rate */
	ili9325_write_register(ILI9325_FRAME_RATE_AND_COLOR_CTRL,
  400894:	f04f 002b 	mov.w	r0, #43	; 0x2b
  400898:	f04f 010d 	mov.w	r1, #13
  40089c:	47a0      	blx	r4
			ILI9325_FRAME_RATE_AND_COLOR_CTRL_FRS(0x0D));
	ili9325_delay(50);
  40089e:	f04f 0032 	mov.w	r0, #50	; 0x32
  4008a2:	47b0      	blx	r6

	/* Adjust the Gamma Curve */
	ili9325_write_register(ILI9325_GAMMA_CTRL1, 0x0000);
  4008a4:	f04f 0030 	mov.w	r0, #48	; 0x30
  4008a8:	f04f 0100 	mov.w	r1, #0
  4008ac:	47a0      	blx	r4
	ili9325_write_register(ILI9325_GAMMA_CTRL2, ILI9325_GAMMA_CTRL2_KP3(0x02) |
  4008ae:	f04f 0031 	mov.w	r0, #49	; 0x31
  4008b2:	f44f 7101 	mov.w	r1, #516	; 0x204
  4008b6:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL2_KP2(0x04));
	ili9325_write_register(ILI9325_GAMMA_CTRL3, ILI9325_GAMMA_CTRL3_KP5(0x02) |
  4008b8:	f04f 0032 	mov.w	r0, #50	; 0x32
  4008bc:	f44f 7100 	mov.w	r1, #512	; 0x200
  4008c0:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL3_KP4(0x00));
	ili9325_write_register(ILI9325_GAMMA_CTRL4, ILI9325_GAMMA_CTRL4_RP1(0x00) |
  4008c2:	f04f 0035 	mov.w	r0, #53	; 0x35
  4008c6:	f04f 0107 	mov.w	r1, #7
  4008ca:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL4_RP0(0x07));
	ili9325_write_register(ILI9325_GAMMA_CTRL5, ILI9325_GAMMA_CTRL5_VRP1(0x14) |
  4008cc:	f04f 0036 	mov.w	r0, #54	; 0x36
  4008d0:	f241 4104 	movw	r1, #5124	; 0x1404
  4008d4:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL5_VRP0(0x04));
	ili9325_write_register(ILI9325_GAMMA_CTRL6, ILI9325_GAMMA_CTRL6_KN1(0x07) |
  4008d6:	f04f 0037 	mov.w	r0, #55	; 0x37
  4008da:	f240 7105 	movw	r1, #1797	; 0x705
  4008de:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL6_KN0(0x05));
	ili9325_write_register(ILI9325_GAMMA_CTRL7, ILI9325_GAMMA_CTRL7_KN3(0x03) |
  4008e0:	f04f 0038 	mov.w	r0, #56	; 0x38
  4008e4:	f240 3105 	movw	r1, #773	; 0x305
  4008e8:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL7_KN2(0x05));
	ili9325_write_register(ILI9325_GAMMA_CTRL8, ILI9325_GAMMA_CTRL8_KN5(0x07) |
  4008ea:	f04f 0039 	mov.w	r0, #57	; 0x39
  4008ee:	f240 7107 	movw	r1, #1799	; 0x707
  4008f2:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL8_KN4(0x07));
	ili9325_write_register(ILI9325_GAMMA_CTRL9, ILI9325_GAMMA_CTRL9_RN1(0x07) |
  4008f4:	f04f 003c 	mov.w	r0, #60	; 0x3c
  4008f8:	f240 7101 	movw	r1, #1793	; 0x701
  4008fc:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL9_RN0(0x01));
	ili9325_write_register(ILI9325_GAMMA_CTRL10, ILI9325_GAMMA_CTRL10_VRN1(0x00) |
  4008fe:	f04f 003d 	mov.w	r0, #61	; 0x3d
  400902:	f04f 010e 	mov.w	r1, #14
  400906:	47a0      	blx	r4
			ILI9325_GAMMA_CTRL10_VRN0(0x0E));
	/* Use the high speed write mode (HWM=1) */
	/* When TRI = 1, data are transferred to the internal RAM in 8-bit x 3 transfers mode via the 8-bit interface. */
	/* DFM Set the mode of transferring data to the internal RAM when TRI = 1. */
	/* I/D[1:0] = 11 Horizontal : increment Vertical : increment, AM=0:Horizontal */
	ili9325_write_register(ILI9325_ENTRY_MODE, ILI9325_ENTRY_MODE_TRI |
  400908:	f04f 0003 	mov.w	r0, #3
  40090c:	f24d 0110 	movw	r1, #53264	; 0xd010
  400910:	47a0      	blx	r4
			ILI9325_ENTRY_MODE_DFM | ILI9325_ENTRY_MODE_ID(0x01) |ILI9325_ENTRY_MODE_BGR);
	/* Sets the number of lines to drive the LCD at an interval of 8 lines. */
	/* The scan direction is from G320 to G1 */
	ili9325_write_register(ILI9325_DRIVER_OUTPUT_CTRL2, ILI9325_DRIVER_OUTPUT_CTRL2_GS |
  400912:	f04f 0060 	mov.w	r0, #96	; 0x60
  400916:	f44f 4127 	mov.w	r1, #42752	; 0xa700
  40091a:	47a0      	blx	r4
			ILI9325_DRIVER_OUTPUT_CTRL2_NL(0x27));

	/* Vertical Scrolling */
	/* Disable scrolling and enable the grayscale inversion */
	ili9325_write_register(ILI9325_BASE_IMG_DISP_CTRL, ILI9325_BASE_IMG_DISP_CTRL_REV);
  40091c:	f04f 0061 	mov.w	r0, #97	; 0x61
  400920:	f04f 0101 	mov.w	r1, #1
  400924:	47a0      	blx	r4
	ili9325_write_register(ILI9325_VERTICAL_SCROLL_CTRL, 0x0000);
  400926:	f04f 006a 	mov.w	r0, #106	; 0x6a
  40092a:	f04f 0100 	mov.w	r1, #0
  40092e:	47a0      	blx	r4

	/* Disable Partial Display */
	ili9325_write_register(ILI9325_PARTIAL_IMG1_DISP_POS, 0x0000);
  400930:	f04f 0080 	mov.w	r0, #128	; 0x80
  400934:	f04f 0100 	mov.w	r1, #0
  400938:	47a0      	blx	r4
	ili9325_write_register(ILI9325_PARTIAL_IMG1_AREA_START_LINE, 0x0000);
  40093a:	f04f 0081 	mov.w	r0, #129	; 0x81
  40093e:	f04f 0100 	mov.w	r1, #0
  400942:	47a0      	blx	r4
	ili9325_write_register(ILI9325_PARTIAL_IMG1_AREA_END_LINE, 0x0000);
  400944:	f04f 0082 	mov.w	r0, #130	; 0x82
  400948:	f04f 0100 	mov.w	r1, #0
  40094c:	47a0      	blx	r4
	ili9325_write_register(ILI9325_PARTIAL_IMG2_DISP_POS, 0x0000);
  40094e:	f04f 0083 	mov.w	r0, #131	; 0x83
  400952:	f04f 0100 	mov.w	r1, #0
  400956:	47a0      	blx	r4
	ili9325_write_register(ILI9325_PARTIAL_IMG2_AREA_START_LINE, 0x0000);
  400958:	f04f 0084 	mov.w	r0, #132	; 0x84
  40095c:	f04f 0100 	mov.w	r1, #0
  400960:	47a0      	blx	r4
	ili9325_write_register(ILI9325_PARTIAL_IMG2_AREA_END_LINE, 0x0000);
  400962:	f04f 0085 	mov.w	r0, #133	; 0x85
  400966:	f04f 0100 	mov.w	r1, #0
  40096a:	47a0      	blx	r4

	/* Panel Control */
	ili9325_write_register(ILI9325_PANEL_INTERFACE_CTRL1,
  40096c:	f04f 0090 	mov.w	r0, #144	; 0x90
  400970:	f04f 0110 	mov.w	r1, #16
  400974:	47a0      	blx	r4
			ILI9325_PANEL_INTERFACE_CTRL1_RTNI(0x10));
	ili9325_write_register(ILI9325_PANEL_INTERFACE_CTRL2,
  400976:	f04f 0092 	mov.w	r0, #146	; 0x92
  40097a:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  40097e:	47a0      	blx	r4
			ILI9325_PANEL_INTERFACE_CTRL2_NOWI(0x06));
	ili9325_write_register(ILI9325_PANEL_INTERFACE_CTRL4,
  400980:	f04f 0095 	mov.w	r0, #149	; 0x95
  400984:	f44f 7188 	mov.w	r1, #272	; 0x110
  400988:	47a0      	blx	r4
			ILI9325_PANEL_INTERFACE_CTRL4_DIVE(0x01) |
			ILI9325_PANEL_INTERFACE_CTRL4_RTNE(0x10));

	ili9325_set_window(0, 0,p_opt->ul_width,p_opt->ul_height);
  40098a:	f04f 0000 	mov.w	r0, #0
  40098e:	4601      	mov	r1, r0
  400990:	682a      	ldr	r2, [r5, #0]
  400992:	686b      	ldr	r3, [r5, #4]
  400994:	f240 7409 	movw	r4, #1801	; 0x709
  400998:	f2c0 0440 	movt	r4, #64	; 0x40
  40099c:	47a0      	blx	r4
	ili9325_set_foreground_color(p_opt->foreground_color);
  40099e:	68a8      	ldr	r0, [r5, #8]
  4009a0:	f240 63e5 	movw	r3, #1765	; 0x6e5
  4009a4:	f2c0 0340 	movt	r3, #64	; 0x40
  4009a8:	4798      	blx	r3
	ili9325_set_cursor_position(0, 0);
  4009aa:	f04f 0000 	mov.w	r0, #0
  4009ae:	4601      	mov	r1, r0
  4009b0:	f240 7251 	movw	r2, #1873	; 0x751
  4009b4:	f2c0 0240 	movt	r2, #64	; 0x40
  4009b8:	4790      	blx	r2
	return 0;
  4009ba:	f04f 0000 	mov.w	r0, #0
  4009be:	bd70      	pop	{r4, r5, r6, pc}
{
	/* Check ILI9325 chipid */
	uint16_t chipid = ili9325_read_register(ILI9325_DEVICE_CODE_REG); /* Driver Code Read (R00h) */

	if (chipid != ILI9325_DEVICE_CODE) {
		return 1;
  4009c0:	f04f 0001 	mov.w	r0, #1

	ili9325_set_window(0, 0,p_opt->ul_width,p_opt->ul_height);
	ili9325_set_foreground_color(p_opt->foreground_color);
	ili9325_set_cursor_position(0, 0);
	return 0;
}
  4009c4:	bd70      	pop	{r4, r5, r6, pc}
  4009c6:	bf00      	nop

004009c8 <ili9325_draw_pixel>:
 * \param ul_y Y coordinate of pixel.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili9325_draw_pixel(uint32_t ul_x, uint32_t ul_y)
{
  4009c8:	b508      	push	{r3, lr}
	if ((ul_x >= ILI9325_LCD_WIDTH) || (ul_y >= ILI9325_LCD_HEIGHT)) {
  4009ca:	28ef      	cmp	r0, #239	; 0xef
  4009cc:	d81b      	bhi.n	400a06 <ili9325_draw_pixel+0x3e>
  4009ce:	f5b1 7fa0 	cmp.w	r1, #320	; 0x140
  4009d2:	d21b      	bcs.n	400a0c <ili9325_draw_pixel+0x44>
		return 1;
	}

	/* Set cursor */
	ili9325_set_cursor_position(ul_x, ul_y);
  4009d4:	b280      	uxth	r0, r0
  4009d6:	b289      	uxth	r1, r1
  4009d8:	f240 7351 	movw	r3, #1873	; 0x751
  4009dc:	f2c0 0340 	movt	r3, #64	; 0x40
  4009e0:	4798      	blx	r3

	/* Prepare to write in GRAM */
	ili9325_write_ram_prepare();
  4009e2:	f240 40a1 	movw	r0, #1185	; 0x4a1
  4009e6:	f2c0 0040 	movt	r0, #64	; 0x40
  4009ea:	4780      	blx	r0
	ili9325_write_ram(*g_ul_pixel_cache);
  4009ec:	f640 0164 	movw	r1, #2148	; 0x864
  4009f0:	f2c2 0100 	movt	r1, #8192	; 0x2000
  4009f4:	6808      	ldr	r0, [r1, #0]
  4009f6:	f240 42b5 	movw	r2, #1205	; 0x4b5
  4009fa:	f2c0 0240 	movt	r2, #64	; 0x40
  4009fe:	4790      	blx	r2
	return 0;
  400a00:	f04f 0000 	mov.w	r0, #0
  400a04:	bd08      	pop	{r3, pc}
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili9325_draw_pixel(uint32_t ul_x, uint32_t ul_y)
{
	if ((ul_x >= ILI9325_LCD_WIDTH) || (ul_y >= ILI9325_LCD_HEIGHT)) {
		return 1;
  400a06:	f04f 0001 	mov.w	r0, #1
  400a0a:	bd08      	pop	{r3, pc}
  400a0c:	f04f 0001 	mov.w	r0, #1

	/* Prepare to write in GRAM */
	ili9325_write_ram_prepare();
	ili9325_write_ram(*g_ul_pixel_cache);
	return 0;
}
  400a10:	bd08      	pop	{r3, pc}
  400a12:	bf00      	nop

00400a14 <ili9325_draw_filled_rectangle>:
 * \param ul_x2 X coordinate of lower-right corner on LCD.
 * \param ul_y2 Y coordinate of lower-right corner on LCD.
 */
void ili9325_draw_filled_rectangle(uint32_t ul_x1, uint32_t ul_y1,
		uint32_t ul_x2, uint32_t ul_y2)
{
  400a14:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  400a18:	b085      	sub	sp, #20
  400a1a:	9003      	str	r0, [sp, #12]
  400a1c:	9102      	str	r1, [sp, #8]
  400a1e:	9201      	str	r2, [sp, #4]
  400a20:	9300      	str	r3, [sp, #0]
	uint32_t size, blocks;

	/* Swap coordinates if necessary */
	ili9325_check_box_coordinates(&ul_x1, &ul_y1, &ul_x2, &ul_y2);
  400a22:	a803      	add	r0, sp, #12
  400a24:	a902      	add	r1, sp, #8
  400a26:	aa01      	add	r2, sp, #4
  400a28:	466b      	mov	r3, sp
  400a2a:	f240 647d 	movw	r4, #1661	; 0x67d
  400a2e:	f2c0 0440 	movt	r4, #64	; 0x40
  400a32:	47a0      	blx	r4

	/* Determine the refresh window area */
	ili9325_set_window(ul_x1, ul_y1, (ul_x2 - ul_x1) + 1, (ul_y2 - ul_y1) + 1);
  400a34:	9a03      	ldr	r2, [sp, #12]
  400a36:	9b02      	ldr	r3, [sp, #8]
  400a38:	9901      	ldr	r1, [sp, #4]
  400a3a:	f101 0501 	add.w	r5, r1, #1
  400a3e:	9800      	ldr	r0, [sp, #0]
  400a40:	f100 0401 	add.w	r4, r0, #1
  400a44:	4610      	mov	r0, r2
  400a46:	4619      	mov	r1, r3
  400a48:	1aaa      	subs	r2, r5, r2
  400a4a:	1ae3      	subs	r3, r4, r3
  400a4c:	f240 7409 	movw	r4, #1801	; 0x709
  400a50:	f2c0 0440 	movt	r4, #64	; 0x40
  400a54:	47a0      	blx	r4

	/* Set cursor */
	ili9325_set_cursor_position(ul_x1, ul_y1);
  400a56:	f8bd 000c 	ldrh.w	r0, [sp, #12]
  400a5a:	f8bd 1008 	ldrh.w	r1, [sp, #8]
  400a5e:	f240 7251 	movw	r2, #1873	; 0x751
  400a62:	f2c0 0240 	movt	r2, #64	; 0x40
  400a66:	4790      	blx	r2

	/* Prepare to write in GRAM */
	ili9325_write_ram_prepare();
  400a68:	f240 43a1 	movw	r3, #1185	; 0x4a1
  400a6c:	f2c0 0340 	movt	r3, #64	; 0x40
  400a70:	4798      	blx	r3

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);
  400a72:	9902      	ldr	r1, [sp, #8]
  400a74:	9800      	ldr	r0, [sp, #0]
  400a76:	1a44      	subs	r4, r0, r1
  400a78:	9a01      	ldr	r2, [sp, #4]
  400a7a:	f102 0801 	add.w	r8, r2, #1
  400a7e:	9b03      	ldr	r3, [sp, #12]
  400a80:	ebc3 0108 	rsb	r1, r3, r8
  400a84:	fb04 1801 	mla	r8, r4, r1, r1
	/* Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
  400a88:	f648 0089 	movw	r0, #34953	; 0x8889
  400a8c:	f6c8 0088 	movt	r0, #34952	; 0x8888
  400a90:	fba0 2408 	umull	r2, r4, r0, r8
	while (blocks--) {
  400a94:	09e4      	lsrs	r4, r4, #7
  400a96:	d01d      	beq.n	400ad4 <ili9325_draw_filled_rectangle+0xc0>
		ili9325_write_ram_buffer(g_ul_pixel_cache, LCD_DATA_CACHE_SIZE);
  400a98:	f640 0764 	movw	r7, #2148	; 0x864
  400a9c:	f2c2 0700 	movt	r7, #8192	; 0x2000
  400aa0:	f04f 06f0 	mov.w	r6, #240	; 0xf0
  400aa4:	f240 45d1 	movw	r5, #1233	; 0x4d1
  400aa8:	f2c0 0540 	movt	r5, #64	; 0x40
  400aac:	f104 32ff 	add.w	r2, r4, #4294967295
  400ab0:	f002 0901 	and.w	r9, r2, #1
  400ab4:	4638      	mov	r0, r7
  400ab6:	4631      	mov	r1, r6
  400ab8:	47a8      	blx	r5
	ili9325_write_ram_prepare();

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);
	/* Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
  400aba:	3c01      	subs	r4, #1
  400abc:	d12e      	bne.n	400b1c <ili9325_draw_filled_rectangle+0x108>
  400abe:	e009      	b.n	400ad4 <ili9325_draw_filled_rectangle+0xc0>
		ili9325_write_ram_buffer(g_ul_pixel_cache, LCD_DATA_CACHE_SIZE);
  400ac0:	4638      	mov	r0, r7
  400ac2:	4631      	mov	r1, r6
  400ac4:	47a8      	blx	r5
  400ac6:	f104 34ff 	add.w	r4, r4, #4294967295
  400aca:	4638      	mov	r0, r7
  400acc:	4631      	mov	r1, r6
  400ace:	47a8      	blx	r5
	ili9325_write_ram_prepare();

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);
	/* Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
  400ad0:	3c01      	subs	r4, #1
  400ad2:	d1f5      	bne.n	400ac0 <ili9325_draw_filled_rectangle+0xac>
		ili9325_write_ram_buffer(g_ul_pixel_cache, LCD_DATA_CACHE_SIZE);
	}
	/* Send remaining pixels */
	ili9325_write_ram_buffer(g_ul_pixel_cache, size % LCD_DATA_CACHE_SIZE);
  400ad4:	f648 0389 	movw	r3, #34953	; 0x8889
  400ad8:	f6c8 0388 	movt	r3, #34952	; 0x8888
  400adc:	fba3 2108 	umull	r2, r1, r3, r8
  400ae0:	ea4f 10d1 	mov.w	r0, r1, lsr #7
  400ae4:	ebc0 1200 	rsb	r2, r0, r0, lsl #4
  400ae8:	f640 0064 	movw	r0, #2148	; 0x864
  400aec:	f2c2 0000 	movt	r0, #8192	; 0x2000
  400af0:	eba8 1102 	sub.w	r1, r8, r2, lsl #4
  400af4:	f240 44d1 	movw	r4, #1233	; 0x4d1
  400af8:	f2c0 0440 	movt	r4, #64	; 0x40
  400afc:	47a0      	blx	r4

	/* Reset the refresh window area */
	ili9325_set_window(0, 0, ILI9325_LCD_WIDTH, ILI9325_LCD_HEIGHT);
  400afe:	f04f 0000 	mov.w	r0, #0
  400b02:	4601      	mov	r1, r0
  400b04:	f04f 02f0 	mov.w	r2, #240	; 0xf0
  400b08:	f44f 73a0 	mov.w	r3, #320	; 0x140
  400b0c:	f240 7409 	movw	r4, #1801	; 0x709
  400b10:	f2c0 0440 	movt	r4, #64	; 0x40
  400b14:	47a0      	blx	r4
}
  400b16:	b005      	add	sp, #20
  400b18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  400b1c:	f1b9 0f00 	cmp.w	r9, #0
  400b20:	d0ce      	beq.n	400ac0 <ili9325_draw_filled_rectangle+0xac>

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);
	/* Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
		ili9325_write_ram_buffer(g_ul_pixel_cache, LCD_DATA_CACHE_SIZE);
  400b22:	4638      	mov	r0, r7
  400b24:	4631      	mov	r1, r6
  400b26:	47a8      	blx	r5
	ili9325_write_ram_prepare();

	size = (ul_x2 - ul_x1 + 1) * (ul_y2 - ul_y1 + 1);
	/* Send pixels blocks => one SPI IT / block */
	blocks = size / LCD_DATA_CACHE_SIZE;
	while (blocks--) {
  400b28:	3c01      	subs	r4, #1
  400b2a:	d1c9      	bne.n	400ac0 <ili9325_draw_filled_rectangle+0xac>
  400b2c:	e7d2      	b.n	400ad4 <ili9325_draw_filled_rectangle+0xc0>
  400b2e:	bf00      	nop

00400b30 <ili9325_draw_line>:
 * \param ul_x2 X coordinate of line end.
 * \param ul_y2 Y coordinate of line end.
 */
void ili9325_draw_line(uint32_t ul_x1, uint32_t ul_y1,
		uint32_t ul_x2, uint32_t ul_y2)
{
  400b30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400b34:	b083      	sub	sp, #12
  400b36:	4682      	mov	sl, r0
  400b38:	4689      	mov	r9, r1
	if ((ul_y1 == ul_y2) || (ul_x1 == ul_x2)) {
  400b3a:	4299      	cmp	r1, r3
  400b3c:	d001      	beq.n	400b42 <ili9325_draw_line+0x12>
  400b3e:	4290      	cmp	r0, r2
  400b40:	d107      	bne.n	400b52 <ili9325_draw_line+0x22>
		ili9325_draw_filled_rectangle(ul_x1, ul_y1, ul_x2, ul_y2);
  400b42:	4650      	mov	r0, sl
  400b44:	4649      	mov	r1, r9
  400b46:	f640 2415 	movw	r4, #2581	; 0xa15
  400b4a:	f2c0 0440 	movt	r4, #64	; 0x40
  400b4e:	47a0      	blx	r4
  400b50:	e068      	b.n	400c24 <ili9325_draw_line+0xf4>
	int dx, dy;
	int i;
	int xinc, yinc, cumul;
	int x, y;

	x = ul_x1;
  400b52:	4680      	mov	r8, r0
	y = ul_y1;
  400b54:	460f      	mov	r7, r1
	dx = ul_x2 - ul_x1;
  400b56:	1a15      	subs	r5, r2, r0
	dy = ul_y2 - ul_y1;
  400b58:	1a5c      	subs	r4, r3, r1
	xinc = (dx > 0) ? 1 : -1;
  400b5a:	2d00      	cmp	r5, #0
  400b5c:	bfd4      	ite	le
  400b5e:	f04f 33ff 	movle.w	r3, #4294967295
  400b62:	2301      	movgt	r3, #1
  400b64:	9300      	str	r3, [sp, #0]
	yinc = (dy > 0) ? 1 : -1;
  400b66:	2c00      	cmp	r4, #0
  400b68:	bfd4      	ite	le
  400b6a:	f04f 30ff 	movle.w	r0, #4294967295
  400b6e:	2001      	movgt	r0, #1
  400b70:	9001      	str	r0, [sp, #4]
	dx = abs(ul_x2 - ul_x1);
  400b72:	2d00      	cmp	r5, #0
  400b74:	bfb8      	it	lt
  400b76:	426d      	neglt	r5, r5
	dy = abs(ul_y2 - ul_y1);
  400b78:	2c00      	cmp	r4, #0
  400b7a:	bfb8      	it	lt
  400b7c:	4264      	neglt	r4, r4

	ili9325_draw_pixel(x, y);
  400b7e:	4650      	mov	r0, sl
  400b80:	f640 12c9 	movw	r2, #2505	; 0x9c9
  400b84:	f2c0 0240 	movt	r2, #64	; 0x40
  400b88:	4790      	blx	r2

	if (dx > dy) {
  400b8a:	42a5      	cmp	r5, r4
  400b8c:	dd26      	ble.n	400bdc <ili9325_draw_line+0xac>
		cumul = dx >> 1;
  400b8e:	ea4f 0665 	mov.w	r6, r5, asr #1

		for (i = 1; i <= dx; i++) {
  400b92:	2d00      	cmp	r5, #0
  400b94:	dd46      	ble.n	400c24 <ili9325_draw_line+0xf4>
 * \param ul_x1 X coordinate of line start.
 * \param ul_y1 Y coordinate of line start.
 * \param ul_x2 X coordinate of line end.
 * \param ul_y2 Y coordinate of line end.
 */
void ili9325_draw_line(uint32_t ul_x1, uint32_t ul_y1,
  400b96:	f8dd b000 	ldr.w	fp, [sp]
  400b9a:	eb0a 090b 	add.w	r9, sl, fp
	ili9325_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  400b9e:	f04f 0801 	mov.w	r8, #1
			if (cumul >= dx) {
				cumul -= dx;
				y += yinc;
			}

			ili9325_draw_pixel(x, y);
  400ba2:	f640 1ac9 	movw	sl, #2505	; 0x9c9
  400ba6:	f2c0 0a40 	movt	sl, #64	; 0x40
  400baa:	ebc8 0005 	rsb	r0, r8, r5
  400bae:	ea00 0208 	and.w	r2, r0, r8
  400bb2:	9200      	str	r2, [sp, #0]
	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
			x += xinc;
			cumul += dy;
  400bb4:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  400bb6:	42b5      	cmp	r5, r6
  400bb8:	dc3a      	bgt.n	400c30 <ili9325_draw_line+0x100>
  400bba:	e036      	b.n	400c2a <ili9325_draw_line+0xfa>
	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
			x += xinc;
			cumul += dy;
  400bbc:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  400bbe:	42b5      	cmp	r5, r6
  400bc0:	dc02      	bgt.n	400bc8 <ili9325_draw_line+0x98>
				cumul -= dx;
  400bc2:	1b76      	subs	r6, r6, r5
				y += yinc;
  400bc4:	9a01      	ldr	r2, [sp, #4]
  400bc6:	18bf      	adds	r7, r7, r2
			}

			ili9325_draw_pixel(x, y);
  400bc8:	4648      	mov	r0, r9
  400bca:	4639      	mov	r1, r7
  400bcc:	47d0      	blx	sl
	ili9325_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  400bce:	f108 0801 	add.w	r8, r8, #1
  400bd2:	44d9      	add	r9, fp
			x += xinc;
			cumul += dy;
  400bd4:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  400bd6:	42b5      	cmp	r5, r6
  400bd8:	dc47      	bgt.n	400c6a <ili9325_draw_line+0x13a>
  400bda:	e043      	b.n	400c64 <ili9325_draw_line+0x134>
			}

			ili9325_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;
  400bdc:	ea4f 0664 	mov.w	r6, r4, asr #1

		for (i = 1; i <= dy; i++) {
  400be0:	2c00      	cmp	r4, #0
  400be2:	dd1f      	ble.n	400c24 <ili9325_draw_line+0xf4>
 * \param ul_x1 X coordinate of line start.
 * \param ul_y1 Y coordinate of line start.
 * \param ul_x2 X coordinate of line end.
 * \param ul_y2 Y coordinate of line end.
 */
void ili9325_draw_line(uint32_t ul_x1, uint32_t ul_y1,
  400be4:	f8dd b004 	ldr.w	fp, [sp, #4]
  400be8:	44d9      	add	r9, fp
			ili9325_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  400bea:	f04f 0701 	mov.w	r7, #1
			if (cumul >= dy) {
				cumul -= dy;
				x += xinc;
			}

			ili9325_draw_pixel(x, y);
  400bee:	f640 1ac9 	movw	sl, #2505	; 0x9c9
  400bf2:	f2c0 0a40 	movt	sl, #64	; 0x40
  400bf6:	1be1      	subs	r1, r4, r7
  400bf8:	4039      	ands	r1, r7
  400bfa:	9101      	str	r1, [sp, #4]
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
			y += yinc;
			cumul += dx;
  400bfc:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  400bfe:	42b4      	cmp	r4, r6
  400c00:	dc3f      	bgt.n	400c82 <ili9325_draw_line+0x152>
  400c02:	e03b      	b.n	400c7c <ili9325_draw_line+0x14c>
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
			y += yinc;
			cumul += dx;
  400c04:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  400c06:	42b4      	cmp	r4, r6
  400c08:	dc02      	bgt.n	400c10 <ili9325_draw_line+0xe0>
				cumul -= dy;
  400c0a:	1b36      	subs	r6, r6, r4
				x += xinc;
  400c0c:	9900      	ldr	r1, [sp, #0]
  400c0e:	4488      	add	r8, r1
			}

			ili9325_draw_pixel(x, y);
  400c10:	4640      	mov	r0, r8
  400c12:	4649      	mov	r1, r9
  400c14:	47d0      	blx	sl
			ili9325_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  400c16:	f107 0701 	add.w	r7, r7, #1
  400c1a:	44d9      	add	r9, fp
			y += yinc;
			cumul += dx;
  400c1c:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  400c1e:	42b4      	cmp	r4, r6
  400c20:	dc4c      	bgt.n	400cbc <ili9325_draw_line+0x18c>
  400c22:	e048      	b.n	400cb6 <ili9325_draw_line+0x186>
	if ((ul_y1 == ul_y2) || (ul_x1 == ul_x2)) {
		ili9325_draw_filled_rectangle(ul_x1, ul_y1, ul_x2, ul_y2);
	} else {
		ili9325_draw_line_bresenham(ul_x1, ul_y1, ul_x2, ul_y2);
	}
}
  400c24:	b003      	add	sp, #12
  400c26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 1; i <= dx; i++) {
			x += xinc;
			cumul += dy;

			if (cumul >= dx) {
				cumul -= dx;
  400c2a:	1b76      	subs	r6, r6, r5
				y += yinc;
  400c2c:	9901      	ldr	r1, [sp, #4]
  400c2e:	187f      	adds	r7, r7, r1
			}

			ili9325_draw_pixel(x, y);
  400c30:	4648      	mov	r0, r9
  400c32:	4639      	mov	r1, r7
  400c34:	47d0      	blx	sl
	ili9325_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  400c36:	f108 0801 	add.w	r8, r8, #1
  400c3a:	44d9      	add	r9, fp
  400c3c:	4545      	cmp	r5, r8
  400c3e:	dbf1      	blt.n	400c24 <ili9325_draw_line+0xf4>
  400c40:	9b00      	ldr	r3, [sp, #0]
  400c42:	2b00      	cmp	r3, #0
  400c44:	d0ba      	beq.n	400bbc <ili9325_draw_line+0x8c>
			x += xinc;
			cumul += dy;
  400c46:	1936      	adds	r6, r6, r4

			if (cumul >= dx) {
  400c48:	42b5      	cmp	r5, r6
  400c4a:	dc02      	bgt.n	400c52 <ili9325_draw_line+0x122>
				cumul -= dx;
  400c4c:	1b76      	subs	r6, r6, r5
				y += yinc;
  400c4e:	9801      	ldr	r0, [sp, #4]
  400c50:	183f      	adds	r7, r7, r0
			}

			ili9325_draw_pixel(x, y);
  400c52:	4648      	mov	r0, r9
  400c54:	4639      	mov	r1, r7
  400c56:	47d0      	blx	sl
	ili9325_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  400c58:	f108 0801 	add.w	r8, r8, #1
  400c5c:	44d9      	add	r9, fp
  400c5e:	4545      	cmp	r5, r8
  400c60:	daac      	bge.n	400bbc <ili9325_draw_line+0x8c>
  400c62:	e7df      	b.n	400c24 <ili9325_draw_line+0xf4>
			x += xinc;
			cumul += dy;

			if (cumul >= dx) {
				cumul -= dx;
  400c64:	1b76      	subs	r6, r6, r5
				y += yinc;
  400c66:	9901      	ldr	r1, [sp, #4]
  400c68:	187f      	adds	r7, r7, r1
			}

			ili9325_draw_pixel(x, y);
  400c6a:	4648      	mov	r0, r9
  400c6c:	4639      	mov	r1, r7
  400c6e:	47d0      	blx	sl
	ili9325_draw_pixel(x, y);

	if (dx > dy) {
		cumul = dx >> 1;

		for (i = 1; i <= dx; i++) {
  400c70:	f108 0801 	add.w	r8, r8, #1
  400c74:	44d9      	add	r9, fp
  400c76:	4545      	cmp	r5, r8
  400c78:	daa0      	bge.n	400bbc <ili9325_draw_line+0x8c>
  400c7a:	e7d3      	b.n	400c24 <ili9325_draw_line+0xf4>
		for (i = 1; i <= dy; i++) {
			y += yinc;
			cumul += dx;

			if (cumul >= dy) {
				cumul -= dy;
  400c7c:	1b36      	subs	r6, r6, r4
				x += xinc;
  400c7e:	9b00      	ldr	r3, [sp, #0]
  400c80:	4498      	add	r8, r3
			}

			ili9325_draw_pixel(x, y);
  400c82:	4640      	mov	r0, r8
  400c84:	4649      	mov	r1, r9
  400c86:	47d0      	blx	sl
			ili9325_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  400c88:	f107 0701 	add.w	r7, r7, #1
  400c8c:	44d9      	add	r9, fp
  400c8e:	42bc      	cmp	r4, r7
  400c90:	dbc8      	blt.n	400c24 <ili9325_draw_line+0xf4>
  400c92:	9801      	ldr	r0, [sp, #4]
  400c94:	2800      	cmp	r0, #0
  400c96:	d0b5      	beq.n	400c04 <ili9325_draw_line+0xd4>
			y += yinc;
			cumul += dx;
  400c98:	1976      	adds	r6, r6, r5

			if (cumul >= dy) {
  400c9a:	42b4      	cmp	r4, r6
  400c9c:	dc02      	bgt.n	400ca4 <ili9325_draw_line+0x174>
				cumul -= dy;
  400c9e:	1b36      	subs	r6, r6, r4
				x += xinc;
  400ca0:	9a00      	ldr	r2, [sp, #0]
  400ca2:	4490      	add	r8, r2
			}

			ili9325_draw_pixel(x, y);
  400ca4:	4640      	mov	r0, r8
  400ca6:	4649      	mov	r1, r9
  400ca8:	47d0      	blx	sl
			ili9325_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  400caa:	f107 0701 	add.w	r7, r7, #1
  400cae:	44d9      	add	r9, fp
  400cb0:	42bc      	cmp	r4, r7
  400cb2:	daa7      	bge.n	400c04 <ili9325_draw_line+0xd4>
  400cb4:	e7b6      	b.n	400c24 <ili9325_draw_line+0xf4>
			y += yinc;
			cumul += dx;

			if (cumul >= dy) {
				cumul -= dy;
  400cb6:	1b36      	subs	r6, r6, r4
				x += xinc;
  400cb8:	9b00      	ldr	r3, [sp, #0]
  400cba:	4498      	add	r8, r3
			}

			ili9325_draw_pixel(x, y);
  400cbc:	4640      	mov	r0, r8
  400cbe:	4649      	mov	r1, r9
  400cc0:	47d0      	blx	sl
			ili9325_draw_pixel(x, y);
		}
	} else {
		cumul = dy >> 1;

		for (i = 1; i <= dy; i++) {
  400cc2:	f107 0701 	add.w	r7, r7, #1
  400cc6:	44d9      	add	r9, fp
  400cc8:	42bc      	cmp	r4, r7
  400cca:	da9b      	bge.n	400c04 <ili9325_draw_line+0xd4>
  400ccc:	e7aa      	b.n	400c24 <ili9325_draw_line+0xf4>
  400cce:	bf00      	nop

00400cd0 <ili9325_draw_circle>:
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili9325_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
{
  400cd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400cd4:	b083      	sub	sp, #12
  400cd6:	4607      	mov	r7, r0
  400cd8:	4688      	mov	r8, r1
	int32_t   d;    /* Decision Variable */
	uint32_t  curX; /* Current X Value */
	uint32_t  curY; /* Current Y Value */

	if (ul_r == 0) {
  400cda:	4616      	mov	r6, r2
  400cdc:	2a00      	cmp	r2, #0
  400cde:	d04b      	beq.n	400d78 <ili9325_draw_circle+0xa8>
		return 1;
	}

	d = 3 - (ul_r << 1);
  400ce0:	ea4f 0342 	mov.w	r3, r2, lsl #1
  400ce4:	f1c3 0003 	rsb	r0, r3, #3
  400ce8:	9001      	str	r0, [sp, #4]
	curX = 0;
  400cea:	f04f 0500 	mov.w	r5, #0
	curY = ul_r;

	while (curX <= curY) {
		ili9325_draw_pixel(ul_x + curX, ul_y + curY);
  400cee:	f640 14c9 	movw	r4, #2505	; 0x9c9
  400cf2:	f2c0 0440 	movt	r4, #64	; 0x40
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili9325_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  400cf6:	eb05 0a07 	add.w	sl, r5, r7
	d = 3 - (ul_r << 1);
	curX = 0;
	curY = ul_r;

	while (curX <= curY) {
		ili9325_draw_pixel(ul_x + curX, ul_y + curY);
  400cfa:	eb06 0b08 	add.w	fp, r6, r8
  400cfe:	4650      	mov	r0, sl
  400d00:	4659      	mov	r1, fp
  400d02:	47a0      	blx	r4
		ili9325_draw_pixel(ul_x + curX, ul_y - curY);
  400d04:	ebc6 0908 	rsb	r9, r6, r8
  400d08:	4650      	mov	r0, sl
  400d0a:	4649      	mov	r1, r9
  400d0c:	47a0      	blx	r4
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili9325_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  400d0e:	ebc5 0a07 	rsb	sl, r5, r7
	curY = ul_r;

	while (curX <= curY) {
		ili9325_draw_pixel(ul_x + curX, ul_y + curY);
		ili9325_draw_pixel(ul_x + curX, ul_y - curY);
		ili9325_draw_pixel(ul_x - curX, ul_y + curY);
  400d12:	4650      	mov	r0, sl
  400d14:	4659      	mov	r1, fp
  400d16:	47a0      	blx	r4
		ili9325_draw_pixel(ul_x - curX, ul_y - curY);
  400d18:	4650      	mov	r0, sl
  400d1a:	4649      	mov	r1, r9
  400d1c:	47a0      	blx	r4
		ili9325_draw_pixel(ul_x + curY, ul_y + curX);
  400d1e:	eb06 0a07 	add.w	sl, r6, r7
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili9325_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  400d22:	eb05 0b08 	add.w	fp, r5, r8
	while (curX <= curY) {
		ili9325_draw_pixel(ul_x + curX, ul_y + curY);
		ili9325_draw_pixel(ul_x + curX, ul_y - curY);
		ili9325_draw_pixel(ul_x - curX, ul_y + curY);
		ili9325_draw_pixel(ul_x - curX, ul_y - curY);
		ili9325_draw_pixel(ul_x + curY, ul_y + curX);
  400d26:	4650      	mov	r0, sl
  400d28:	4659      	mov	r1, fp
  400d2a:	47a0      	blx	r4
 * \param ul_y Y coordinate of circle center.
 * \param ul_r circle radius.
 *
 * \return 0 if succeeds, otherwise fails.
 */
uint32_t ili9325_draw_circle(uint32_t ul_x, uint32_t ul_y, uint32_t ul_r)
  400d2c:	ebc5 0908 	rsb	r9, r5, r8
		ili9325_draw_pixel(ul_x + curX, ul_y + curY);
		ili9325_draw_pixel(ul_x + curX, ul_y - curY);
		ili9325_draw_pixel(ul_x - curX, ul_y + curY);
		ili9325_draw_pixel(ul_x - curX, ul_y - curY);
		ili9325_draw_pixel(ul_x + curY, ul_y + curX);
		ili9325_draw_pixel(ul_x + curY, ul_y - curX);
  400d30:	4650      	mov	r0, sl
  400d32:	4649      	mov	r1, r9
  400d34:	47a0      	blx	r4
		ili9325_draw_pixel(ul_x - curY, ul_y + curX);
  400d36:	ebc6 0a07 	rsb	sl, r6, r7
  400d3a:	4650      	mov	r0, sl
  400d3c:	4659      	mov	r1, fp
  400d3e:	47a0      	blx	r4
		ili9325_draw_pixel(ul_x - curY, ul_y - curX);
  400d40:	4650      	mov	r0, sl
  400d42:	4649      	mov	r1, r9
  400d44:	47a0      	blx	r4

		if (d < 0) {
  400d46:	9a01      	ldr	r2, [sp, #4]
  400d48:	2a00      	cmp	r2, #0
  400d4a:	da05      	bge.n	400d58 <ili9325_draw_circle+0x88>
			d += (curX << 2) + 6;
  400d4c:	eb02 0285 	add.w	r2, r2, r5, lsl #2
  400d50:	f102 0206 	add.w	r2, r2, #6
  400d54:	9201      	str	r2, [sp, #4]
  400d56:	e008      	b.n	400d6a <ili9325_draw_circle+0x9a>
		} else {
			d += ((curX - curY) << 2) + 10;
  400d58:	9901      	ldr	r1, [sp, #4]
  400d5a:	f101 010a 	add.w	r1, r1, #10
  400d5e:	1bab      	subs	r3, r5, r6
  400d60:	eb01 0083 	add.w	r0, r1, r3, lsl #2
  400d64:	9001      	str	r0, [sp, #4]
			curY--;
  400d66:	f106 36ff 	add.w	r6, r6, #4294967295
		}
		curX++;
  400d6a:	f105 0501 	add.w	r5, r5, #1

	d = 3 - (ul_r << 1);
	curX = 0;
	curY = ul_r;

	while (curX <= curY) {
  400d6e:	42ae      	cmp	r6, r5
  400d70:	d2c1      	bcs.n	400cf6 <ili9325_draw_circle+0x26>
			curY--;
		}
		curX++;
	}

	return 0;
  400d72:	f04f 0000 	mov.w	r0, #0
  400d76:	e001      	b.n	400d7c <ili9325_draw_circle+0xac>
	int32_t   d;    /* Decision Variable */
	uint32_t  curX; /* Current X Value */
	uint32_t  curY; /* Current Y Value */

	if (ul_r == 0) {
		return 1;
  400d78:	f04f 0001 	mov.w	r0, #1
		}
		curX++;
	}

	return 0;
}
  400d7c:	b003      	add	sp, #12
  400d7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400d82:	bf00      	nop

00400d84 <ili9325_draw_string>:
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili9325_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
{
  400d84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400d88:	b089      	sub	sp, #36	; 0x24
  400d8a:	9006      	str	r0, [sp, #24]
  400d8c:	468b      	mov	fp, r1
	uint32_t xorg = ul_x;

	while (*p_str != 0) {
  400d8e:	7813      	ldrb	r3, [r2, #0]
  400d90:	2b00      	cmp	r3, #0
  400d92:	f000 80c7 	beq.w	400f24 <ili9325_draw_string+0x1a0>
  400d96:	9200      	str	r2, [sp, #0]
  400d98:	4682      	mov	sl, r0
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili9325_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  400d9a:	f642 32e0 	movw	r2, #11232	; 0x2be0
  400d9e:	f2c0 0240 	movt	r2, #64	; 0x40
  400da2:	9205      	str	r2, [sp, #20]
  400da4:	f2a2 206b 	subw	r0, r2, #619	; 0x26b
  400da8:	9007      	str	r0, [sp, #28]
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400daa:	f640 11c9 	movw	r1, #2505	; 0x9c9
  400dae:	4689      	mov	r9, r1
  400db0:	f2c0 0940 	movt	r9, #64	; 0x40
{
	uint32_t xorg = ul_x;

	while (*p_str != 0) {
		/* If newline, jump to the next line (font height + 2) */
		if (*p_str == '\n') {
  400db4:	2b0a      	cmp	r3, #10
  400db6:	d104      	bne.n	400dc2 <ili9325_draw_string+0x3e>
			ul_y += gfont.height + 2;
  400db8:	f10b 0b10 	add.w	fp, fp, #16
			ul_x = xorg;
  400dbc:	f8dd a018 	ldr.w	sl, [sp, #24]
  400dc0:	e0a9      	b.n	400f16 <ili9325_draw_string+0x192>
	uint32_t row, col;
	uint32_t offset, offset0, offset1;

	/* Compute offset according of the specified ASCII character */
	/* Note: the first 32 characters of the ASCII table are not handled */
	offset = ((uint32_t)uc_c - 0x20) * 20;
  400dc2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  400dc6:	ea4f 0883 	mov.w	r8, r3, lsl #2
  400dca:	f5a8 7720 	sub.w	r7, r8, #640	; 0x280
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili9325_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  400dce:	9c05      	ldr	r4, [sp, #20]
  400dd0:	19e0      	adds	r0, r4, r7
				ili9325_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  400dd2:	f2a8 267f 	subw	r6, r8, #639	; 0x27f
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili9325_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  400dd6:	19a6      	adds	r6, r4, r6
  400dd8:	9d07      	ldr	r5, [sp, #28]
  400dda:	44a8      	add	r8, r5
  400ddc:	4655      	mov	r5, sl
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400dde:	f10b 0201 	add.w	r2, fp, #1
  400de2:	9201      	str	r2, [sp, #4]
  400de4:	f10b 0102 	add.w	r1, fp, #2
  400de8:	9102      	str	r1, [sp, #8]
  400dea:	f10b 0303 	add.w	r3, fp, #3
  400dee:	9303      	str	r3, [sp, #12]
  400df0:	f10b 0704 	add.w	r7, fp, #4
  400df4:	9704      	str	r7, [sp, #16]
  400df6:	464c      	mov	r4, r9
  400df8:	4681      	mov	r9, r0
  400dfa:	4627      	mov	r7, r4
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili9325_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  400dfc:	4634      	mov	r4, r6
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400dfe:	f816 0c01 	ldrb.w	r0, [r6, #-1]
  400e02:	f010 0f80 	tst.w	r0, #128	; 0x80
  400e06:	d002      	beq.n	400e0e <ili9325_draw_string+0x8a>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e08:	4628      	mov	r0, r5
  400e0a:	4659      	mov	r1, fp
  400e0c:	47b8      	blx	r7
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400e0e:	f814 2c01 	ldrb.w	r2, [r4, #-1]
  400e12:	f002 0140 	and.w	r1, r2, #64	; 0x40
  400e16:	b2cb      	uxtb	r3, r1
  400e18:	b113      	cbz	r3, 400e20 <ili9325_draw_string+0x9c>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e1a:	4628      	mov	r0, r5
  400e1c:	9901      	ldr	r1, [sp, #4]
  400e1e:	47b8      	blx	r7
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400e20:	f814 0c01 	ldrb.w	r0, [r4, #-1]
  400e24:	f000 0220 	and.w	r2, r0, #32
  400e28:	b2d1      	uxtb	r1, r2
  400e2a:	b111      	cbz	r1, 400e32 <ili9325_draw_string+0xae>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e2c:	4628      	mov	r0, r5
  400e2e:	9902      	ldr	r1, [sp, #8]
  400e30:	47b8      	blx	r7
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400e32:	f814 3c01 	ldrb.w	r3, [r4, #-1]
  400e36:	f003 0010 	and.w	r0, r3, #16
  400e3a:	b2c2      	uxtb	r2, r0
  400e3c:	b112      	cbz	r2, 400e44 <ili9325_draw_string+0xc0>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e3e:	4628      	mov	r0, r5
  400e40:	9903      	ldr	r1, [sp, #12]
  400e42:	47b8      	blx	r7
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400e44:	f814 1c01 	ldrb.w	r1, [r4, #-1]
  400e48:	f001 0308 	and.w	r3, r1, #8
  400e4c:	b2d8      	uxtb	r0, r3
  400e4e:	b110      	cbz	r0, 400e56 <ili9325_draw_string+0xd2>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e50:	4628      	mov	r0, r5
  400e52:	9904      	ldr	r1, [sp, #16]
  400e54:	47b8      	blx	r7
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400e56:	f814 2c01 	ldrb.w	r2, [r4, #-1]
  400e5a:	f002 0104 	and.w	r1, r2, #4
  400e5e:	b2cb      	uxtb	r3, r1
  400e60:	b11b      	cbz	r3, 400e6a <ili9325_draw_string+0xe6>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e62:	4628      	mov	r0, r5
  400e64:	f10b 0105 	add.w	r1, fp, #5
  400e68:	47b8      	blx	r7
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400e6a:	f814 0c01 	ldrb.w	r0, [r4, #-1]
  400e6e:	f000 0202 	and.w	r2, r0, #2
  400e72:	b2d1      	uxtb	r1, r2
  400e74:	b119      	cbz	r1, 400e7e <ili9325_draw_string+0xfa>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e76:	4628      	mov	r0, r5
  400e78:	f10b 0106 	add.w	r1, fp, #6
  400e7c:	47b8      	blx	r7
		offset0 = offset + col * 2;
		offset1 = offset0 + 1;

		/* Draw pixel on screen depending on the corresponding bit value from the charset */
		for (row = 0; row < 8; row++) {
			if ((p_uc_charset10x14[offset0] >> (7 - row)) & 0x1) {
  400e7e:	f814 4c01 	ldrb.w	r4, [r4, #-1]
  400e82:	f014 0f01 	tst.w	r4, #1
  400e86:	d003      	beq.n	400e90 <ili9325_draw_string+0x10c>
				ili9325_draw_pixel(ul_x + col, ul_y + row);
  400e88:	4628      	mov	r0, r5
  400e8a:	f10b 0107 	add.w	r1, fp, #7
  400e8e:	47b8      	blx	r7
 *
 * \param ul_x X coordinate of string top-left corner.
 * \param ul_y Y coordinate of string top-left corner.
 * \param p_str String to display.
 */
void ili9325_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
  400e90:	464c      	mov	r4, r9
				ili9325_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  400e92:	f899 3001 	ldrb.w	r3, [r9, #1]
  400e96:	f013 0f80 	tst.w	r3, #128	; 0x80
  400e9a:	d003      	beq.n	400ea4 <ili9325_draw_string+0x120>
				ili9325_draw_pixel(ul_x + col, ul_y + row + 8);
  400e9c:	4628      	mov	r0, r5
  400e9e:	f10b 0108 	add.w	r1, fp, #8
  400ea2:	47b8      	blx	r7
				ili9325_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  400ea4:	7860      	ldrb	r0, [r4, #1]
  400ea6:	f000 0240 	and.w	r2, r0, #64	; 0x40
  400eaa:	b2d1      	uxtb	r1, r2
  400eac:	b119      	cbz	r1, 400eb6 <ili9325_draw_string+0x132>
				ili9325_draw_pixel(ul_x + col, ul_y + row + 8);
  400eae:	4628      	mov	r0, r5
  400eb0:	f10b 0109 	add.w	r1, fp, #9
  400eb4:	47b8      	blx	r7
				ili9325_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  400eb6:	7863      	ldrb	r3, [r4, #1]
  400eb8:	f003 0020 	and.w	r0, r3, #32
  400ebc:	b2c2      	uxtb	r2, r0
  400ebe:	b11a      	cbz	r2, 400ec8 <ili9325_draw_string+0x144>
				ili9325_draw_pixel(ul_x + col, ul_y + row + 8);
  400ec0:	4628      	mov	r0, r5
  400ec2:	f10b 010a 	add.w	r1, fp, #10
  400ec6:	47b8      	blx	r7
				ili9325_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  400ec8:	7861      	ldrb	r1, [r4, #1]
  400eca:	f001 0310 	and.w	r3, r1, #16
  400ece:	b2d8      	uxtb	r0, r3
  400ed0:	b118      	cbz	r0, 400eda <ili9325_draw_string+0x156>
				ili9325_draw_pixel(ul_x + col, ul_y + row + 8);
  400ed2:	4628      	mov	r0, r5
  400ed4:	f10b 010b 	add.w	r1, fp, #11
  400ed8:	47b8      	blx	r7
				ili9325_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  400eda:	7862      	ldrb	r2, [r4, #1]
  400edc:	f002 0108 	and.w	r1, r2, #8
  400ee0:	b2cb      	uxtb	r3, r1
  400ee2:	b11b      	cbz	r3, 400eec <ili9325_draw_string+0x168>
				ili9325_draw_pixel(ul_x + col, ul_y + row + 8);
  400ee4:	4628      	mov	r0, r5
  400ee6:	f10b 010c 	add.w	r1, fp, #12
  400eea:	47b8      	blx	r7
				ili9325_draw_pixel(ul_x + col, ul_y + row);
			}
		}

		for (row = 0; row < 6; row++) {
			if ((p_uc_charset10x14[offset1] >> (7 - row)) & 0x1) {
  400eec:	7860      	ldrb	r0, [r4, #1]
  400eee:	f000 0204 	and.w	r2, r0, #4
  400ef2:	b2d1      	uxtb	r1, r2
  400ef4:	b119      	cbz	r1, 400efe <ili9325_draw_string+0x17a>
				ili9325_draw_pixel(ul_x + col, ul_y + row + 8);
  400ef6:	4628      	mov	r0, r5
  400ef8:	f10b 010d 	add.w	r1, fp, #13
  400efc:	47b8      	blx	r7
  400efe:	f109 0902 	add.w	r9, r9, #2
  400f02:	f106 0602 	add.w	r6, r6, #2
  400f06:	f105 0501 	add.w	r5, r5, #1

	/* Compute offset according of the specified ASCII character */
	/* Note: the first 32 characters of the ASCII table are not handled */
	offset = ((uint32_t)uc_c - 0x20) * 20;

	for (col = 0; col < 10; col++) {
  400f0a:	4546      	cmp	r6, r8
  400f0c:	f47f af76 	bne.w	400dfc <ili9325_draw_string+0x78>
  400f10:	46b9      	mov	r9, r7
			ul_y += gfont.height + 2;
			ul_x = xorg;
		} else {
			/* Draw the character and place cursor right after (font width + 2) */
			ili9325_draw_char(ul_x, ul_y, *p_str);
			ul_x += gfont.width + 2;
  400f12:	f10a 0a0c 	add.w	sl, sl, #12
 */
void ili9325_draw_string(uint32_t ul_x, uint32_t ul_y, const uint8_t *p_str)
{
	uint32_t xorg = ul_x;

	while (*p_str != 0) {
  400f16:	9800      	ldr	r0, [sp, #0]
  400f18:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  400f1c:	9000      	str	r0, [sp, #0]
  400f1e:	2b00      	cmp	r3, #0
  400f20:	f47f af48 	bne.w	400db4 <ili9325_draw_string+0x30>
			ili9325_draw_char(ul_x, ul_y, *p_str);
			ul_x += gfont.width + 2;
		}
		p_str++;
	}
}
  400f24:	b009      	add	sp, #36	; 0x24
  400f26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400f2a:	bf00      	nop

00400f2c <smc_set_setup_timing>:
 * \param ul_setup_timing Setup timing for NWE, NCS, NRD.
 */
void smc_set_setup_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_setup_timing)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_SETUP = ul_setup_timing;
  400f2c:	ea4f 1101 	mov.w	r1, r1, lsl #4
  400f30:	5042      	str	r2, [r0, r1]
  400f32:	4770      	bx	lr

00400f34 <smc_set_pulse_timing>:
 * \param ul_pulse_timing Pulse timing for NWE,NCS,NRD.
 */
void smc_set_pulse_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_pulse_timing)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_PULSE = ul_pulse_timing;
  400f34:	eb00 1101 	add.w	r1, r0, r1, lsl #4
  400f38:	604a      	str	r2, [r1, #4]
  400f3a:	4770      	bx	lr

00400f3c <smc_set_cycle_timing>:
 * \param ul_cycle_timing Cycle timing for NWE and NRD.
 */
void smc_set_cycle_timing(Smc *p_smc, uint32_t ul_cs,
		uint32_t ul_cycle_timing)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_CYCLE = ul_cycle_timing;
  400f3c:	eb00 1101 	add.w	r1, r0, r1, lsl #4
  400f40:	608a      	str	r2, [r1, #8]
  400f42:	4770      	bx	lr

00400f44 <smc_set_mode>:
 * \param ul_cs Chip select number to be set.
 * \param ul_mode SMC mode.
 */
void smc_set_mode(Smc *p_smc, uint32_t ul_cs, uint32_t ul_mode)
{
	p_smc->SMC_CS_NUMBER[ul_cs].SMC_MODE = ul_mode;
  400f44:	eb00 1101 	add.w	r1, r0, r1, lsl #4
  400f48:	60ca      	str	r2, [r1, #12]
  400f4a:	4770      	bx	lr

00400f4c <pio_pull_up>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  400f4c:	b10a      	cbz	r2, 400f52 <pio_pull_up+0x6>
		p_pio->PIO_PUER = ul_mask;
  400f4e:	6641      	str	r1, [r0, #100]	; 0x64
  400f50:	4770      	bx	lr
	} else {
		p_pio->PIO_PUDR = ul_mask;
  400f52:	6601      	str	r1, [r0, #96]	; 0x60
  400f54:	4770      	bx	lr
  400f56:	bf00      	nop

00400f58 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  400f58:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  400f5a:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP)
	switch (ul_type) {
  400f5c:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  400f60:	d030      	beq.n	400fc4 <pio_set_peripheral+0x6c>
  400f62:	d808      	bhi.n	400f76 <pio_set_peripheral+0x1e>
  400f64:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  400f68:	d014      	beq.n	400f94 <pio_set_peripheral+0x3c>
  400f6a:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  400f6e:	d01e      	beq.n	400fae <pio_set_peripheral+0x56>
  400f70:	2900      	cmp	r1, #0
  400f72:	d03b      	beq.n	400fec <pio_set_peripheral+0x94>
  400f74:	e039      	b.n	400fea <pio_set_peripheral+0x92>
  400f76:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  400f7a:	d037      	beq.n	400fec <pio_set_peripheral+0x94>
  400f7c:	d803      	bhi.n	400f86 <pio_set_peripheral+0x2e>
  400f7e:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  400f82:	d132      	bne.n	400fea <pio_set_peripheral+0x92>
  400f84:	e029      	b.n	400fda <pio_set_peripheral+0x82>
  400f86:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  400f8a:	d02f      	beq.n	400fec <pio_set_peripheral+0x94>
  400f8c:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  400f90:	d12b      	bne.n	400fea <pio_set_peripheral+0x92>
  400f92:	e02b      	b.n	400fec <pio_set_peripheral+0x94>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400f94:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400f96:	6f04      	ldr	r4, [r0, #112]	; 0x70
  400f98:	ea6f 0302 	mvn.w	r3, r2
  400f9c:	4021      	ands	r1, r4
  400f9e:	4019      	ands	r1, r3
  400fa0:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400fa2:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400fa4:	6f44      	ldr	r4, [r0, #116]	; 0x74
  400fa6:	4021      	ands	r1, r4
  400fa8:	400b      	ands	r3, r1
  400faa:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  400fac:	e01d      	b.n	400fea <pio_set_peripheral+0x92>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400fae:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400fb0:	ea42 0103 	orr.w	r1, r2, r3
  400fb4:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400fb6:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400fb8:	6f41      	ldr	r1, [r0, #116]	; 0x74
  400fba:	400b      	ands	r3, r1
  400fbc:	ea23 0302 	bic.w	r3, r3, r2
  400fc0:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  400fc2:	e012      	b.n	400fea <pio_set_peripheral+0x92>
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400fc4:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400fc6:	6f01      	ldr	r1, [r0, #112]	; 0x70
  400fc8:	400b      	ands	r3, r1
  400fca:	ea23 0302 	bic.w	r3, r3, r2
  400fce:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400fd0:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  400fd2:	ea42 0103 	orr.w	r1, r2, r3
  400fd6:	6741      	str	r1, [r0, #116]	; 0x74
		break;
  400fd8:	e007      	b.n	400fea <pio_set_peripheral+0x92>

	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  400fda:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400fdc:	ea42 0103 	orr.w	r1, r2, r3
  400fe0:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400fe2:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  400fe4:	ea42 0103 	orr.w	r1, r2, r3
  400fe8:	6741      	str	r1, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  400fea:	6042      	str	r2, [r0, #4]
}
  400fec:	bc10      	pop	{r4}
  400fee:	4770      	bx	lr

00400ff0 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  400ff0:	6441      	str	r1, [r0, #68]	; 0x44
  400ff2:	4770      	bx	lr

00400ff4 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  400ff4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400ff6:	4604      	mov	r4, r0
  400ff8:	460d      	mov	r5, r1
  400ffa:	4616      	mov	r6, r2
  400ffc:	461f      	mov	r7, r3
	pio_disable_interrupt(p_pio, ul_mask);
  400ffe:	f640 73f1 	movw	r3, #4081	; 0xff1
  401002:	f2c0 0340 	movt	r3, #64	; 0x40
  401006:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  401008:	4620      	mov	r0, r4
  40100a:	4629      	mov	r1, r5
  40100c:	9a06      	ldr	r2, [sp, #24]
  40100e:	f640 734d 	movw	r3, #3917	; 0xf4d
  401012:	f2c0 0340 	movt	r3, #64	; 0x40
  401016:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  401018:	b10f      	cbz	r7, 40101e <pio_set_output+0x2a>
		p_pio->PIO_MDER = ul_mask;
  40101a:	6525      	str	r5, [r4, #80]	; 0x50
  40101c:	e000      	b.n	401020 <pio_set_output+0x2c>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  40101e:	6565      	str	r5, [r4, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  401020:	b10e      	cbz	r6, 401026 <pio_set_output+0x32>
		p_pio->PIO_SODR = ul_mask;
  401022:	6325      	str	r5, [r4, #48]	; 0x30
  401024:	e000      	b.n	401028 <pio_set_output+0x34>
	} else {
		p_pio->PIO_CODR = ul_mask;
  401026:	6365      	str	r5, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  401028:	6125      	str	r5, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  40102a:	6025      	str	r5, [r4, #0]
  40102c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40102e:	bf00      	nop

00401030 <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  401030:	b570      	push	{r4, r5, r6, lr}
  401032:	4604      	mov	r4, r0
  401034:	460d      	mov	r5, r1
  401036:	4616      	mov	r6, r2
	pio_disable_interrupt(p_pio, ul_mask);
  401038:	f640 73f1 	movw	r3, #4081	; 0xff1
  40103c:	f2c0 0340 	movt	r3, #64	; 0x40
  401040:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  401042:	4620      	mov	r0, r4
  401044:	4629      	mov	r1, r5
  401046:	f006 0201 	and.w	r2, r6, #1
  40104a:	f640 734d 	movw	r3, #3917	; 0xf4d
  40104e:	f2c0 0340 	movt	r3, #64	; 0x40
  401052:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  401054:	f016 0f0a 	tst.w	r6, #10
		p_pio->PIO_IFER = ul_mask;
  401058:	bf14      	ite	ne
  40105a:	6225      	strne	r5, [r4, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  40105c:	6265      	streq	r5, [r4, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  40105e:	f016 0f02 	tst.w	r6, #2
  401062:	d002      	beq.n	40106a <pio_set_input+0x3a>
		p_pio->PIO_IFSCDR = ul_mask;
  401064:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
  401068:	e004      	b.n	401074 <pio_set_input+0x44>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  40106a:	f016 0f08 	tst.w	r6, #8
			p_pio->PIO_IFSCER = ul_mask;
  40106e:	bf18      	it	ne
  401070:	f8c4 5084 	strne.w	r5, [r4, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  401074:	6165      	str	r5, [r4, #20]
	p_pio->PIO_PER = ul_mask;
  401076:	6025      	str	r5, [r4, #0]
  401078:	bd70      	pop	{r4, r5, r6, pc}
  40107a:	bf00      	nop

0040107c <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  40107c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  40107e:	4770      	bx	lr

00401080 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  401080:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  401082:	4770      	bx	lr

00401084 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  401084:	b5f0      	push	{r4, r5, r6, r7, lr}
  401086:	b083      	sub	sp, #12
  401088:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40108a:	ea4f 1650 	mov.w	r6, r0, lsr #5
  40108e:	f506 1100 	add.w	r1, r6, #2097152	; 0x200000
  401092:	f201 7207 	addw	r2, r1, #1799	; 0x707
  401096:	ea4f 2642 	mov.w	r6, r2, lsl #9
#endif

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40109a:	f005 44f0 	and.w	r4, r5, #2013265920	; 0x78000000
  40109e:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
  4010a2:	d064      	beq.n	40116e <pio_configure_pin+0xea>
  4010a4:	d80a      	bhi.n	4010bc <pio_configure_pin+0x38>
  4010a6:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
  4010aa:	d02c      	beq.n	401106 <pio_configure_pin+0x82>
  4010ac:	f1b4 5fc0 	cmp.w	r4, #402653184	; 0x18000000
  4010b0:	d043      	beq.n	40113a <pio_configure_pin+0xb6>
  4010b2:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
  4010b6:	f040 809d 	bne.w	4011f4 <pio_configure_pin+0x170>
  4010ba:	e00a      	b.n	4010d2 <pio_configure_pin+0x4e>
  4010bc:	f1b4 5f40 	cmp.w	r4, #805306368	; 0x30000000
  4010c0:	d07e      	beq.n	4011c0 <pio_configure_pin+0x13c>
  4010c2:	f1b4 5f60 	cmp.w	r4, #939524096	; 0x38000000
  4010c6:	d07b      	beq.n	4011c0 <pio_configure_pin+0x13c>
  4010c8:	f1b4 5f20 	cmp.w	r4, #671088640	; 0x28000000
  4010cc:	f040 8092 	bne.w	4011f4 <pio_configure_pin+0x170>
  4010d0:	e067      	b.n	4011a2 <pio_configure_pin+0x11e>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
  4010d2:	f000 031f 	and.w	r3, r0, #31
  4010d6:	f04f 0401 	mov.w	r4, #1
  4010da:	fa04 f703 	lsl.w	r7, r4, r3
  4010de:	4630      	mov	r0, r6
  4010e0:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  4010e4:	463a      	mov	r2, r7
  4010e6:	f640 7359 	movw	r3, #3929	; 0xf59
  4010ea:	f2c0 0340 	movt	r3, #64	; 0x40
  4010ee:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  4010f0:	4630      	mov	r0, r6
  4010f2:	4639      	mov	r1, r7
  4010f4:	ea05 0204 	and.w	r2, r5, r4
  4010f8:	f640 734d 	movw	r3, #3917	; 0xf4d
  4010fc:	f2c0 0340 	movt	r3, #64	; 0x40
  401100:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401102:	4620      	mov	r0, r4
	switch (ul_flags & PIO_TYPE_Msk) {
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401104:	e078      	b.n	4011f8 <pio_configure_pin+0x174>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
  401106:	f000 071f 	and.w	r7, r0, #31
  40110a:	f04f 0401 	mov.w	r4, #1
  40110e:	fa04 f707 	lsl.w	r7, r4, r7
  401112:	4630      	mov	r0, r6
  401114:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  401118:	463a      	mov	r2, r7
  40111a:	f640 7359 	movw	r3, #3929	; 0xf59
  40111e:	f2c0 0340 	movt	r3, #64	; 0x40
  401122:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401124:	4630      	mov	r0, r6
  401126:	4639      	mov	r1, r7
  401128:	ea05 0204 	and.w	r2, r5, r4
  40112c:	f640 734d 	movw	r3, #3917	; 0xf4d
  401130:	f2c0 0340 	movt	r3, #64	; 0x40
  401134:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401136:	4620      	mov	r0, r4
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  401138:	e05e      	b.n	4011f8 <pio_configure_pin+0x174>
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
  40113a:	f000 001f 	and.w	r0, r0, #31
  40113e:	f04f 0401 	mov.w	r4, #1
  401142:	fa04 f700 	lsl.w	r7, r4, r0
  401146:	4630      	mov	r0, r6
  401148:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40114c:	463a      	mov	r2, r7
  40114e:	f640 7359 	movw	r3, #3929	; 0xf59
  401152:	f2c0 0340 	movt	r3, #64	; 0x40
  401156:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  401158:	4630      	mov	r0, r6
  40115a:	4639      	mov	r1, r7
  40115c:	ea05 0204 	and.w	r2, r5, r4
  401160:	f640 734d 	movw	r3, #3917	; 0xf4d
  401164:	f2c0 0340 	movt	r3, #64	; 0x40
  401168:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40116a:	4620      	mov	r0, r4
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  40116c:	e044      	b.n	4011f8 <pio_configure_pin+0x174>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  40116e:	f000 021f 	and.w	r2, r0, #31
  401172:	f04f 0401 	mov.w	r4, #1
  401176:	fa04 f702 	lsl.w	r7, r4, r2
  40117a:	4630      	mov	r0, r6
  40117c:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  401180:	463a      	mov	r2, r7
  401182:	f640 7359 	movw	r3, #3929	; 0xf59
  401186:	f2c0 0340 	movt	r3, #64	; 0x40
  40118a:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
  40118c:	4630      	mov	r0, r6
  40118e:	4639      	mov	r1, r7
  401190:	ea05 0204 	and.w	r2, r5, r4
  401194:	f640 734d 	movw	r3, #3917	; 0xf4d
  401198:	f2c0 0340 	movt	r3, #64	; 0x40
  40119c:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40119e:	4620      	mov	r0, r4
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
  4011a0:	e02a      	b.n	4011f8 <pio_configure_pin+0x174>
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  4011a2:	f000 011f 	and.w	r1, r0, #31
  4011a6:	f04f 0401 	mov.w	r4, #1
  4011aa:	4630      	mov	r0, r6
  4011ac:	fa04 f101 	lsl.w	r1, r4, r1
  4011b0:	462a      	mov	r2, r5
  4011b2:	f241 0331 	movw	r3, #4145	; 0x1031
  4011b6:	f2c0 0340 	movt	r3, #64	; 0x40
  4011ba:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4011bc:	4620      	mov	r0, r4
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  4011be:	e01b      	b.n	4011f8 <pio_configure_pin+0x174>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  4011c0:	f000 031f 	and.w	r3, r0, #31
  4011c4:	f04f 0401 	mov.w	r4, #1
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  4011c8:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  4011cc:	ea05 0004 	and.w	r0, r5, r4
  4011d0:	9000      	str	r0, [sp, #0]
  4011d2:	4630      	mov	r0, r6
  4011d4:	fa04 f103 	lsl.w	r1, r4, r3
  4011d8:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
  4011dc:	bf14      	ite	ne
  4011de:	2200      	movne	r2, #0
  4011e0:	2201      	moveq	r2, #1
  4011e2:	f3c5 0380 	ubfx	r3, r5, #2, #1
  4011e6:	f640 75f5 	movw	r5, #4085	; 0xff5
  4011ea:	f2c0 0540 	movt	r5, #64	; 0x40
  4011ee:	47a8      	blx	r5

	default:
		return 0;
	}

	return 1;
  4011f0:	4620      	mov	r0, r4
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  4011f2:	e001      	b.n	4011f8 <pio_configure_pin+0x174>

	default:
		return 0;
  4011f4:	f04f 0000 	mov.w	r0, #0
	}

	return 1;
}
  4011f8:	b003      	add	sp, #12
  4011fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

004011fc <pio_configure_pin_group>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  4011fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  4011fe:	b083      	sub	sp, #12
  401200:	4607      	mov	r7, r0
  401202:	460e      	mov	r6, r1
  401204:	4615      	mov	r5, r2
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  401206:	f002 44f0 	and.w	r4, r2, #2013265920	; 0x78000000
  40120a:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
  40120e:	d050      	beq.n	4012b2 <pio_configure_pin_group+0xb6>
  401210:	d809      	bhi.n	401226 <pio_configure_pin_group+0x2a>
  401212:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
  401216:	d024      	beq.n	401262 <pio_configure_pin_group+0x66>
  401218:	f1b4 5fc0 	cmp.w	r4, #402653184	; 0x18000000
  40121c:	d035      	beq.n	40128a <pio_configure_pin_group+0x8e>
  40121e:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
  401222:	d178      	bne.n	401316 <pio_configure_pin_group+0x11a>
  401224:	e009      	b.n	40123a <pio_configure_pin_group+0x3e>
  401226:	f1b4 5f40 	cmp.w	r4, #805306368	; 0x30000000
  40122a:	d05e      	beq.n	4012ea <pio_configure_pin_group+0xee>
  40122c:	f1b4 5f60 	cmp.w	r4, #939524096	; 0x38000000
  401230:	d05b      	beq.n	4012ea <pio_configure_pin_group+0xee>
  401232:	f1b4 5f20 	cmp.w	r4, #671088640	; 0x28000000
  401236:	d16e      	bne.n	401316 <pio_configure_pin_group+0x11a>
  401238:	e04f      	b.n	4012da <pio_configure_pin_group+0xde>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
  40123a:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  40123e:	4632      	mov	r2, r6
  401240:	f640 7359 	movw	r3, #3929	; 0xf59
  401244:	f2c0 0340 	movt	r3, #64	; 0x40
  401248:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  40124a:	4638      	mov	r0, r7
  40124c:	4631      	mov	r1, r6
  40124e:	f005 0201 	and.w	r2, r5, #1
  401252:	f640 734d 	movw	r3, #3917	; 0xf4d
  401256:	f2c0 0340 	movt	r3, #64	; 0x40
  40125a:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40125c:	f04f 0001 	mov.w	r0, #1
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  401260:	e05b      	b.n	40131a <pio_configure_pin_group+0x11e>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, ul_mask);
  401262:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  401266:	4632      	mov	r2, r6
  401268:	f640 7359 	movw	r3, #3929	; 0xf59
  40126c:	f2c0 0340 	movt	r3, #64	; 0x40
  401270:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  401272:	4638      	mov	r0, r7
  401274:	4631      	mov	r1, r6
  401276:	f005 0201 	and.w	r2, r5, #1
  40127a:	f640 734d 	movw	r3, #3917	; 0xf4d
  40127e:	f2c0 0340 	movt	r3, #64	; 0x40
  401282:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  401284:	f04f 0001 	mov.w	r0, #1
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  401288:	e047      	b.n	40131a <pio_configure_pin_group+0x11e>
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
  40128a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40128e:	4632      	mov	r2, r6
  401290:	f640 7359 	movw	r3, #3929	; 0xf59
  401294:	f2c0 0340 	movt	r3, #64	; 0x40
  401298:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  40129a:	4638      	mov	r0, r7
  40129c:	4631      	mov	r1, r6
  40129e:	f005 0201 	and.w	r2, r5, #1
  4012a2:	f640 734d 	movw	r3, #3917	; 0xf4d
  4012a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4012aa:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4012ac:	f04f 0001 	mov.w	r0, #1
		break;
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP)
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  4012b0:	e033      	b.n	40131a <pio_configure_pin_group+0x11e>
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  4012b2:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  4012b6:	4632      	mov	r2, r6
  4012b8:	f640 7359 	movw	r3, #3929	; 0xf59
  4012bc:	f2c0 0340 	movt	r3, #64	; 0x40
  4012c0:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
  4012c2:	4638      	mov	r0, r7
  4012c4:	4631      	mov	r1, r6
  4012c6:	f005 0201 	and.w	r2, r5, #1
  4012ca:	f640 734d 	movw	r3, #3917	; 0xf4d
  4012ce:	f2c0 0340 	movt	r3, #64	; 0x40
  4012d2:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4012d4:	f04f 0001 	mov.w	r0, #1
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
  4012d8:	e01f      	b.n	40131a <pio_configure_pin_group+0x11e>
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  4012da:	f241 0331 	movw	r3, #4145	; 0x1031
  4012de:	f2c0 0340 	movt	r3, #64	; 0x40
  4012e2:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4012e4:	f04f 0001 	mov.w	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
  4012e8:	e017      	b.n	40131a <pio_configure_pin_group+0x11e>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  4012ea:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
  4012ee:	f005 0001 	and.w	r0, r5, #1
  4012f2:	9000      	str	r0, [sp, #0]
  4012f4:	4638      	mov	r0, r7
  4012f6:	4631      	mov	r1, r6
  4012f8:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
  4012fc:	bf14      	ite	ne
  4012fe:	2200      	movne	r2, #0
  401300:	2201      	moveq	r2, #1
  401302:	f3c5 0380 	ubfx	r3, r5, #2, #1
  401306:	f640 74f5 	movw	r4, #4085	; 0xff5
  40130a:	f2c0 0440 	movt	r4, #64	; 0x40
  40130e:	47a0      	blx	r4

	default:
		return 0;
	}

	return 1;
  401310:	f04f 0001 	mov.w	r0, #1
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
  401314:	e001      	b.n	40131a <pio_configure_pin_group+0x11e>

	default:
		return 0;
  401316:	f04f 0000 	mov.w	r0, #0
	}

	return 1;
}
  40131a:	b003      	add	sp, #12
  40131c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40131e:	bf00      	nop

00401320 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  401320:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401324:	4680      	mov	r8, r0
  401326:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  401328:	f241 037d 	movw	r3, #4221	; 0x107d
  40132c:	f2c0 0340 	movt	r3, #64	; 0x40
  401330:	4798      	blx	r3
  401332:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  401334:	4640      	mov	r0, r8
  401336:	f241 0181 	movw	r1, #4225	; 0x1081
  40133a:	f2c0 0140 	movt	r1, #64	; 0x40
  40133e:	4788      	blx	r1

	/* Check pending events */
	if (status != 0) {
  401340:	4005      	ands	r5, r0
  401342:	d014      	beq.n	40136e <pio_handler_process+0x4e>
  401344:	4c12      	ldr	r4, [pc, #72]	; (401390 <pio_handler_process+0x70>)
 * \brief Process an interrupt request on the given PIO controller.
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
  401346:	4627      	mov	r7, r4
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  401348:	f854 0c0c 	ldr.w	r0, [r4, #-12]
  40134c:	42b0      	cmp	r0, r6
  40134e:	d10a      	bne.n	401366 <pio_handler_process+0x46>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  401350:	f854 1c08 	ldr.w	r1, [r4, #-8]
  401354:	4229      	tst	r1, r5
  401356:	d006      	beq.n	401366 <pio_handler_process+0x46>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  401358:	6822      	ldr	r2, [r4, #0]
  40135a:	4630      	mov	r0, r6
  40135c:	4790      	blx	r2
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40135e:	f854 3c08 	ldr.w	r3, [r4, #-8]
  401362:	ea25 0503 	bic.w	r5, r5, r3
  401366:	f104 0410 	add.w	r4, r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  40136a:	2d00      	cmp	r5, #0
  40136c:	d1eb      	bne.n	401346 <pio_handler_process+0x26>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  40136e:	f640 41dc 	movw	r1, #3292	; 0xcdc
  401372:	f2c2 0100 	movt	r1, #8192	; 0x2000
  401376:	6808      	ldr	r0, [r1, #0]
  401378:	b138      	cbz	r0, 40138a <pio_handler_process+0x6a>
		if (pio_capture_handler) {
  40137a:	f640 4224 	movw	r2, #3108	; 0xc24
  40137e:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401382:	6813      	ldr	r3, [r2, #0]
  401384:	b10b      	cbz	r3, 40138a <pio_handler_process+0x6a>
			pio_capture_handler(p_pio);
  401386:	4640      	mov	r0, r8
  401388:	4798      	blx	r3
  40138a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40138e:	bf00      	nop
  401390:	20000c34 	.word	0x20000c34

00401394 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  401394:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  401396:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  40139a:	f2c4 000e 	movt	r0, #16398	; 0x400e
  40139e:	f04f 010b 	mov.w	r1, #11
  4013a2:	f241 3321 	movw	r3, #4897	; 0x1321
  4013a6:	f2c0 0340 	movt	r3, #64	; 0x40
  4013aa:	4798      	blx	r3
  4013ac:	bd08      	pop	{r3, pc}
  4013ae:	bf00      	nop

004013b0 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  4013b0:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  4013b2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  4013b6:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4013ba:	f04f 010c 	mov.w	r1, #12
  4013be:	f241 3321 	movw	r3, #4897	; 0x1321
  4013c2:	f2c0 0340 	movt	r3, #64	; 0x40
  4013c6:	4798      	blx	r3
  4013c8:	bd08      	pop	{r3, pc}
  4013ca:	bf00      	nop

004013cc <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  4013cc:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  4013ce:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  4013d2:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4013d6:	f04f 010d 	mov.w	r1, #13
  4013da:	f241 3321 	movw	r3, #4897	; 0x1321
  4013de:	f2c0 0340 	movt	r3, #64	; 0x40
  4013e2:	4798      	blx	r3
  4013e4:	bd08      	pop	{r3, pc}
  4013e6:	bf00      	nop

004013e8 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4013e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4013ec:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4013f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  4013f2:	f022 0170 	bic.w	r1, r2, #112	; 0x70
  4013f6:	4308      	orrs	r0, r1
  4013f8:	6318      	str	r0, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4013fa:	6e98      	ldr	r0, [r3, #104]	; 0x68
  4013fc:	f010 0f08 	tst.w	r0, #8
  401400:	d007      	beq.n	401412 <pmc_switch_mck_to_pllack+0x2a>
  401402:	e010      	b.n	401426 <pmc_switch_mck_to_pllack+0x3e>
  401404:	f100 33ff 	add.w	r3, r0, #4294967295
  401408:	6e90      	ldr	r0, [r2, #104]	; 0x68
  40140a:	f010 0f08 	tst.w	r0, #8
  40140e:	d038      	beq.n	401482 <pmc_switch_mck_to_pllack+0x9a>
  401410:	e009      	b.n	401426 <pmc_switch_mck_to_pllack+0x3e>
  401412:	f44f 6000 	mov.w	r0, #2048	; 0x800
  401416:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40141a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40141e:	6e91      	ldr	r1, [r2, #104]	; 0x68
  401420:	f011 0f08 	tst.w	r1, #8
  401424:	d0ee      	beq.n	401404 <pmc_switch_mck_to_pllack+0x1c>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  401426:	f44f 6180 	mov.w	r1, #1024	; 0x400
  40142a:	f2c4 010e 	movt	r1, #16398	; 0x400e
  40142e:	6b0a      	ldr	r2, [r1, #48]	; 0x30
  401430:	f022 0303 	bic.w	r3, r2, #3
  401434:	f043 0002 	orr.w	r0, r3, #2
  401438:	6308      	str	r0, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40143a:	6e89      	ldr	r1, [r1, #104]	; 0x68
  40143c:	f011 0f08 	tst.w	r1, #8
  401440:	d009      	beq.n	401456 <pmc_switch_mck_to_pllack+0x6e>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  401442:	f04f 0000 	mov.w	r0, #0
  401446:	4770      	bx	lr
  401448:	f103 33ff 	add.w	r3, r3, #4294967295
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40144c:	6e91      	ldr	r1, [r2, #104]	; 0x68
  40144e:	f011 0f08 	tst.w	r1, #8
  401452:	d013      	beq.n	40147c <pmc_switch_mck_to_pllack+0x94>
  401454:	e009      	b.n	40146a <pmc_switch_mck_to_pllack+0x82>
  401456:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40145a:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40145e:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401462:	6e90      	ldr	r0, [r2, #104]	; 0x68
  401464:	f010 0f08 	tst.w	r0, #8
  401468:	d0ee      	beq.n	401448 <pmc_switch_mck_to_pllack+0x60>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  40146a:	f04f 0000 	mov.w	r0, #0
  40146e:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  401470:	f04f 0001 	mov.w	r0, #1
  401474:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  401476:	f04f 0001 	mov.w	r0, #1
		}
	}

	return 0;
}
  40147a:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  40147c:	3b01      	subs	r3, #1
  40147e:	d1f0      	bne.n	401462 <pmc_switch_mck_to_pllack+0x7a>
  401480:	e7f9      	b.n	401476 <pmc_switch_mck_to_pllack+0x8e>
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
  401482:	1e58      	subs	r0, r3, #1
  401484:	d1cb      	bne.n	40141e <pmc_switch_mck_to_pllack+0x36>
  401486:	e7f3      	b.n	401470 <pmc_switch_mck_to_pllack+0x88>

00401488 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  401488:	b188      	cbz	r0, 4014ae <pmc_switch_mainck_to_xtal+0x26>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40148a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  40148e:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401492:	6a08      	ldr	r0, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  401494:	f64f 72fc 	movw	r2, #65532	; 0xfffc
  401498:	f6cf 62c8 	movt	r2, #65224	; 0xfec8
  40149c:	4002      	ands	r2, r0
  40149e:	f04f 0302 	mov.w	r3, #2
  4014a2:	f2c0 1337 	movt	r3, #311	; 0x137
  4014a6:	ea42 0003 	orr.w	r0, r2, r3
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4014aa:	6208      	str	r0, [r1, #32]
  4014ac:	4770      	bx	lr
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4014ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014b2:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4014b6:	6a1a      	ldr	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4014b8:	f422 105c 	bic.w	r0, r2, #3604480	; 0x370000
  4014bc:	f020 0203 	bic.w	r2, r0, #3
  4014c0:	f442 105c 	orr.w	r0, r2, #3604480	; 0x370000
  4014c4:	f040 0201 	orr.w	r2, r0, #1
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4014c8:	ea4f 6101 	mov.w	r1, r1, lsl #24
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4014cc:	ea42 4011 	orr.w	r0, r2, r1, lsr #16
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4014d0:	6218      	str	r0, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4014d2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4014d6:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4014da:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4014dc:	f013 0f01 	tst.w	r3, #1
  4014e0:	d0fb      	beq.n	4014da <pmc_switch_mainck_to_xtal+0x52>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4014e2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  4014e6:	f2c4 010e 	movt	r1, #16398	; 0x400e
  4014ea:	6a08      	ldr	r0, [r1, #32]
  4014ec:	f040 729b 	orr.w	r2, r0, #20316160	; 0x1360000
  4014f0:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
  4014f4:	620b      	str	r3, [r1, #32]
  4014f6:	4770      	bx	lr

004014f8 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4014f8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4014fc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401500:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401502:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  401506:	4770      	bx	lr

00401508 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  401508:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40150c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401510:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  401514:	629a      	str	r2, [r3, #40]	; 0x28
  401516:	4770      	bx	lr

00401518 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  401518:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40151c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401520:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  401522:	f000 0002 	and.w	r0, r0, #2
  401526:	4770      	bx	lr

00401528 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  401528:	2822      	cmp	r0, #34	; 0x22
  40152a:	d835      	bhi.n	401598 <pmc_enable_periph_clk+0x70>
		return 1;
	}

	if (ul_id < 32) {
  40152c:	281f      	cmp	r0, #31
  40152e:	d817      	bhi.n	401560 <pmc_enable_periph_clk+0x38>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  401530:	f44f 6180 	mov.w	r1, #1024	; 0x400
  401534:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401538:	698a      	ldr	r2, [r1, #24]
  40153a:	f04f 0301 	mov.w	r3, #1
  40153e:	fa03 f300 	lsl.w	r3, r3, r0
  401542:	401a      	ands	r2, r3
  401544:	4293      	cmp	r3, r2
  401546:	d02a      	beq.n	40159e <pmc_enable_periph_clk+0x76>
			PMC->PMC_PCER0 = 1 << ul_id;
  401548:	f04f 0101 	mov.w	r1, #1
  40154c:	fa01 f000 	lsl.w	r0, r1, r0
  401550:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401554:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401558:	6110      	str	r0, [r2, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  40155a:	f04f 0000 	mov.w	r0, #0
  40155e:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CP)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  401560:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401564:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401568:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CP)
	} else {
		ul_id -= 32;
  40156c:	f1a0 0020 	sub.w	r0, r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  401570:	f04f 0101 	mov.w	r1, #1
  401574:	fa01 f100 	lsl.w	r1, r1, r0
  401578:	400a      	ands	r2, r1
  40157a:	4291      	cmp	r1, r2
  40157c:	d012      	beq.n	4015a4 <pmc_enable_periph_clk+0x7c>
			PMC->PMC_PCER1 = 1 << ul_id;
  40157e:	f04f 0301 	mov.w	r3, #1
  401582:	fa03 f000 	lsl.w	r0, r3, r0
  401586:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40158a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40158e:	f8c2 0100 	str.w	r0, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  401592:	f04f 0000 	mov.w	r0, #0
  401596:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  401598:	f04f 0001 	mov.w	r0, #1
  40159c:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  40159e:	f04f 0000 	mov.w	r0, #0
  4015a2:	4770      	bx	lr
  4015a4:	f04f 0000 	mov.w	r0, #0
}
  4015a8:	4770      	bx	lr
  4015aa:	bf00      	nop

004015ac <uart_init>:
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  4015ac:	b410      	push	{r4}
	uint32_t cd = 0;

	/* Reset and disable receiver & transmitter */
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
  4015ae:	f04f 03ac 	mov.w	r3, #172	; 0xac
  4015b2:	6003      	str	r3, [r0, #0]
			| UART_CR_RXDIS | UART_CR_TXDIS;

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
  4015b4:	680a      	ldr	r2, [r1, #0]
  4015b6:	684c      	ldr	r4, [r1, #4]
  4015b8:	fbb2 f3f4 	udiv	r3, r2, r4
  4015bc:	ea4f 1313 	mov.w	r3, r3, lsr #4
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
  4015c0:	f103 34ff 	add.w	r4, r3, #4294967295
  4015c4:	f64f 72fe 	movw	r2, #65534	; 0xfffe
  4015c8:	4294      	cmp	r4, r2
  4015ca:	d80c      	bhi.n	4015e6 <uart_init+0x3a>
		return 1;

	p_uart->UART_BRGR = cd;
  4015cc:	6203      	str	r3, [r0, #32]
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;
  4015ce:	6889      	ldr	r1, [r1, #8]
  4015d0:	6041      	str	r1, [r0, #4]

	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  4015d2:	f240 2302 	movw	r3, #514	; 0x202
  4015d6:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  4015da:	f04f 0250 	mov.w	r2, #80	; 0x50
  4015de:	6002      	str	r2, [r0, #0]

	return 0;
  4015e0:	f04f 0000 	mov.w	r0, #0
  4015e4:	e001      	b.n	4015ea <uart_init+0x3e>

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
		return 1;
  4015e6:	f04f 0001 	mov.w	r0, #1

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;

	return 0;
}
  4015ea:	bc10      	pop	{r4}
  4015ec:	4770      	bx	lr
  4015ee:	bf00      	nop

004015f0 <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  4015f0:	6943      	ldr	r3, [r0, #20]
  4015f2:	f013 0f02 	tst.w	r3, #2
  4015f6:	d003      	beq.n	401600 <uart_write+0x10>
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  4015f8:	61c1      	str	r1, [r0, #28]
	return 0;
  4015fa:	f04f 0000 	mov.w	r0, #0
  4015fe:	4770      	bx	lr
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
		return 1;
  401600:	f04f 0001 	mov.w	r0, #1

	/* Send character */
	p_uart->UART_THR = uc_data;
	return 0;
}
  401604:	4770      	bx	lr
  401606:	bf00      	nop

00401608 <uart_read>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
  401608:	6943      	ldr	r3, [r0, #20]
  40160a:	f013 0f01 	tst.w	r3, #1
  40160e:	d004      	beq.n	40161a <uart_read+0x12>
		return 1;

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
  401610:	6980      	ldr	r0, [r0, #24]
  401612:	7008      	strb	r0, [r1, #0]
	return 0;
  401614:	f04f 0000 	mov.w	r0, #0
  401618:	4770      	bx	lr
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
		return 1;
  40161a:	f04f 0001 	mov.w	r0, #1

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
	return 0;
}
  40161e:	4770      	bx	lr

00401620 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  401620:	6943      	ldr	r3, [r0, #20]
  401622:	f013 0f02 	tst.w	r3, #2
  401626:	d007      	beq.n	401638 <usart_write+0x18>
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  401628:	ea4f 51c1 	mov.w	r1, r1, lsl #23
  40162c:	ea4f 52d1 	mov.w	r2, r1, lsr #23
  401630:	61c2      	str	r2, [r0, #28]
	return 0;
  401632:	f04f 0000 	mov.w	r0, #0
  401636:	4770      	bx	lr
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
		return 1;
  401638:	f04f 0001 	mov.w	r0, #1
	}

	p_usart->US_THR = US_THR_TXCHR(c);
	return 0;
}
  40163c:	4770      	bx	lr
  40163e:	bf00      	nop

00401640 <usart_read>:
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  401640:	6943      	ldr	r3, [r0, #20]
  401642:	f013 0f01 	tst.w	r3, #1
  401646:	d008      	beq.n	40165a <usart_read+0x1a>
		return 1;
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  401648:	6980      	ldr	r0, [r0, #24]
  40164a:	ea4f 52c0 	mov.w	r2, r0, lsl #23
  40164e:	ea4f 53d2 	mov.w	r3, r2, lsr #23
  401652:	600b      	str	r3, [r1, #0]

	return 0;
  401654:	f04f 0000 	mov.w	r0, #0
  401658:	4770      	bx	lr
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
		return 1;
  40165a:	f04f 0001 	mov.w	r0, #1

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;

	return 0;
}
  40165e:	4770      	bx	lr

00401660 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  401660:	e7fe      	b.n	401660 <Dummy_Handler>
  401662:	bf00      	nop

00401664 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401664:	b538      	push	{r3, r4, r5, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  401666:	4b50      	ldr	r3, [pc, #320]	; (4017a8 <Reset_Handler+0x144>)
  401668:	4a50      	ldr	r2, [pc, #320]	; (4017ac <Reset_Handler+0x148>)
  40166a:	429a      	cmp	r2, r3
  40166c:	d929      	bls.n	4016c2 <Reset_Handler+0x5e>
		for (; pDest < &_erelocate;) {
  40166e:	4d50      	ldr	r5, [pc, #320]	; (4017b0 <Reset_Handler+0x14c>)
  401670:	4b4d      	ldr	r3, [pc, #308]	; (4017a8 <Reset_Handler+0x144>)
  401672:	42ab      	cmp	r3, r5
  401674:	d248      	bcs.n	401708 <Reset_Handler+0xa4>

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  401676:	f103 0004 	add.w	r0, r3, #4
  40167a:	4a4e      	ldr	r2, [pc, #312]	; (4017b4 <Reset_Handler+0x150>)
  40167c:	1a11      	subs	r1, r2, r0
  40167e:	f021 0403 	bic.w	r4, r1, #3
  401682:	f04f 0300 	mov.w	r3, #0
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
  401686:	f240 0200 	movw	r2, #0
  40168a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40168e:	f243 31a0 	movw	r1, #13216	; 0x33a0
  401692:	f2c0 0140 	movt	r1, #64	; 0x40
  401696:	f104 0004 	add.w	r0, r4, #4
  40169a:	f3c4 0480 	ubfx	r4, r4, #2, #1
  40169e:	585d      	ldr	r5, [r3, r1]
  4016a0:	509d      	str	r5, [r3, r2]
  4016a2:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  4016a6:	4283      	cmp	r3, r0
  4016a8:	d16d      	bne.n	401786 <Reset_Handler+0x122>
  4016aa:	e02d      	b.n	401708 <Reset_Handler+0xa4>
			*pDest++ = *pSrc++;
  4016ac:	585d      	ldr	r5, [r3, r1]
  4016ae:	509d      	str	r5, [r3, r2]
  4016b0:	f103 0304 	add.w	r3, r3, #4
  4016b4:	585c      	ldr	r4, [r3, r1]
  4016b6:	509c      	str	r4, [r3, r2]
  4016b8:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  4016bc:	4283      	cmp	r3, r0
  4016be:	d1f5      	bne.n	4016ac <Reset_Handler+0x48>
  4016c0:	e022      	b.n	401708 <Reset_Handler+0xa4>
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  4016c2:	4839      	ldr	r0, [pc, #228]	; (4017a8 <Reset_Handler+0x144>)
  4016c4:	4939      	ldr	r1, [pc, #228]	; (4017ac <Reset_Handler+0x148>)
  4016c6:	4281      	cmp	r1, r0
  4016c8:	d21e      	bcs.n	401708 <Reset_Handler+0xa4>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  4016ca:	f640 0548 	movw	r5, #2120	; 0x848
  4016ce:	f2c2 0500 	movt	r5, #8192	; 0x2000
  4016d2:	f240 0400 	movw	r4, #0
  4016d6:	f2c2 0400 	movt	r4, #8192	; 0x2000
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  4016da:	4b37      	ldr	r3, [pc, #220]	; (4017b8 <Reset_Handler+0x154>)
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4016dc:	1b2a      	subs	r2, r5, r4
  4016de:	d013      	beq.n	401708 <Reset_Handler+0xa4>
  4016e0:	f1a2 0004 	sub.w	r0, r2, #4
  4016e4:	f3c0 0180 	ubfx	r1, r0, #2, #1
			*pDest-- = *pSrc--;
  4016e8:	589c      	ldr	r4, [r3, r2]
  4016ea:	f845 4d04 	str.w	r4, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4016ee:	3a04      	subs	r2, #4
  4016f0:	d152      	bne.n	401798 <Reset_Handler+0x134>
  4016f2:	e009      	b.n	401708 <Reset_Handler+0xa4>
			*pDest-- = *pSrc--;
  4016f4:	5899      	ldr	r1, [r3, r2]
  4016f6:	f845 1d04 	str.w	r1, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4016fa:	f1a2 0204 	sub.w	r2, r2, #4
			*pDest-- = *pSrc--;
  4016fe:	589c      	ldr	r4, [r3, r2]
  401700:	f845 4d04 	str.w	r4, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  401704:	3a04      	subs	r2, #4
  401706:	d1f5      	bne.n	4016f4 <Reset_Handler+0x90>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  401708:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40170a:	4b2c      	ldr	r3, [pc, #176]	; (4017bc <Reset_Handler+0x158>)
  40170c:	4a2c      	ldr	r2, [pc, #176]	; (4017c0 <Reset_Handler+0x15c>)
  40170e:	429a      	cmp	r2, r3
  401710:	d21e      	bcs.n	401750 <Reset_Handler+0xec>
  401712:	f1a2 0504 	sub.w	r5, r2, #4

/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
  401716:	492b      	ldr	r1, [pc, #172]	; (4017c4 <Reset_Handler+0x160>)
  401718:	1b48      	subs	r0, r1, r5
  40171a:	f020 0403 	bic.w	r4, r0, #3
  40171e:	f640 0348 	movw	r3, #2120	; 0x848
  401722:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401726:	18e2      	adds	r2, r4, r3
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
		*pDest++ = 0;
  401728:	f04f 0100 	mov.w	r1, #0
  40172c:	1b50      	subs	r0, r2, r5
  40172e:	f1a0 0004 	sub.w	r0, r0, #4
  401732:	f3c0 0480 	ubfx	r4, r0, #2, #1
  401736:	f845 1f04 	str.w	r1, [r5, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40173a:	4295      	cmp	r5, r2
  40173c:	d11c      	bne.n	401778 <Reset_Handler+0x114>
  40173e:	e007      	b.n	401750 <Reset_Handler+0xec>
  401740:	f105 0304 	add.w	r3, r5, #4
		*pDest++ = 0;
  401744:	6069      	str	r1, [r5, #4]
  401746:	f105 0508 	add.w	r5, r5, #8
  40174a:	6059      	str	r1, [r3, #4]
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40174c:	4295      	cmp	r5, r2
  40174e:	d1f7      	bne.n	401740 <Reset_Handler+0xdc>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  401750:	f44f 456d 	mov.w	r5, #60672	; 0xed00
  401754:	f2ce 0500 	movt	r5, #57344	; 0xe000
  401758:	f240 0200 	movw	r2, #0
  40175c:	f2c0 0240 	movt	r2, #64	; 0x40
  401760:	60aa      	str	r2, [r5, #8]

	/* Initialize the C library */
	__libc_init_array();
  401762:	f641 7101 	movw	r1, #7937	; 0x1f01
  401766:	f2c0 0140 	movt	r1, #64	; 0x40
  40176a:	4788      	blx	r1

	/* Branch to main function */
	main();
  40176c:	f641 4039 	movw	r0, #7225	; 0x1c39
  401770:	f2c0 0040 	movt	r0, #64	; 0x40
  401774:	4780      	blx	r0
  401776:	e7fe      	b.n	401776 <Reset_Handler+0x112>
  401778:	2c00      	cmp	r4, #0
  40177a:	d0e1      	beq.n	401740 <Reset_Handler+0xdc>
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
		*pDest++ = 0;
  40177c:	f845 1f04 	str.w	r1, [r5, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401780:	4295      	cmp	r5, r2
  401782:	d1dd      	bne.n	401740 <Reset_Handler+0xdc>
  401784:	e7e4      	b.n	401750 <Reset_Handler+0xec>
  401786:	2c00      	cmp	r4, #0
  401788:	d090      	beq.n	4016ac <Reset_Handler+0x48>
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
  40178a:	585c      	ldr	r4, [r3, r1]
  40178c:	509c      	str	r4, [r3, r2]
  40178e:	f103 0304 	add.w	r3, r3, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  401792:	4283      	cmp	r3, r0
  401794:	d18a      	bne.n	4016ac <Reset_Handler+0x48>
  401796:	e7b7      	b.n	401708 <Reset_Handler+0xa4>
  401798:	2900      	cmp	r1, #0
  40179a:	d0ab      	beq.n	4016f4 <Reset_Handler+0x90>
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
			*pDest-- = *pSrc--;
  40179c:	5898      	ldr	r0, [r3, r2]
  40179e:	f845 0d04 	str.w	r0, [r5, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4017a2:	3a04      	subs	r2, #4
  4017a4:	d1a6      	bne.n	4016f4 <Reset_Handler+0x90>
  4017a6:	e7af      	b.n	401708 <Reset_Handler+0xa4>
  4017a8:	20000000 	.word	0x20000000
  4017ac:	004033a0 	.word	0x004033a0
  4017b0:	20000848 	.word	0x20000848
  4017b4:	2000084b 	.word	0x2000084b
  4017b8:	0040339c 	.word	0x0040339c
  4017bc:	20000cf4 	.word	0x20000cf4
  4017c0:	20000848 	.word	0x20000848
  4017c4:	20000cef 	.word	0x20000cef

004017c8 <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  4017c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4017cc:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4017d0:	6b18      	ldr	r0, [r3, #48]	; 0x30
  4017d2:	f000 0303 	and.w	r3, r0, #3
  4017d6:	2b03      	cmp	r3, #3
  4017d8:	f200 80a9 	bhi.w	40192e <SystemCoreClockUpdate+0x166>
  4017dc:	e8df f003 	tbb	[pc, r3]
  4017e0:	4f4f1402 	.word	0x4f4f1402
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  4017e4:	f241 4010 	movw	r0, #5136	; 0x1410
  4017e8:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4017ec:	6941      	ldr	r1, [r0, #20]
  4017ee:	f011 0f80 	tst.w	r1, #128	; 0x80
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  4017f2:	f240 0300 	movw	r3, #0
  4017f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  4017fa:	bf14      	ite	ne
  4017fc:	f44f 4200 	movne.w	r2, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401800:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  401804:	601a      	str	r2, [r3, #0]
  401806:	e092      	b.n	40192e <SystemCoreClockUpdate+0x166>
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  401808:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40180c:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401810:	6a18      	ldr	r0, [r3, #32]
  401812:	f010 7f80 	tst.w	r0, #16777216	; 0x1000000
  401816:	d009      	beq.n	40182c <SystemCoreClockUpdate+0x64>
			SystemCoreClock = CHIP_FREQ_XTAL;
  401818:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  40181c:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401820:	f240 0200 	movw	r2, #0
  401824:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401828:	6013      	str	r3, [r2, #0]
  40182a:	e080      	b.n	40192e <SystemCoreClockUpdate+0x166>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40182c:	f44f 6110 	mov.w	r1, #2304	; 0x900
  401830:	f2c0 013d 	movt	r1, #61	; 0x3d
  401834:	f240 0200 	movw	r2, #0
  401838:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40183c:	6011      	str	r1, [r2, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  40183e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401842:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401846:	6a18      	ldr	r0, [r3, #32]
  401848:	f000 0170 	and.w	r1, r0, #112	; 0x70
  40184c:	2910      	cmp	r1, #16
  40184e:	d002      	beq.n	401856 <SystemCoreClockUpdate+0x8e>
  401850:	2920      	cmp	r1, #32
  401852:	d16c      	bne.n	40192e <SystemCoreClockUpdate+0x166>
  401854:	e009      	b.n	40186a <SystemCoreClockUpdate+0xa2>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  401856:	f44f 5090 	mov.w	r0, #4608	; 0x1200
  40185a:	f2c0 007a 	movt	r0, #122	; 0x7a
  40185e:	f240 0100 	movw	r1, #0
  401862:	f2c2 0100 	movt	r1, #8192	; 0x2000
  401866:	6008      	str	r0, [r1, #0]
			break;
  401868:	e061      	b.n	40192e <SystemCoreClockUpdate+0x166>
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  40186a:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  40186e:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401872:	f240 0200 	movw	r2, #0
  401876:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40187a:	6013      	str	r3, [r2, #0]
			break;
  40187c:	e057      	b.n	40192e <SystemCoreClockUpdate+0x166>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40187e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401882:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401886:	6a13      	ldr	r3, [r2, #32]
  401888:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  40188c:	d009      	beq.n	4018a2 <SystemCoreClockUpdate+0xda>
				SystemCoreClock = CHIP_FREQ_XTAL;
  40188e:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  401892:	f2c0 03b7 	movt	r3, #183	; 0xb7
  401896:	f240 0200 	movw	r2, #0
  40189a:	f2c2 0200 	movt	r2, #8192	; 0x2000
  40189e:	6013      	str	r3, [r2, #0]
  4018a0:	e027      	b.n	4018f2 <SystemCoreClockUpdate+0x12a>
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4018a2:	f44f 6310 	mov.w	r3, #2304	; 0x900
  4018a6:	f2c0 033d 	movt	r3, #61	; 0x3d
  4018aa:	f240 0200 	movw	r2, #0
  4018ae:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4018b2:	6013      	str	r3, [r2, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  4018b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4018b8:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4018bc:	6a1a      	ldr	r2, [r3, #32]
  4018be:	f002 0370 	and.w	r3, r2, #112	; 0x70
  4018c2:	2b10      	cmp	r3, #16
  4018c4:	d002      	beq.n	4018cc <SystemCoreClockUpdate+0x104>
  4018c6:	2b20      	cmp	r3, #32
  4018c8:	d113      	bne.n	4018f2 <SystemCoreClockUpdate+0x12a>
  4018ca:	e009      	b.n	4018e0 <SystemCoreClockUpdate+0x118>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  4018cc:	f44f 5390 	mov.w	r3, #4608	; 0x1200
  4018d0:	f2c0 037a 	movt	r3, #122	; 0x7a
  4018d4:	f240 0200 	movw	r2, #0
  4018d8:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4018dc:	6013      	str	r3, [r2, #0]
					break;
  4018de:	e008      	b.n	4018f2 <SystemCoreClockUpdate+0x12a>
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  4018e0:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
  4018e4:	f2c0 03b7 	movt	r3, #183	; 0xb7
  4018e8:	f240 0200 	movw	r2, #0
  4018ec:	f2c2 0200 	movt	r2, #8192	; 0x2000
  4018f0:	6013      	str	r3, [r2, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  4018f2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4018f6:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4018fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  4018fc:	f002 0303 	and.w	r3, r2, #3
  401900:	2b02      	cmp	r3, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  401902:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401906:	f2c4 020e 	movt	r2, #16398	; 0x400e
  40190a:	bf07      	ittee	eq
  40190c:	6a90      	ldreq	r0, [r2, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  40190e:	6a91      	ldreq	r1, [r2, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  401910:	6ad0      	ldrne	r0, [r2, #44]	; 0x2c
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  401912:	6ad1      	ldrne	r1, [r2, #44]	; 0x2c
  401914:	f240 0300 	movw	r3, #0
  401918:	f2c2 0300 	movt	r3, #8192	; 0x2000
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  40191c:	f3c0 400a 	ubfx	r0, r0, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  401920:	681a      	ldr	r2, [r3, #0]
  401922:	fb00 2002 	mla	r0, r0, r2, r2
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
						>> CKGR_PLLBR_DIVB_Pos));
  401926:	b2c9      	uxtb	r1, r1
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  401928:	fbb0 f2f1 	udiv	r2, r0, r1
  40192c:	601a      	str	r2, [r3, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  40192e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401932:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401936:	6b10      	ldr	r0, [r2, #48]	; 0x30
  401938:	f000 0170 	and.w	r1, r0, #112	; 0x70
  40193c:	2970      	cmp	r1, #112	; 0x70
  40193e:	d10e      	bne.n	40195e <SystemCoreClockUpdate+0x196>
		SystemCoreClock /= 3U;
  401940:	f240 0300 	movw	r3, #0
  401944:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401948:	6818      	ldr	r0, [r3, #0]
  40194a:	f64a 22ab 	movw	r2, #43691	; 0xaaab
  40194e:	f6ca 22aa 	movt	r2, #43690	; 0xaaaa
  401952:	fba2 0100 	umull	r0, r1, r2, r0
  401956:	ea4f 0051 	mov.w	r0, r1, lsr #1
  40195a:	6018      	str	r0, [r3, #0]
  40195c:	4770      	bx	lr
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  40195e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401962:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401966:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  401968:	f240 0000 	movw	r0, #0
  40196c:	f2c2 0000 	movt	r0, #8192	; 0x2000
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  401970:	f3c2 1102 	ubfx	r1, r2, #4, #3
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  401974:	6803      	ldr	r3, [r0, #0]
  401976:	fa23 f301 	lsr.w	r3, r3, r1
  40197a:	6003      	str	r3, [r0, #0]
  40197c:	4770      	bx	lr
  40197e:	bf00      	nop

00401980 <system_init_flash>:
				}
			}
		}
	}
#else
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  401980:	f642 43ff 	movw	r3, #11519	; 0x2cff
  401984:	f2c0 1331 	movt	r3, #305	; 0x131
  401988:	4298      	cmp	r0, r3
  40198a:	d80c      	bhi.n	4019a6 <system_init_flash+0x26>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  40198c:	f44f 6120 	mov.w	r1, #2560	; 0xa00
  401990:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401994:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
  401998:	6008      	str	r0, [r1, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  40199a:	f44f 6340 	mov.w	r3, #3072	; 0xc00
  40199e:	f2c4 030e 	movt	r3, #16398	; 0x400e
  4019a2:	6018      	str	r0, [r3, #0]
  4019a4:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  4019a6:	f645 11ff 	movw	r1, #23039	; 0x59ff
  4019aa:	f2c0 2162 	movt	r1, #610	; 0x262
  4019ae:	4288      	cmp	r0, r1
  4019b0:	d80e      	bhi.n	4019d0 <system_init_flash+0x50>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4019b2:	f44f 6020 	mov.w	r0, #2560	; 0xa00
  4019b6:	f2c4 000e 	movt	r0, #16398	; 0x400e
  4019ba:	f44f 7380 	mov.w	r3, #256	; 0x100
  4019be:	f2c0 4300 	movt	r3, #1024	; 0x400
  4019c2:	6003      	str	r3, [r0, #0]
			EFC1->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4019c4:	f44f 6240 	mov.w	r2, #3072	; 0xc00
  4019c8:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4019cc:	6013      	str	r3, [r2, #0]
  4019ce:	4770      	bx	lr
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  4019d0:	f248 62ff 	movw	r2, #34559	; 0x86ff
  4019d4:	f2c0 3293 	movt	r2, #915	; 0x393
  4019d8:	4290      	cmp	r0, r2
  4019da:	d80e      	bhi.n	4019fa <system_init_flash+0x7a>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4019dc:	f44f 6220 	mov.w	r2, #2560	; 0xa00
  4019e0:	f2c4 020e 	movt	r2, #16398	; 0x400e
  4019e4:	f44f 7300 	mov.w	r3, #512	; 0x200
  4019e8:	f2c0 4300 	movt	r3, #1024	; 0x400
  4019ec:	6013      	str	r3, [r2, #0]
				EFC1->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4019ee:	f44f 6140 	mov.w	r1, #3072	; 0xc00
  4019f2:	f2c4 010e 	movt	r1, #16398	; 0x400e
  4019f6:	600b      	str	r3, [r1, #0]
  4019f8:	4770      	bx	lr
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  4019fa:	f24b 33ff 	movw	r3, #46079	; 0xb3ff
  4019fe:	f2c0 43c4 	movt	r3, #1220	; 0x4c4
  401a02:	4298      	cmp	r0, r3
  401a04:	d80e      	bhi.n	401a24 <system_init_flash+0xa4>
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  401a06:	f44f 6220 	mov.w	r2, #2560	; 0xa00
  401a0a:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401a0e:	f44f 7140 	mov.w	r1, #768	; 0x300
  401a12:	f2c0 4100 	movt	r1, #1024	; 0x400
  401a16:	6011      	str	r1, [r2, #0]
					EFC1->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  401a18:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  401a1c:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401a20:	6001      	str	r1, [r0, #0]
  401a22:	4770      	bx	lr
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  401a24:	f24e 01ff 	movw	r1, #57599	; 0xe0ff
  401a28:	f2c0 51f5 	movt	r1, #1525	; 0x5f5
  401a2c:	4288      	cmp	r0, r1
  401a2e:	d80c      	bhi.n	401a4a <system_init_flash+0xca>
						EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401a30:	f44f 6120 	mov.w	r1, #2560	; 0xa00
  401a34:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401a38:	f04f 2004 	mov.w	r0, #67109888	; 0x4000400
  401a3c:	6008      	str	r0, [r1, #0]
						EFC1->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401a3e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
  401a42:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401a46:	6018      	str	r0, [r3, #0]
  401a48:	4770      	bx	lr
					} else {
						EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  401a4a:	f44f 6020 	mov.w	r0, #2560	; 0xa00
  401a4e:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401a52:	f44f 63a0 	mov.w	r3, #1280	; 0x500
  401a56:	f2c0 4300 	movt	r3, #1024	; 0x400
  401a5a:	6003      	str	r3, [r0, #0]
						EFC1->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  401a5c:	f44f 6240 	mov.w	r2, #3072	; 0xc00
  401a60:	f2c4 020e 	movt	r2, #16398	; 0x400e
  401a64:	6013      	str	r3, [r2, #0]
  401a66:	4770      	bx	lr

00401a68 <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  401a68:	f640 4398 	movw	r3, #3224	; 0xc98
  401a6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a70:	6819      	ldr	r1, [r3, #0]
  401a72:	b941      	cbnz	r1, 401a86 <_sbrk+0x1e>
		heap = (unsigned char *)&_end;
  401a74:	f640 4398 	movw	r3, #3224	; 0xc98
  401a78:	f2c2 0300 	movt	r3, #8192	; 0x2000
  401a7c:	f643 42f8 	movw	r2, #15608	; 0x3cf8
  401a80:	f2c2 0200 	movt	r2, #8192	; 0x2000
  401a84:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  401a86:	f640 4198 	movw	r1, #3224	; 0xc98
  401a8a:	f2c2 0100 	movt	r1, #8192	; 0x2000
  401a8e:	680b      	ldr	r3, [r1, #0]

	if (((int)prev_heap + incr) > ramend) {
  401a90:	1818      	adds	r0, r3, r0
  401a92:	f647 72fc 	movw	r2, #32764	; 0x7ffc
  401a96:	f2c2 0202 	movt	r2, #8194	; 0x2002
  401a9a:	4282      	cmp	r2, r0
  401a9c:	db06      	blt.n	401aac <_sbrk+0x44>
		return (caddr_t) -1;	
	}

	heap += incr;
  401a9e:	4601      	mov	r1, r0
  401aa0:	f640 4098 	movw	r0, #3224	; 0xc98
  401aa4:	f2c2 0000 	movt	r0, #8192	; 0x2000
  401aa8:	6001      	str	r1, [r0, #0]

	return (caddr_t) prev_heap;
  401aaa:	e001      	b.n	401ab0 <_sbrk+0x48>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  401aac:	f04f 33ff 	mov.w	r3, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  401ab0:	4618      	mov	r0, r3
  401ab2:	4770      	bx	lr

00401ab4 <_close>:
}

extern int _close(int file)
{
	return -1;
}
  401ab4:	f04f 30ff 	mov.w	r0, #4294967295
  401ab8:	4770      	bx	lr
  401aba:	bf00      	nop

00401abc <_lseek>:
}

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
  401abc:	f04f 0000 	mov.w	r0, #0
  401ac0:	4770      	bx	lr
  401ac2:	bf00      	nop

00401ac4 <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  401ac4:	b5f0      	push	{r4, r5, r6, r7, lr}
  401ac6:	b083      	sub	sp, #12
  401ac8:	4604      	mov	r4, r0
  401aca:	460d      	mov	r5, r1
	uint32_t val = 0;
  401acc:	f04f 0300 	mov.w	r3, #0
  401ad0:	9301      	str	r3, [sp, #4]
	if (UART == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  401ad2:	f44f 60c0 	mov.w	r0, #1536	; 0x600
  401ad6:	f2c4 000e 	movt	r0, #16398	; 0x400e
  401ada:	4284      	cmp	r4, r0
  401adc:	d10d      	bne.n	401afa <usart_serial_getchar+0x36>
		while (uart_read((Uart*)p_usart, data));
  401ade:	f44f 66c0 	mov.w	r6, #1536	; 0x600
  401ae2:	f2c4 060e 	movt	r6, #16398	; 0x400e
  401ae6:	f241 6709 	movw	r7, #5641	; 0x1609
  401aea:	f2c0 0740 	movt	r7, #64	; 0x40
  401aee:	4630      	mov	r0, r6
  401af0:	4629      	mov	r1, r5
  401af2:	47b8      	blx	r7
  401af4:	2800      	cmp	r0, #0
  401af6:	d1fa      	bne.n	401aee <usart_serial_getchar+0x2a>
  401af8:	e029      	b.n	401b4e <usart_serial_getchar+0x8a>
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  401afa:	f44f 6100 	mov.w	r1, #2048	; 0x800
  401afe:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401b02:	428c      	cmp	r4, r1
  401b04:	d10d      	bne.n	401b22 <usart_serial_getchar+0x5e>
		while (uart_read((Uart*)p_usart, data));
  401b06:	f44f 6400 	mov.w	r4, #2048	; 0x800
  401b0a:	f2c4 040e 	movt	r4, #16398	; 0x400e
  401b0e:	f241 6609 	movw	r6, #5641	; 0x1609
  401b12:	f2c0 0640 	movt	r6, #64	; 0x40
  401b16:	4620      	mov	r0, r4
  401b18:	4629      	mov	r1, r5
  401b1a:	47b0      	blx	r6
  401b1c:	2800      	cmp	r0, #0
  401b1e:	d1fa      	bne.n	401b16 <usart_serial_getchar+0x52>
  401b20:	e02a      	b.n	401b78 <usart_serial_getchar+0xb4>
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  401b22:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  401b26:	f2c4 0202 	movt	r2, #16386	; 0x4002
  401b2a:	4294      	cmp	r4, r2
  401b2c:	d10f      	bne.n	401b4e <usart_serial_getchar+0x8a>
		while (usart_read(p_usart, &val));
  401b2e:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  401b32:	f2c4 0402 	movt	r4, #16386	; 0x4002
  401b36:	f241 6641 	movw	r6, #5697	; 0x1641
  401b3a:	f2c0 0640 	movt	r6, #64	; 0x40
  401b3e:	4620      	mov	r0, r4
  401b40:	a901      	add	r1, sp, #4
  401b42:	47b0      	blx	r6
  401b44:	2800      	cmp	r0, #0
  401b46:	d1fa      	bne.n	401b3e <usart_serial_getchar+0x7a>
		*data = (uint8_t)(val & 0xFF);
  401b48:	9b01      	ldr	r3, [sp, #4]
  401b4a:	702b      	strb	r3, [r5, #0]
  401b4c:	e014      	b.n	401b78 <usart_serial_getchar+0xb4>
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  401b4e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  401b52:	f2c4 0002 	movt	r0, #16386	; 0x4002
  401b56:	4284      	cmp	r4, r0
  401b58:	d10e      	bne.n	401b78 <usart_serial_getchar+0xb4>
		while (usart_read(p_usart, &val));
  401b5a:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  401b5e:	f2c4 0402 	movt	r4, #16386	; 0x4002
  401b62:	f241 6641 	movw	r6, #5697	; 0x1641
  401b66:	f2c0 0640 	movt	r6, #64	; 0x40
  401b6a:	4620      	mov	r0, r4
  401b6c:	a901      	add	r1, sp, #4
  401b6e:	47b0      	blx	r6
  401b70:	2800      	cmp	r0, #0
  401b72:	d1fa      	bne.n	401b6a <usart_serial_getchar+0xa6>
		*data = (uint8_t)(val & 0xFF);
  401b74:	9901      	ldr	r1, [sp, #4]
  401b76:	7029      	strb	r1, [r5, #0]
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  401b78:	b003      	add	sp, #12
  401b7a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00401b7c <usart_serial_putchar>:
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  401b7c:	b570      	push	{r4, r5, r6, lr}
  401b7e:	460c      	mov	r4, r1
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  401b80:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  401b84:	f2c4 030e 	movt	r3, #16398	; 0x400e
  401b88:	4298      	cmp	r0, r3
  401b8a:	d10f      	bne.n	401bac <usart_serial_putchar+0x30>
		while (uart_write((Uart*)p_usart, c)!=0);
  401b8c:	f44f 65c0 	mov.w	r5, #1536	; 0x600
  401b90:	f2c4 050e 	movt	r5, #16398	; 0x400e
  401b94:	f241 56f1 	movw	r6, #5617	; 0x15f1
  401b98:	f2c0 0640 	movt	r6, #64	; 0x40
  401b9c:	4628      	mov	r0, r5
  401b9e:	4621      	mov	r1, r4
  401ba0:	47b0      	blx	r6
  401ba2:	2800      	cmp	r0, #0
  401ba4:	d1fa      	bne.n	401b9c <usart_serial_putchar+0x20>
		return 1;
  401ba6:	f04f 0001 	mov.w	r0, #1
  401baa:	bd70      	pop	{r4, r5, r6, pc}
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  401bac:	f44f 6100 	mov.w	r1, #2048	; 0x800
  401bb0:	f2c4 010e 	movt	r1, #16398	; 0x400e
  401bb4:	4288      	cmp	r0, r1
  401bb6:	d10f      	bne.n	401bd8 <usart_serial_putchar+0x5c>
		while (uart_write((Uart*)p_usart, c)!=0);
  401bb8:	f44f 6500 	mov.w	r5, #2048	; 0x800
  401bbc:	f2c4 050e 	movt	r5, #16398	; 0x400e
  401bc0:	f241 56f1 	movw	r6, #5617	; 0x15f1
  401bc4:	f2c0 0640 	movt	r6, #64	; 0x40
  401bc8:	4628      	mov	r0, r5
  401bca:	4621      	mov	r1, r4
  401bcc:	47b0      	blx	r6
  401bce:	2800      	cmp	r0, #0
  401bd0:	d1fa      	bne.n	401bc8 <usart_serial_putchar+0x4c>
		return 1;
  401bd2:	f04f 0001 	mov.w	r0, #1
  401bd6:	bd70      	pop	{r4, r5, r6, pc}
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  401bd8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  401bdc:	f2c4 0202 	movt	r2, #16386	; 0x4002
  401be0:	4290      	cmp	r0, r2
  401be2:	d10f      	bne.n	401c04 <usart_serial_putchar+0x88>
		while (usart_write(p_usart, c)!=0);
  401be4:	f44f 4580 	mov.w	r5, #16384	; 0x4000
  401be8:	f2c4 0502 	movt	r5, #16386	; 0x4002
  401bec:	f241 6621 	movw	r6, #5665	; 0x1621
  401bf0:	f2c0 0640 	movt	r6, #64	; 0x40
  401bf4:	4628      	mov	r0, r5
  401bf6:	4621      	mov	r1, r4
  401bf8:	47b0      	blx	r6
  401bfa:	2800      	cmp	r0, #0
  401bfc:	d1fa      	bne.n	401bf4 <usart_serial_putchar+0x78>
		return 1;
  401bfe:	f04f 0001 	mov.w	r0, #1
  401c02:	bd70      	pop	{r4, r5, r6, pc}
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  401c04:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401c08:	f2c4 0302 	movt	r3, #16386	; 0x4002
  401c0c:	4298      	cmp	r0, r3
  401c0e:	d10f      	bne.n	401c30 <usart_serial_putchar+0xb4>
		while (usart_write(p_usart, c)!=0);
  401c10:	f44f 4500 	mov.w	r5, #32768	; 0x8000
  401c14:	f2c4 0502 	movt	r5, #16386	; 0x4002
  401c18:	f241 6621 	movw	r6, #5665	; 0x1621
  401c1c:	f2c0 0640 	movt	r6, #64	; 0x40
  401c20:	4628      	mov	r0, r5
  401c22:	4621      	mov	r1, r4
  401c24:	47b0      	blx	r6
  401c26:	2800      	cmp	r0, #0
  401c28:	d1fa      	bne.n	401c20 <usart_serial_putchar+0xa4>
		return 1;
  401c2a:	f04f 0001 	mov.w	r0, #1
  401c2e:	bd70      	pop	{r4, r5, r6, pc}
		return 1;
	}
# endif
#endif /* ifdef USART */

	return 0;
  401c30:	f04f 0000 	mov.w	r0, #0
}
  401c34:	bd70      	pop	{r4, r5, r6, pc}
  401c36:	bf00      	nop

00401c38 <main>:
 * \brief Application entry point for smc_lcd example.
 *
 * \return Unused (ANSI-C compatibility).
 */
int main(void)
{
  401c38:	b580      	push	{r7, lr}
  401c3a:	b084      	sub	sp, #16
	sysclk_init();
  401c3c:	f240 137d 	movw	r3, #381	; 0x17d
  401c40:	f2c0 0340 	movt	r3, #64	; 0x40
  401c44:	4798      	blx	r3
	board_init();
  401c46:	f240 301d 	movw	r0, #797	; 0x31d
  401c4a:	f2c0 0040 	movt	r0, #64	; 0x40
  401c4e:	4780      	blx	r0
  401c50:	f04f 0008 	mov.w	r0, #8
  401c54:	f241 5429 	movw	r4, #5417	; 0x1529
  401c58:	f2c0 0440 	movt	r4, #64	; 0x40
  401c5c:	47a0      	blx	r4
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
  401c5e:	f44f 65c0 	mov.w	r5, #1536	; 0x600
  401c62:	f2c4 050e 	movt	r5, #16398	; 0x400e
  401c66:	f640 41d8 	movw	r1, #3288	; 0xcd8
  401c6a:	f2c2 0100 	movt	r1, #8192	; 0x2000
  401c6e:	600d      	str	r5, [r1, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  401c70:	f640 46d4 	movw	r6, #3284	; 0xcd4
  401c74:	f2c2 0600 	movt	r6, #8192	; 0x2000
  401c78:	f641 327d 	movw	r2, #7037	; 0x1b7d
  401c7c:	f2c0 0240 	movt	r2, #64	; 0x40
  401c80:	6032      	str	r2, [r6, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
  401c82:	f640 47d0 	movw	r7, #3280	; 0xcd0
  401c86:	f2c2 0700 	movt	r7, #8192	; 0x2000
  401c8a:	f641 23c5 	movw	r3, #6853	; 0x1ac5
  401c8e:	f2c0 0340 	movt	r3, #64	; 0x40
  401c92:	603b      	str	r3, [r7, #0]
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
#if (!SAM4L)
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  401c94:	f44f 6060 	mov.w	r0, #3584	; 0xe00
  401c98:	f2c0 7027 	movt	r0, #1831	; 0x727
  401c9c:	9000      	str	r0, [sp, #0]
	uart_settings.ul_baudrate = opt->baudrate;
  401c9e:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
  401ca2:	9101      	str	r1, [sp, #4]
	uart_settings.ul_mode = opt->paritytype;
  401ca4:	f44f 6600 	mov.w	r6, #2048	; 0x800
  401ca8:	9602      	str	r6, [sp, #8]
  401caa:	f04f 0008 	mov.w	r0, #8
  401cae:	47a0      	blx	r4
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		sysclk_enable_peripheral_clock(ID_UART0);
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
  401cb0:	4628      	mov	r0, r5
  401cb2:	4669      	mov	r1, sp
  401cb4:	f241 55ad 	movw	r5, #5549	; 0x15ad
  401cb8:	f2c0 0540 	movt	r5, #64	; 0x40
  401cbc:	47a8      	blx	r5
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  401cbe:	f240 0708 	movw	r7, #8
  401cc2:	f2c2 0700 	movt	r7, #8192	; 0x2000
  401cc6:	683a      	ldr	r2, [r7, #0]
  401cc8:	6890      	ldr	r0, [r2, #8]
  401cca:	f04f 0100 	mov.w	r1, #0
  401cce:	f641 765d 	movw	r6, #8029	; 0x1f5d
  401cd2:	f2c0 0640 	movt	r6, #64	; 0x40
  401cd6:	47b0      	blx	r6
	setbuf(stdin, NULL);
  401cd8:	683b      	ldr	r3, [r7, #0]
  401cda:	6858      	ldr	r0, [r3, #4]
  401cdc:	f04f 0100 	mov.w	r1, #0
  401ce0:	47b0      	blx	r6
	
	/* Initialize debug console */
	configure_console();

	/* Enable peripheral clock */
	pmc_enable_periph_clk(ID_SMC);
  401ce2:	f04f 000a 	mov.w	r0, #10
  401ce6:	47a0      	blx	r4

	/* Configure SMC interface for Lcd */
	smc_set_setup_timing(SMC,ILI9325_LCD_CS,SMC_SETUP_NWE_SETUP(2)
  401ce8:	f04f 0400 	mov.w	r4, #0
  401cec:	f2c4 040e 	movt	r4, #16398	; 0x400e
  401cf0:	4620      	mov	r0, r4
  401cf2:	f04f 0101 	mov.w	r1, #1
  401cf6:	f04f 3202 	mov.w	r2, #33686018	; 0x2020202
  401cfa:	f640 752d 	movw	r5, #3885	; 0xf2d
  401cfe:	f2c0 0540 	movt	r5, #64	; 0x40
  401d02:	47a8      	blx	r5
			| SMC_SETUP_NCS_WR_SETUP(2)
			| SMC_SETUP_NRD_SETUP(2)
			| SMC_SETUP_NCS_RD_SETUP(2));
	smc_set_pulse_timing(SMC, ILI9325_LCD_CS , SMC_PULSE_NWE_PULSE(4)
  401d04:	4620      	mov	r0, r4
  401d06:	f04f 0101 	mov.w	r1, #1
  401d0a:	f240 4204 	movw	r2, #1028	; 0x404
  401d0e:	f6c0 220a 	movt	r2, #2570	; 0xa0a
  401d12:	f640 7735 	movw	r7, #3893	; 0xf35
  401d16:	f2c0 0740 	movt	r7, #64	; 0x40
  401d1a:	47b8      	blx	r7
			| SMC_PULSE_NCS_WR_PULSE(4)
			| SMC_PULSE_NRD_PULSE(10)
			| SMC_PULSE_NCS_RD_PULSE(10));
	smc_set_cycle_timing(SMC, ILI9325_LCD_CS, SMC_CYCLE_NWE_CYCLE(10)
  401d1c:	4620      	mov	r0, r4
  401d1e:	f04f 0101 	mov.w	r1, #1
  401d22:	f04f 020a 	mov.w	r2, #10
  401d26:	f2c0 0216 	movt	r2, #22
  401d2a:	f640 763d 	movw	r6, #3901	; 0xf3d
  401d2e:	f2c0 0640 	movt	r6, #64	; 0x40
  401d32:	47b0      	blx	r6
#if !defined(SAM4S)
	smc_set_mode(SMC, ILI9325_LCD_CS, SMC_MODE_READ_MODE
			| SMC_MODE_WRITE_MODE
			| SMC_MODE_DBW_8_BIT);
#else
	smc_set_mode(SMC, ILI9325_LCD_CS, SMC_MODE_READ_MODE
  401d34:	4620      	mov	r0, r4
  401d36:	f04f 0101 	mov.w	r1, #1
  401d3a:	f04f 0203 	mov.w	r2, #3
  401d3e:	f640 7345 	movw	r3, #3909	; 0xf45
  401d42:	f2c0 0340 	movt	r3, #64	; 0x40
  401d46:	4798      	blx	r3
			| SMC_MODE_WRITE_MODE);
#endif
	/* Initialize display parameter */
	g_ili9325_display_opt.ul_width = ILI9325_LCD_WIDTH;
  401d48:	f640 45e0 	movw	r5, #3296	; 0xce0
  401d4c:	f2c2 0500 	movt	r5, #8192	; 0x2000
  401d50:	f04f 07f0 	mov.w	r7, #240	; 0xf0
  401d54:	602f      	str	r7, [r5, #0]
	g_ili9325_display_opt.ul_height = ILI9325_LCD_HEIGHT;
  401d56:	f44f 76a0 	mov.w	r6, #320	; 0x140
  401d5a:	606e      	str	r6, [r5, #4]
	g_ili9325_display_opt.foreground_color = COLOR_BLACK;
  401d5c:	f04f 0400 	mov.w	r4, #0
  401d60:	60ac      	str	r4, [r5, #8]
	g_ili9325_display_opt.background_color = COLOR_WHITE;
  401d62:	f06f 487f 	mvn.w	r8, #4278190080	; 0xff000000
  401d66:	f8c5 800c 	str.w	r8, [r5, #12]

	/* Switch off backlight */
	aat31xx_disable_backlight();
  401d6a:	f240 4079 	movw	r0, #1145	; 0x479
  401d6e:	f2c0 0040 	movt	r0, #64	; 0x40
  401d72:	4780      	blx	r0

	/* Initialize LCD */
	ili9325_init(&g_ili9325_display_opt);
  401d74:	4628      	mov	r0, r5
  401d76:	f240 7171 	movw	r1, #1905	; 0x771
  401d7a:	f2c0 0140 	movt	r1, #64	; 0x40
  401d7e:	4788      	blx	r1

	/* Set backlight level */
	aat31xx_set_backlight(AAT31XX_AVG_BACKLIGHT_LEVEL);
  401d80:	f04f 0008 	mov.w	r0, #8
  401d84:	f240 420d 	movw	r2, #1037	; 0x40d
  401d88:	f2c0 0240 	movt	r2, #64	; 0x40
  401d8c:	4790      	blx	r2

	ili9325_set_foreground_color(COLOR_WHITE);
  401d8e:	4640      	mov	r0, r8
  401d90:	f240 65e5 	movw	r5, #1765	; 0x6e5
  401d94:	f2c0 0540 	movt	r5, #64	; 0x40
  401d98:	47a8      	blx	r5
	ili9325_draw_filled_rectangle(0, 0, ILI9325_LCD_WIDTH, ILI9325_LCD_HEIGHT);
  401d9a:	4620      	mov	r0, r4
  401d9c:	4621      	mov	r1, r4
  401d9e:	463a      	mov	r2, r7
  401da0:	4633      	mov	r3, r6
  401da2:	f640 2c15 	movw	ip, #2581	; 0xa15
  401da6:	f2c0 0c40 	movt	ip, #64	; 0x40
  401daa:	47e0      	blx	ip

	/* Turn on LCD */
	ili9325_display_on();
  401dac:	f240 63cd 	movw	r3, #1741	; 0x6cd
  401db0:	f2c0 0340 	movt	r3, #64	; 0x40
  401db4:	4798      	blx	r3

	/* Draw text, image and basic shapes on the LCD */
	ili9325_set_foreground_color(COLOR_BLACK);
  401db6:	4620      	mov	r0, r4
  401db8:	47a8      	blx	r5
	ili9325_draw_string(10, 20, (uint8_t *)"ili9325_lcd example");
  401dba:	f04f 000a 	mov.w	r0, #10
  401dbe:	f04f 0114 	mov.w	r1, #20
  401dc2:	f243 3260 	movw	r2, #13152	; 0x3360
  401dc6:	f2c0 0240 	movt	r2, #64	; 0x40
  401dca:	f640 5385 	movw	r3, #3461	; 0xd85
  401dce:	f2c0 0340 	movt	r3, #64	; 0x40
  401dd2:	4798      	blx	r3

	ili9325_set_foreground_color(COLOR_RED);
  401dd4:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
  401dd8:	47a8      	blx	r5
	ili9325_draw_circle(60, 160, 40);
  401dda:	f04f 003c 	mov.w	r0, #60	; 0x3c
  401dde:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  401de2:	f04f 0228 	mov.w	r2, #40	; 0x28
  401de6:	f640 48d1 	movw	r8, #3281	; 0xcd1
  401dea:	f2c0 0840 	movt	r8, #64	; 0x40
  401dee:	47c0      	blx	r8
	ili9325_set_foreground_color(COLOR_GREEN);
  401df0:	f44f 407f 	mov.w	r0, #65280	; 0xff00
  401df4:	47a8      	blx	r5
	ili9325_draw_circle(120, 160, 40);
  401df6:	f04f 0078 	mov.w	r0, #120	; 0x78
  401dfa:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  401dfe:	f04f 0228 	mov.w	r2, #40	; 0x28
  401e02:	47c0      	blx	r8
	ili9325_set_foreground_color(COLOR_BLUE);
  401e04:	f04f 00ff 	mov.w	r0, #255	; 0xff
  401e08:	47a8      	blx	r5
	ili9325_draw_circle(180, 160, 40);
  401e0a:	f04f 00b4 	mov.w	r0, #180	; 0xb4
  401e0e:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  401e12:	f04f 0228 	mov.w	r2, #40	; 0x28
  401e16:	47c0      	blx	r8

	ili9325_set_foreground_color(COLOR_VIOLET);
  401e18:	f248 20ee 	movw	r0, #33518	; 0x82ee
  401e1c:	f2c0 00ee 	movt	r0, #238	; 0xee
  401e20:	47a8      	blx	r5
	ili9325_draw_line(0, 0, 240, 320);
  401e22:	4620      	mov	r0, r4
  401e24:	4621      	mov	r1, r4
  401e26:	463a      	mov	r2, r7
  401e28:	4633      	mov	r3, r6
  401e2a:	f640 3731 	movw	r7, #2865	; 0xb31
  401e2e:	f2c0 0740 	movt	r7, #64	; 0x40
  401e32:	47b8      	blx	r7
  401e34:	e7fe      	b.n	401e34 <main+0x1fc>
  401e36:	bf00      	nop

00401e38 <__register_exitproc>:
  401e38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  401e3c:	4698      	mov	r8, r3
  401e3e:	4b23      	ldr	r3, [pc, #140]	; (401ecc <__register_exitproc+0x94>)
  401e40:	681c      	ldr	r4, [r3, #0]
  401e42:	4606      	mov	r6, r0
  401e44:	f8d4 0148 	ldr.w	r0, [r4, #328]	; 0x148
  401e48:	460f      	mov	r7, r1
  401e4a:	4691      	mov	r9, r2
  401e4c:	b918      	cbnz	r0, 401e56 <__register_exitproc+0x1e>
  401e4e:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  401e52:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  401e56:	6841      	ldr	r1, [r0, #4]
  401e58:	291f      	cmp	r1, #31
  401e5a:	dd16      	ble.n	401e8a <__register_exitproc+0x52>
  401e5c:	481c      	ldr	r0, [pc, #112]	; (401ed0 <__register_exitproc+0x98>)
  401e5e:	b918      	cbnz	r0, 401e68 <__register_exitproc+0x30>
  401e60:	f04f 30ff 	mov.w	r0, #4294967295
  401e64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  401e68:	f44f 70c8 	mov.w	r0, #400	; 0x190
  401e6c:	f000 fbbc 	bl	4025e8 <malloc>
  401e70:	2800      	cmp	r0, #0
  401e72:	d0f5      	beq.n	401e60 <__register_exitproc+0x28>
  401e74:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  401e78:	2500      	movs	r5, #0
  401e7a:	6045      	str	r5, [r0, #4]
  401e7c:	6002      	str	r2, [r0, #0]
  401e7e:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  401e82:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
  401e86:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
  401e8a:	b1b6      	cbz	r6, 401eba <__register_exitproc+0x82>
  401e8c:	6844      	ldr	r4, [r0, #4]
  401e8e:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
  401e92:	2201      	movs	r2, #1
  401e94:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  401e98:	fa02 f204 	lsl.w	r2, r2, r4
  401e9c:	4311      	orrs	r1, r2
  401e9e:	2e02      	cmp	r6, #2
  401ea0:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
  401ea4:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  401ea8:	461c      	mov	r4, r3
  401eaa:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
  401eae:	d104      	bne.n	401eba <__register_exitproc+0x82>
  401eb0:	f8d0 318c 	ldr.w	r3, [r0, #396]	; 0x18c
  401eb4:	431a      	orrs	r2, r3
  401eb6:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
  401eba:	6841      	ldr	r1, [r0, #4]
  401ebc:	1c8b      	adds	r3, r1, #2
  401ebe:	1c4a      	adds	r2, r1, #1
  401ec0:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
  401ec4:	6042      	str	r2, [r0, #4]
  401ec6:	2000      	movs	r0, #0
  401ec8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  401ecc:	00403374 	.word	0x00403374
  401ed0:	004025e9 	.word	0x004025e9

00401ed4 <__libc_fini_array>:
  401ed4:	b570      	push	{r4, r5, r6, lr}
  401ed6:	4b08      	ldr	r3, [pc, #32]	; (401ef8 <__libc_fini_array+0x24>)
  401ed8:	4c08      	ldr	r4, [pc, #32]	; (401efc <__libc_fini_array+0x28>)
  401eda:	1ae0      	subs	r0, r4, r3
  401edc:	1084      	asrs	r4, r0, #2
  401ede:	eb03 0684 	add.w	r6, r3, r4, lsl #2
  401ee2:	2500      	movs	r5, #0
  401ee4:	3d04      	subs	r5, #4
  401ee6:	b11c      	cbz	r4, 401ef0 <__libc_fini_array+0x1c>
  401ee8:	5972      	ldr	r2, [r6, r5]
  401eea:	4790      	blx	r2
  401eec:	3c01      	subs	r4, #1
  401eee:	e7f9      	b.n	401ee4 <__libc_fini_array+0x10>
  401ef0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  401ef4:	f001 ba4c 	b.w	403390 <_fini>
  401ef8:	0040339c 	.word	0x0040339c
  401efc:	004033a0 	.word	0x004033a0

00401f00 <__libc_init_array>:
  401f00:	b538      	push	{r3, r4, r5, lr}
  401f02:	4d0e      	ldr	r5, [pc, #56]	; (401f3c <__libc_init_array+0x3c>)
  401f04:	4b0e      	ldr	r3, [pc, #56]	; (401f40 <__libc_init_array+0x40>)
  401f06:	1ae8      	subs	r0, r5, r3
  401f08:	1085      	asrs	r5, r0, #2
  401f0a:	2400      	movs	r4, #0
  401f0c:	42ac      	cmp	r4, r5
  401f0e:	d005      	beq.n	401f1c <__libc_init_array+0x1c>
  401f10:	490b      	ldr	r1, [pc, #44]	; (401f40 <__libc_init_array+0x40>)
  401f12:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
  401f16:	4790      	blx	r2
  401f18:	3401      	adds	r4, #1
  401f1a:	e7f7      	b.n	401f0c <__libc_init_array+0xc>
  401f1c:	f001 fa2e 	bl	40337c <_init>
  401f20:	4908      	ldr	r1, [pc, #32]	; (401f44 <__libc_init_array+0x44>)
  401f22:	4a09      	ldr	r2, [pc, #36]	; (401f48 <__libc_init_array+0x48>)
  401f24:	1a54      	subs	r4, r2, r1
  401f26:	10a5      	asrs	r5, r4, #2
  401f28:	2400      	movs	r4, #0
  401f2a:	42ac      	cmp	r4, r5
  401f2c:	d005      	beq.n	401f3a <__libc_init_array+0x3a>
  401f2e:	4b05      	ldr	r3, [pc, #20]	; (401f44 <__libc_init_array+0x44>)
  401f30:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  401f34:	4780      	blx	r0
  401f36:	3401      	adds	r4, #1
  401f38:	e7f7      	b.n	401f2a <__libc_init_array+0x2a>
  401f3a:	bd38      	pop	{r3, r4, r5, pc}
  401f3c:	00403388 	.word	0x00403388
  401f40:	00403388 	.word	0x00403388
  401f44:	00403388 	.word	0x00403388
  401f48:	00403390 	.word	0x00403390

00401f4c <memset>:
  401f4c:	1882      	adds	r2, r0, r2
  401f4e:	4603      	mov	r3, r0
  401f50:	4293      	cmp	r3, r2
  401f52:	d002      	beq.n	401f5a <memset+0xe>
  401f54:	f803 1b01 	strb.w	r1, [r3], #1
  401f58:	e7fa      	b.n	401f50 <memset+0x4>
  401f5a:	4770      	bx	lr

00401f5c <setbuf>:
  401f5c:	2900      	cmp	r1, #0
  401f5e:	bf0c      	ite	eq
  401f60:	2202      	moveq	r2, #2
  401f62:	2200      	movne	r2, #0
  401f64:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401f68:	f000 b800 	b.w	401f6c <setvbuf>

00401f6c <setvbuf>:
  401f6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401f70:	461d      	mov	r5, r3
  401f72:	4b37      	ldr	r3, [pc, #220]	; (402050 <setvbuf+0xe4>)
  401f74:	4604      	mov	r4, r0
  401f76:	6818      	ldr	r0, [r3, #0]
  401f78:	460e      	mov	r6, r1
  401f7a:	4617      	mov	r7, r2
  401f7c:	4698      	mov	r8, r3
  401f7e:	b118      	cbz	r0, 401f88 <setvbuf+0x1c>
  401f80:	6b82      	ldr	r2, [r0, #56]	; 0x38
  401f82:	b90a      	cbnz	r2, 401f88 <setvbuf+0x1c>
  401f84:	f000 f96c 	bl	402260 <__sinit>
  401f88:	2f02      	cmp	r7, #2
  401f8a:	d85d      	bhi.n	402048 <setvbuf+0xdc>
  401f8c:	2d00      	cmp	r5, #0
  401f8e:	db5b      	blt.n	402048 <setvbuf+0xdc>
  401f90:	4621      	mov	r1, r4
  401f92:	f8d8 0000 	ldr.w	r0, [r8]
  401f96:	f000 f86f 	bl	402078 <_fflush_r>
  401f9a:	89a1      	ldrh	r1, [r4, #12]
  401f9c:	f001 0380 	and.w	r3, r1, #128	; 0x80
  401fa0:	2000      	movs	r0, #0
  401fa2:	b21a      	sxth	r2, r3
  401fa4:	6060      	str	r0, [r4, #4]
  401fa6:	61a0      	str	r0, [r4, #24]
  401fa8:	b122      	cbz	r2, 401fb4 <setvbuf+0x48>
  401faa:	4829      	ldr	r0, [pc, #164]	; (402050 <setvbuf+0xe4>)
  401fac:	6921      	ldr	r1, [r4, #16]
  401fae:	6800      	ldr	r0, [r0, #0]
  401fb0:	f000 fa20 	bl	4023f4 <_free_r>
  401fb4:	89a1      	ldrh	r1, [r4, #12]
  401fb6:	2f02      	cmp	r7, #2
  401fb8:	f021 0383 	bic.w	r3, r1, #131	; 0x83
  401fbc:	81a3      	strh	r3, [r4, #12]
  401fbe:	d012      	beq.n	401fe6 <setvbuf+0x7a>
  401fc0:	bb36      	cbnz	r6, 402010 <setvbuf+0xa4>
  401fc2:	2d00      	cmp	r5, #0
  401fc4:	bf08      	it	eq
  401fc6:	f44f 6580 	moveq.w	r5, #1024	; 0x400
  401fca:	4628      	mov	r0, r5
  401fcc:	f000 fb0c 	bl	4025e8 <malloc>
  401fd0:	4606      	mov	r6, r0
  401fd2:	b9c8      	cbnz	r0, 402008 <setvbuf+0x9c>
  401fd4:	f44f 6080 	mov.w	r0, #1024	; 0x400
  401fd8:	f000 fb06 	bl	4025e8 <malloc>
  401fdc:	4606      	mov	r6, r0
  401fde:	b988      	cbnz	r0, 402004 <setvbuf+0x98>
  401fe0:	f04f 30ff 	mov.w	r0, #4294967295
  401fe4:	e000      	b.n	401fe8 <setvbuf+0x7c>
  401fe6:	2000      	movs	r0, #0
  401fe8:	89a1      	ldrh	r1, [r4, #12]
  401fea:	f041 0302 	orr.w	r3, r1, #2
  401fee:	81a3      	strh	r3, [r4, #12]
  401ff0:	f104 0143 	add.w	r1, r4, #67	; 0x43
  401ff4:	2200      	movs	r2, #0
  401ff6:	2301      	movs	r3, #1
  401ff8:	60a2      	str	r2, [r4, #8]
  401ffa:	6021      	str	r1, [r4, #0]
  401ffc:	6121      	str	r1, [r4, #16]
  401ffe:	6163      	str	r3, [r4, #20]
  402000:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402004:	f44f 6580 	mov.w	r5, #1024	; 0x400
  402008:	89a2      	ldrh	r2, [r4, #12]
  40200a:	f042 0080 	orr.w	r0, r2, #128	; 0x80
  40200e:	81a0      	strh	r0, [r4, #12]
  402010:	2f01      	cmp	r7, #1
  402012:	d105      	bne.n	402020 <setvbuf+0xb4>
  402014:	89a1      	ldrh	r1, [r4, #12]
  402016:	426a      	negs	r2, r5
  402018:	f041 0301 	orr.w	r3, r1, #1
  40201c:	81a3      	strh	r3, [r4, #12]
  40201e:	61a2      	str	r2, [r4, #24]
  402020:	480b      	ldr	r0, [pc, #44]	; (402050 <setvbuf+0xe4>)
  402022:	89a2      	ldrh	r2, [r4, #12]
  402024:	6801      	ldr	r1, [r0, #0]
  402026:	4b0b      	ldr	r3, [pc, #44]	; (402054 <setvbuf+0xe8>)
  402028:	f002 0008 	and.w	r0, r2, #8
  40202c:	b200      	sxth	r0, r0
  40202e:	63cb      	str	r3, [r1, #60]	; 0x3c
  402030:	6026      	str	r6, [r4, #0]
  402032:	6126      	str	r6, [r4, #16]
  402034:	6165      	str	r5, [r4, #20]
  402036:	b148      	cbz	r0, 40204c <setvbuf+0xe0>
  402038:	f012 0f03 	tst.w	r2, #3
  40203c:	bf18      	it	ne
  40203e:	2500      	movne	r5, #0
  402040:	60a5      	str	r5, [r4, #8]
  402042:	2000      	movs	r0, #0
  402044:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402048:	f04f 30ff 	mov.w	r0, #4294967295
  40204c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402050:	20000008 	.word	0x20000008
  402054:	004021d5 	.word	0x004021d5

00402058 <register_fini>:
  402058:	4b02      	ldr	r3, [pc, #8]	; (402064 <register_fini+0xc>)
  40205a:	b113      	cbz	r3, 402062 <register_fini+0xa>
  40205c:	4802      	ldr	r0, [pc, #8]	; (402068 <register_fini+0x10>)
  40205e:	f000 b805 	b.w	40206c <atexit>
  402062:	4770      	bx	lr
  402064:	00000000 	.word	0x00000000
  402068:	00401ed5 	.word	0x00401ed5

0040206c <atexit>:
  40206c:	4601      	mov	r1, r0
  40206e:	2000      	movs	r0, #0
  402070:	4602      	mov	r2, r0
  402072:	4603      	mov	r3, r0
  402074:	f7ff bee0 	b.w	401e38 <__register_exitproc>

00402078 <_fflush_r>:
  402078:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40207c:	460c      	mov	r4, r1
  40207e:	4605      	mov	r5, r0
  402080:	b118      	cbz	r0, 40208a <_fflush_r+0x12>
  402082:	6b83      	ldr	r3, [r0, #56]	; 0x38
  402084:	b90b      	cbnz	r3, 40208a <_fflush_r+0x12>
  402086:	f000 f8eb 	bl	402260 <__sinit>
  40208a:	89a2      	ldrh	r2, [r4, #12]
  40208c:	b332      	cbz	r2, 4020dc <_fflush_r+0x64>
  40208e:	f002 0008 	and.w	r0, r2, #8
  402092:	b201      	sxth	r1, r0
  402094:	2900      	cmp	r1, #0
  402096:	d162      	bne.n	40215e <_fflush_r+0xe6>
  402098:	6861      	ldr	r1, [r4, #4]
  40209a:	f442 6000 	orr.w	r0, r2, #2048	; 0x800
  40209e:	2900      	cmp	r1, #0
  4020a0:	81a0      	strh	r0, [r4, #12]
  4020a2:	dc02      	bgt.n	4020aa <_fflush_r+0x32>
  4020a4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4020a6:	2b00      	cmp	r3, #0
  4020a8:	dd18      	ble.n	4020dc <_fflush_r+0x64>
  4020aa:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  4020ac:	b1b6      	cbz	r6, 4020dc <_fflush_r+0x64>
  4020ae:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
  4020b2:	2000      	movs	r0, #0
  4020b4:	b212      	sxth	r2, r2
  4020b6:	682f      	ldr	r7, [r5, #0]
  4020b8:	6028      	str	r0, [r5, #0]
  4020ba:	b10a      	cbz	r2, 4020c0 <_fflush_r+0x48>
  4020bc:	6d22      	ldr	r2, [r4, #80]	; 0x50
  4020be:	e010      	b.n	4020e2 <_fflush_r+0x6a>
  4020c0:	2301      	movs	r3, #1
  4020c2:	4628      	mov	r0, r5
  4020c4:	69e1      	ldr	r1, [r4, #28]
  4020c6:	47b0      	blx	r6
  4020c8:	4602      	mov	r2, r0
  4020ca:	3001      	adds	r0, #1
  4020cc:	d109      	bne.n	4020e2 <_fflush_r+0x6a>
  4020ce:	6829      	ldr	r1, [r5, #0]
  4020d0:	b139      	cbz	r1, 4020e2 <_fflush_r+0x6a>
  4020d2:	291d      	cmp	r1, #29
  4020d4:	d001      	beq.n	4020da <_fflush_r+0x62>
  4020d6:	2916      	cmp	r1, #22
  4020d8:	d14f      	bne.n	40217a <_fflush_r+0x102>
  4020da:	602f      	str	r7, [r5, #0]
  4020dc:	2000      	movs	r0, #0
  4020de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4020e2:	89a6      	ldrh	r6, [r4, #12]
  4020e4:	f006 0104 	and.w	r1, r6, #4
  4020e8:	b20b      	sxth	r3, r1
  4020ea:	b12b      	cbz	r3, 4020f8 <_fflush_r+0x80>
  4020ec:	6860      	ldr	r0, [r4, #4]
  4020ee:	6b26      	ldr	r6, [r4, #48]	; 0x30
  4020f0:	1a12      	subs	r2, r2, r0
  4020f2:	b10e      	cbz	r6, 4020f8 <_fflush_r+0x80>
  4020f4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  4020f6:	1a52      	subs	r2, r2, r1
  4020f8:	69e1      	ldr	r1, [r4, #28]
  4020fa:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  4020fc:	2300      	movs	r3, #0
  4020fe:	4628      	mov	r0, r5
  402100:	47b0      	blx	r6
  402102:	1c41      	adds	r1, r0, #1
  402104:	d105      	bne.n	402112 <_fflush_r+0x9a>
  402106:	682a      	ldr	r2, [r5, #0]
  402108:	b11a      	cbz	r2, 402112 <_fflush_r+0x9a>
  40210a:	2a1d      	cmp	r2, #29
  40210c:	d001      	beq.n	402112 <_fflush_r+0x9a>
  40210e:	2a16      	cmp	r2, #22
  402110:	d11f      	bne.n	402152 <_fflush_r+0xda>
  402112:	89a3      	ldrh	r3, [r4, #12]
  402114:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
  402118:	2100      	movs	r1, #0
  40211a:	81a2      	strh	r2, [r4, #12]
  40211c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  402120:	6922      	ldr	r2, [r4, #16]
  402122:	6061      	str	r1, [r4, #4]
  402124:	b219      	sxth	r1, r3
  402126:	6022      	str	r2, [r4, #0]
  402128:	b121      	cbz	r1, 402134 <_fflush_r+0xbc>
  40212a:	1c42      	adds	r2, r0, #1
  40212c:	d101      	bne.n	402132 <_fflush_r+0xba>
  40212e:	682a      	ldr	r2, [r5, #0]
  402130:	b902      	cbnz	r2, 402134 <_fflush_r+0xbc>
  402132:	6520      	str	r0, [r4, #80]	; 0x50
  402134:	6b21      	ldr	r1, [r4, #48]	; 0x30
  402136:	602f      	str	r7, [r5, #0]
  402138:	2900      	cmp	r1, #0
  40213a:	d0cf      	beq.n	4020dc <_fflush_r+0x64>
  40213c:	f104 0040 	add.w	r0, r4, #64	; 0x40
  402140:	4281      	cmp	r1, r0
  402142:	d002      	beq.n	40214a <_fflush_r+0xd2>
  402144:	4628      	mov	r0, r5
  402146:	f000 f955 	bl	4023f4 <_free_r>
  40214a:	2000      	movs	r0, #0
  40214c:	6320      	str	r0, [r4, #48]	; 0x30
  40214e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402152:	89a3      	ldrh	r3, [r4, #12]
  402154:	f043 0140 	orr.w	r1, r3, #64	; 0x40
  402158:	81a1      	strh	r1, [r4, #12]
  40215a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40215e:	6926      	ldr	r6, [r4, #16]
  402160:	2e00      	cmp	r6, #0
  402162:	d0bb      	beq.n	4020dc <_fflush_r+0x64>
  402164:	0792      	lsls	r2, r2, #30
  402166:	6823      	ldr	r3, [r4, #0]
  402168:	bf08      	it	eq
  40216a:	6962      	ldreq	r2, [r4, #20]
  40216c:	6026      	str	r6, [r4, #0]
  40216e:	bf18      	it	ne
  402170:	2200      	movne	r2, #0
  402172:	ebc6 0803 	rsb	r8, r6, r3
  402176:	60a2      	str	r2, [r4, #8]
  402178:	e012      	b.n	4021a0 <_fflush_r+0x128>
  40217a:	89a3      	ldrh	r3, [r4, #12]
  40217c:	f043 0040 	orr.w	r0, r3, #64	; 0x40
  402180:	81a0      	strh	r0, [r4, #12]
  402182:	f04f 30ff 	mov.w	r0, #4294967295
  402186:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40218a:	6a67      	ldr	r7, [r4, #36]	; 0x24
  40218c:	69e1      	ldr	r1, [r4, #28]
  40218e:	4628      	mov	r0, r5
  402190:	4632      	mov	r2, r6
  402192:	4643      	mov	r3, r8
  402194:	47b8      	blx	r7
  402196:	2800      	cmp	r0, #0
  402198:	ddef      	ble.n	40217a <_fflush_r+0x102>
  40219a:	1836      	adds	r6, r6, r0
  40219c:	ebc0 0808 	rsb	r8, r0, r8
  4021a0:	f1b8 0f00 	cmp.w	r8, #0
  4021a4:	dcf1      	bgt.n	40218a <_fflush_r+0x112>
  4021a6:	e799      	b.n	4020dc <_fflush_r+0x64>

004021a8 <fflush>:
  4021a8:	4601      	mov	r1, r0
  4021aa:	b920      	cbnz	r0, 4021b6 <fflush+0xe>
  4021ac:	4804      	ldr	r0, [pc, #16]	; (4021c0 <fflush+0x18>)
  4021ae:	4905      	ldr	r1, [pc, #20]	; (4021c4 <fflush+0x1c>)
  4021b0:	6800      	ldr	r0, [r0, #0]
  4021b2:	f000 b9f6 	b.w	4025a2 <_fwalk_reent>
  4021b6:	4b04      	ldr	r3, [pc, #16]	; (4021c8 <fflush+0x20>)
  4021b8:	6818      	ldr	r0, [r3, #0]
  4021ba:	f7ff bf5d 	b.w	402078 <_fflush_r>
  4021be:	bf00      	nop
  4021c0:	00403374 	.word	0x00403374
  4021c4:	00402079 	.word	0x00402079
  4021c8:	20000008 	.word	0x20000008

004021cc <__fp_lock>:
  4021cc:	2000      	movs	r0, #0
  4021ce:	4770      	bx	lr

004021d0 <__fp_unlock>:
  4021d0:	2000      	movs	r0, #0
  4021d2:	4770      	bx	lr

004021d4 <_cleanup_r>:
  4021d4:	4901      	ldr	r1, [pc, #4]	; (4021dc <_cleanup_r+0x8>)
  4021d6:	f000 b9c3 	b.w	402560 <_fwalk>
  4021da:	bf00      	nop
  4021dc:	00402b89 	.word	0x00402b89

004021e0 <std.isra.0>:
  4021e0:	2300      	movs	r3, #0
  4021e2:	b510      	push	{r4, lr}
  4021e4:	4604      	mov	r4, r0
  4021e6:	6003      	str	r3, [r0, #0]
  4021e8:	6043      	str	r3, [r0, #4]
  4021ea:	6083      	str	r3, [r0, #8]
  4021ec:	8181      	strh	r1, [r0, #12]
  4021ee:	6643      	str	r3, [r0, #100]	; 0x64
  4021f0:	81c2      	strh	r2, [r0, #14]
  4021f2:	6103      	str	r3, [r0, #16]
  4021f4:	6143      	str	r3, [r0, #20]
  4021f6:	6183      	str	r3, [r0, #24]
  4021f8:	4619      	mov	r1, r3
  4021fa:	2208      	movs	r2, #8
  4021fc:	f100 005c 	add.w	r0, r0, #92	; 0x5c
  402200:	f7ff fea4 	bl	401f4c <memset>
  402204:	4804      	ldr	r0, [pc, #16]	; (402218 <std.isra.0+0x38>)
  402206:	4905      	ldr	r1, [pc, #20]	; (40221c <std.isra.0+0x3c>)
  402208:	4a05      	ldr	r2, [pc, #20]	; (402220 <std.isra.0+0x40>)
  40220a:	4b06      	ldr	r3, [pc, #24]	; (402224 <std.isra.0+0x44>)
  40220c:	61e4      	str	r4, [r4, #28]
  40220e:	6220      	str	r0, [r4, #32]
  402210:	6261      	str	r1, [r4, #36]	; 0x24
  402212:	62a2      	str	r2, [r4, #40]	; 0x28
  402214:	62e3      	str	r3, [r4, #44]	; 0x2c
  402216:	bd10      	pop	{r4, pc}
  402218:	00402a31 	.word	0x00402a31
  40221c:	00402a57 	.word	0x00402a57
  402220:	00402a93 	.word	0x00402a93
  402224:	00402ab7 	.word	0x00402ab7

00402228 <__sfmoreglue>:
  402228:	b570      	push	{r4, r5, r6, lr}
  40222a:	2568      	movs	r5, #104	; 0x68
  40222c:	434d      	muls	r5, r1
  40222e:	460e      	mov	r6, r1
  402230:	f105 010c 	add.w	r1, r5, #12
  402234:	f000 f9e8 	bl	402608 <_malloc_r>
  402238:	4604      	mov	r4, r0
  40223a:	b140      	cbz	r0, 40224e <__sfmoreglue+0x26>
  40223c:	f100 000c 	add.w	r0, r0, #12
  402240:	2100      	movs	r1, #0
  402242:	e884 0042 	stmia.w	r4, {r1, r6}
  402246:	60a0      	str	r0, [r4, #8]
  402248:	462a      	mov	r2, r5
  40224a:	f7ff fe7f 	bl	401f4c <memset>
  40224e:	4620      	mov	r0, r4
  402250:	bd70      	pop	{r4, r5, r6, pc}

00402252 <_cleanup>:
  402252:	4b02      	ldr	r3, [pc, #8]	; (40225c <_cleanup+0xa>)
  402254:	6818      	ldr	r0, [r3, #0]
  402256:	f7ff bfbd 	b.w	4021d4 <_cleanup_r>
  40225a:	bf00      	nop
  40225c:	00403374 	.word	0x00403374

00402260 <__sinit>:
  402260:	b538      	push	{r3, r4, r5, lr}
  402262:	6b83      	ldr	r3, [r0, #56]	; 0x38
  402264:	4604      	mov	r4, r0
  402266:	b9eb      	cbnz	r3, 4022a4 <__sinit+0x44>
  402268:	4a0f      	ldr	r2, [pc, #60]	; (4022a8 <__sinit+0x48>)
  40226a:	f8c0 32e0 	str.w	r3, [r0, #736]	; 0x2e0
  40226e:	2501      	movs	r5, #1
  402270:	63c2      	str	r2, [r0, #60]	; 0x3c
  402272:	6385      	str	r5, [r0, #56]	; 0x38
  402274:	f504 713b 	add.w	r1, r4, #748	; 0x2ec
  402278:	2003      	movs	r0, #3
  40227a:	461a      	mov	r2, r3
  40227c:	f8c4 02e4 	str.w	r0, [r4, #740]	; 0x2e4
  402280:	f8c4 12e8 	str.w	r1, [r4, #744]	; 0x2e8
  402284:	6860      	ldr	r0, [r4, #4]
  402286:	2104      	movs	r1, #4
  402288:	f7ff ffaa 	bl	4021e0 <std.isra.0>
  40228c:	68a0      	ldr	r0, [r4, #8]
  40228e:	2109      	movs	r1, #9
  402290:	462a      	mov	r2, r5
  402292:	f7ff ffa5 	bl	4021e0 <std.isra.0>
  402296:	68e0      	ldr	r0, [r4, #12]
  402298:	2112      	movs	r1, #18
  40229a:	2202      	movs	r2, #2
  40229c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  4022a0:	f7ff bf9e 	b.w	4021e0 <std.isra.0>
  4022a4:	bd38      	pop	{r3, r4, r5, pc}
  4022a6:	bf00      	nop
  4022a8:	004021d5 	.word	0x004021d5

004022ac <__sfp>:
  4022ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4022ae:	4b1d      	ldr	r3, [pc, #116]	; (402324 <__sfp+0x78>)
  4022b0:	681e      	ldr	r6, [r3, #0]
  4022b2:	4607      	mov	r7, r0
  4022b4:	6bb0      	ldr	r0, [r6, #56]	; 0x38
  4022b6:	b910      	cbnz	r0, 4022be <__sfp+0x12>
  4022b8:	4630      	mov	r0, r6
  4022ba:	f7ff ffd1 	bl	402260 <__sinit>
  4022be:	f506 7638 	add.w	r6, r6, #736	; 0x2e0
  4022c2:	68b4      	ldr	r4, [r6, #8]
  4022c4:	6871      	ldr	r1, [r6, #4]
  4022c6:	3901      	subs	r1, #1
  4022c8:	d404      	bmi.n	4022d4 <__sfp+0x28>
  4022ca:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  4022ce:	b185      	cbz	r5, 4022f2 <__sfp+0x46>
  4022d0:	3468      	adds	r4, #104	; 0x68
  4022d2:	e7f8      	b.n	4022c6 <__sfp+0x1a>
  4022d4:	6832      	ldr	r2, [r6, #0]
  4022d6:	b10a      	cbz	r2, 4022dc <__sfp+0x30>
  4022d8:	6836      	ldr	r6, [r6, #0]
  4022da:	e7f2      	b.n	4022c2 <__sfp+0x16>
  4022dc:	4638      	mov	r0, r7
  4022de:	2104      	movs	r1, #4
  4022e0:	f7ff ffa2 	bl	402228 <__sfmoreglue>
  4022e4:	6030      	str	r0, [r6, #0]
  4022e6:	2800      	cmp	r0, #0
  4022e8:	d1f6      	bne.n	4022d8 <__sfp+0x2c>
  4022ea:	240c      	movs	r4, #12
  4022ec:	603c      	str	r4, [r7, #0]
  4022ee:	4604      	mov	r4, r0
  4022f0:	e015      	b.n	40231e <__sfp+0x72>
  4022f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4022f6:	2001      	movs	r0, #1
  4022f8:	81a0      	strh	r0, [r4, #12]
  4022fa:	81e3      	strh	r3, [r4, #14]
  4022fc:	6665      	str	r5, [r4, #100]	; 0x64
  4022fe:	6025      	str	r5, [r4, #0]
  402300:	60a5      	str	r5, [r4, #8]
  402302:	6065      	str	r5, [r4, #4]
  402304:	6125      	str	r5, [r4, #16]
  402306:	6165      	str	r5, [r4, #20]
  402308:	61a5      	str	r5, [r4, #24]
  40230a:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  40230e:	4629      	mov	r1, r5
  402310:	2208      	movs	r2, #8
  402312:	f7ff fe1b 	bl	401f4c <memset>
  402316:	6325      	str	r5, [r4, #48]	; 0x30
  402318:	6365      	str	r5, [r4, #52]	; 0x34
  40231a:	6465      	str	r5, [r4, #68]	; 0x44
  40231c:	64a5      	str	r5, [r4, #72]	; 0x48
  40231e:	4620      	mov	r0, r4
  402320:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402322:	bf00      	nop
  402324:	00403374 	.word	0x00403374

00402328 <__sfp_lock_acquire>:
  402328:	4770      	bx	lr

0040232a <__sfp_lock_release>:
  40232a:	4770      	bx	lr

0040232c <__sinit_lock_acquire>:
  40232c:	4770      	bx	lr

0040232e <__sinit_lock_release>:
  40232e:	4770      	bx	lr

00402330 <__fp_lock_all>:
  402330:	4b02      	ldr	r3, [pc, #8]	; (40233c <__fp_lock_all+0xc>)
  402332:	4903      	ldr	r1, [pc, #12]	; (402340 <__fp_lock_all+0x10>)
  402334:	6818      	ldr	r0, [r3, #0]
  402336:	f000 b913 	b.w	402560 <_fwalk>
  40233a:	bf00      	nop
  40233c:	20000008 	.word	0x20000008
  402340:	004021cd 	.word	0x004021cd

00402344 <__fp_unlock_all>:
  402344:	4b02      	ldr	r3, [pc, #8]	; (402350 <__fp_unlock_all+0xc>)
  402346:	4903      	ldr	r1, [pc, #12]	; (402354 <__fp_unlock_all+0x10>)
  402348:	6818      	ldr	r0, [r3, #0]
  40234a:	f000 b909 	b.w	402560 <_fwalk>
  40234e:	bf00      	nop
  402350:	20000008 	.word	0x20000008
  402354:	004021d1 	.word	0x004021d1

00402358 <_malloc_trim_r>:
  402358:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40235a:	4d23      	ldr	r5, [pc, #140]	; (4023e8 <_malloc_trim_r+0x90>)
  40235c:	460e      	mov	r6, r1
  40235e:	4604      	mov	r4, r0
  402360:	f000 fb54 	bl	402a0c <__malloc_lock>
  402364:	68ab      	ldr	r3, [r5, #8]
  402366:	685f      	ldr	r7, [r3, #4]
  402368:	f027 0703 	bic.w	r7, r7, #3
  40236c:	f607 70ef 	addw	r0, r7, #4079	; 0xfef
  402370:	1b81      	subs	r1, r0, r6
  402372:	f421 627f 	bic.w	r2, r1, #4080	; 0xff0
  402376:	f022 060f 	bic.w	r6, r2, #15
  40237a:	f5a6 5680 	sub.w	r6, r6, #4096	; 0x1000
  40237e:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
  402382:	da04      	bge.n	40238e <_malloc_trim_r+0x36>
  402384:	4620      	mov	r0, r4
  402386:	f000 fb42 	bl	402a0e <__malloc_unlock>
  40238a:	2000      	movs	r0, #0
  40238c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40238e:	2100      	movs	r1, #0
  402390:	4620      	mov	r0, r4
  402392:	f000 fb3d 	bl	402a10 <_sbrk_r>
  402396:	68ab      	ldr	r3, [r5, #8]
  402398:	19d9      	adds	r1, r3, r7
  40239a:	4288      	cmp	r0, r1
  40239c:	d1f2      	bne.n	402384 <_malloc_trim_r+0x2c>
  40239e:	4271      	negs	r1, r6
  4023a0:	4620      	mov	r0, r4
  4023a2:	f000 fb35 	bl	402a10 <_sbrk_r>
  4023a6:	3001      	adds	r0, #1
  4023a8:	d110      	bne.n	4023cc <_malloc_trim_r+0x74>
  4023aa:	2100      	movs	r1, #0
  4023ac:	4620      	mov	r0, r4
  4023ae:	f000 fb2f 	bl	402a10 <_sbrk_r>
  4023b2:	68ab      	ldr	r3, [r5, #8]
  4023b4:	1ac2      	subs	r2, r0, r3
  4023b6:	2a0f      	cmp	r2, #15
  4023b8:	dde4      	ble.n	402384 <_malloc_trim_r+0x2c>
  4023ba:	490c      	ldr	r1, [pc, #48]	; (4023ec <_malloc_trim_r+0x94>)
  4023bc:	6809      	ldr	r1, [r1, #0]
  4023be:	1a40      	subs	r0, r0, r1
  4023c0:	490b      	ldr	r1, [pc, #44]	; (4023f0 <_malloc_trim_r+0x98>)
  4023c2:	f042 0201 	orr.w	r2, r2, #1
  4023c6:	6008      	str	r0, [r1, #0]
  4023c8:	605a      	str	r2, [r3, #4]
  4023ca:	e7db      	b.n	402384 <_malloc_trim_r+0x2c>
  4023cc:	4b08      	ldr	r3, [pc, #32]	; (4023f0 <_malloc_trim_r+0x98>)
  4023ce:	68a8      	ldr	r0, [r5, #8]
  4023d0:	681a      	ldr	r2, [r3, #0]
  4023d2:	1bbf      	subs	r7, r7, r6
  4023d4:	f047 0701 	orr.w	r7, r7, #1
  4023d8:	6047      	str	r7, [r0, #4]
  4023da:	1b96      	subs	r6, r2, r6
  4023dc:	4620      	mov	r0, r4
  4023de:	601e      	str	r6, [r3, #0]
  4023e0:	f000 fb15 	bl	402a0e <__malloc_unlock>
  4023e4:	2001      	movs	r0, #1
  4023e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4023e8:	20000438 	.word	0x20000438
  4023ec:	20000840 	.word	0x20000840
  4023f0:	20000ca0 	.word	0x20000ca0

004023f4 <_free_r>:
  4023f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4023f6:	4606      	mov	r6, r0
  4023f8:	460d      	mov	r5, r1
  4023fa:	2900      	cmp	r1, #0
  4023fc:	f000 80a6 	beq.w	40254c <_free_r+0x158>
  402400:	f000 fb04 	bl	402a0c <__malloc_lock>
  402404:	f855 cc04 	ldr.w	ip, [r5, #-4]
  402408:	4f51      	ldr	r7, [pc, #324]	; (402550 <_free_r+0x15c>)
  40240a:	f1a5 0308 	sub.w	r3, r5, #8
  40240e:	f02c 0201 	bic.w	r2, ip, #1
  402412:	189c      	adds	r4, r3, r2
  402414:	68b9      	ldr	r1, [r7, #8]
  402416:	6860      	ldr	r0, [r4, #4]
  402418:	428c      	cmp	r4, r1
  40241a:	f020 0003 	bic.w	r0, r0, #3
  40241e:	f00c 0101 	and.w	r1, ip, #1
  402422:	d11c      	bne.n	40245e <_free_r+0x6a>
  402424:	1882      	adds	r2, r0, r2
  402426:	b939      	cbnz	r1, 402438 <_free_r+0x44>
  402428:	f855 1c08 	ldr.w	r1, [r5, #-8]
  40242c:	1a5b      	subs	r3, r3, r1
  40242e:	1852      	adds	r2, r2, r1
  402430:	6898      	ldr	r0, [r3, #8]
  402432:	68d9      	ldr	r1, [r3, #12]
  402434:	60c1      	str	r1, [r0, #12]
  402436:	6088      	str	r0, [r1, #8]
  402438:	4845      	ldr	r0, [pc, #276]	; (402550 <_free_r+0x15c>)
  40243a:	f042 0101 	orr.w	r1, r2, #1
  40243e:	6059      	str	r1, [r3, #4]
  402440:	6083      	str	r3, [r0, #8]
  402442:	4b44      	ldr	r3, [pc, #272]	; (402554 <_free_r+0x160>)
  402444:	6819      	ldr	r1, [r3, #0]
  402446:	428a      	cmp	r2, r1
  402448:	d304      	bcc.n	402454 <_free_r+0x60>
  40244a:	4a43      	ldr	r2, [pc, #268]	; (402558 <_free_r+0x164>)
  40244c:	4630      	mov	r0, r6
  40244e:	6811      	ldr	r1, [r2, #0]
  402450:	f7ff ff82 	bl	402358 <_malloc_trim_r>
  402454:	4630      	mov	r0, r6
  402456:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  40245a:	f000 bad8 	b.w	402a0e <__malloc_unlock>
  40245e:	6060      	str	r0, [r4, #4]
  402460:	b959      	cbnz	r1, 40247a <_free_r+0x86>
  402462:	f855 5c08 	ldr.w	r5, [r5, #-8]
  402466:	1b5b      	subs	r3, r3, r5
  402468:	1952      	adds	r2, r2, r5
  40246a:	689d      	ldr	r5, [r3, #8]
  40246c:	3708      	adds	r7, #8
  40246e:	42bd      	cmp	r5, r7
  402470:	d005      	beq.n	40247e <_free_r+0x8a>
  402472:	68df      	ldr	r7, [r3, #12]
  402474:	60ef      	str	r7, [r5, #12]
  402476:	60bd      	str	r5, [r7, #8]
  402478:	e002      	b.n	402480 <_free_r+0x8c>
  40247a:	2100      	movs	r1, #0
  40247c:	e000      	b.n	402480 <_free_r+0x8c>
  40247e:	2101      	movs	r1, #1
  402480:	1825      	adds	r5, r4, r0
  402482:	686d      	ldr	r5, [r5, #4]
  402484:	f015 0f01 	tst.w	r5, #1
  402488:	d10f      	bne.n	4024aa <_free_r+0xb6>
  40248a:	1812      	adds	r2, r2, r0
  40248c:	b949      	cbnz	r1, 4024a2 <_free_r+0xae>
  40248e:	68a0      	ldr	r0, [r4, #8]
  402490:	4d32      	ldr	r5, [pc, #200]	; (40255c <_free_r+0x168>)
  402492:	42a8      	cmp	r0, r5
  402494:	d105      	bne.n	4024a2 <_free_r+0xae>
  402496:	60eb      	str	r3, [r5, #12]
  402498:	60ab      	str	r3, [r5, #8]
  40249a:	60d8      	str	r0, [r3, #12]
  40249c:	6098      	str	r0, [r3, #8]
  40249e:	2101      	movs	r1, #1
  4024a0:	e003      	b.n	4024aa <_free_r+0xb6>
  4024a2:	68e0      	ldr	r0, [r4, #12]
  4024a4:	68a4      	ldr	r4, [r4, #8]
  4024a6:	60e0      	str	r0, [r4, #12]
  4024a8:	6084      	str	r4, [r0, #8]
  4024aa:	f042 0001 	orr.w	r0, r2, #1
  4024ae:	6058      	str	r0, [r3, #4]
  4024b0:	509a      	str	r2, [r3, r2]
  4024b2:	2900      	cmp	r1, #0
  4024b4:	d1ce      	bne.n	402454 <_free_r+0x60>
  4024b6:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  4024ba:	d20c      	bcs.n	4024d6 <_free_r+0xe2>
  4024bc:	4924      	ldr	r1, [pc, #144]	; (402550 <_free_r+0x15c>)
  4024be:	08d2      	lsrs	r2, r2, #3
  4024c0:	1090      	asrs	r0, r2, #2
  4024c2:	2401      	movs	r4, #1
  4024c4:	fa04 f400 	lsl.w	r4, r4, r0
  4024c8:	6848      	ldr	r0, [r1, #4]
  4024ca:	4320      	orrs	r0, r4
  4024cc:	6048      	str	r0, [r1, #4]
  4024ce:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
  4024d2:	6881      	ldr	r1, [r0, #8]
  4024d4:	e035      	b.n	402542 <_free_r+0x14e>
  4024d6:	0a54      	lsrs	r4, r2, #9
  4024d8:	2c04      	cmp	r4, #4
  4024da:	d802      	bhi.n	4024e2 <_free_r+0xee>
  4024dc:	0994      	lsrs	r4, r2, #6
  4024de:	3438      	adds	r4, #56	; 0x38
  4024e0:	e016      	b.n	402510 <_free_r+0x11c>
  4024e2:	2c14      	cmp	r4, #20
  4024e4:	d801      	bhi.n	4024ea <_free_r+0xf6>
  4024e6:	345b      	adds	r4, #91	; 0x5b
  4024e8:	e012      	b.n	402510 <_free_r+0x11c>
  4024ea:	2c54      	cmp	r4, #84	; 0x54
  4024ec:	d802      	bhi.n	4024f4 <_free_r+0x100>
  4024ee:	0b14      	lsrs	r4, r2, #12
  4024f0:	346e      	adds	r4, #110	; 0x6e
  4024f2:	e00d      	b.n	402510 <_free_r+0x11c>
  4024f4:	f5b4 7faa 	cmp.w	r4, #340	; 0x154
  4024f8:	d802      	bhi.n	402500 <_free_r+0x10c>
  4024fa:	0bd4      	lsrs	r4, r2, #15
  4024fc:	3477      	adds	r4, #119	; 0x77
  4024fe:	e007      	b.n	402510 <_free_r+0x11c>
  402500:	f240 5554 	movw	r5, #1364	; 0x554
  402504:	42ac      	cmp	r4, r5
  402506:	d802      	bhi.n	40250e <_free_r+0x11a>
  402508:	0c94      	lsrs	r4, r2, #18
  40250a:	347c      	adds	r4, #124	; 0x7c
  40250c:	e000      	b.n	402510 <_free_r+0x11c>
  40250e:	247e      	movs	r4, #126	; 0x7e
  402510:	4d0f      	ldr	r5, [pc, #60]	; (402550 <_free_r+0x15c>)
  402512:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
  402516:	6881      	ldr	r1, [r0, #8]
  402518:	4281      	cmp	r1, r0
  40251a:	d10c      	bne.n	402536 <_free_r+0x142>
  40251c:	6868      	ldr	r0, [r5, #4]
  40251e:	2201      	movs	r2, #1
  402520:	10a4      	asrs	r4, r4, #2
  402522:	fa02 f404 	lsl.w	r4, r2, r4
  402526:	ea44 0200 	orr.w	r2, r4, r0
  40252a:	606a      	str	r2, [r5, #4]
  40252c:	4608      	mov	r0, r1
  40252e:	e008      	b.n	402542 <_free_r+0x14e>
  402530:	6889      	ldr	r1, [r1, #8]
  402532:	4281      	cmp	r1, r0
  402534:	d004      	beq.n	402540 <_free_r+0x14c>
  402536:	684c      	ldr	r4, [r1, #4]
  402538:	f024 0403 	bic.w	r4, r4, #3
  40253c:	42a2      	cmp	r2, r4
  40253e:	d3f7      	bcc.n	402530 <_free_r+0x13c>
  402540:	68c8      	ldr	r0, [r1, #12]
  402542:	60d8      	str	r0, [r3, #12]
  402544:	6099      	str	r1, [r3, #8]
  402546:	6083      	str	r3, [r0, #8]
  402548:	60cb      	str	r3, [r1, #12]
  40254a:	e783      	b.n	402454 <_free_r+0x60>
  40254c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40254e:	bf00      	nop
  402550:	20000438 	.word	0x20000438
  402554:	20000844 	.word	0x20000844
  402558:	20000c9c 	.word	0x20000c9c
  40255c:	20000440 	.word	0x20000440

00402560 <_fwalk>:
  402560:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402564:	4604      	mov	r4, r0
  402566:	4688      	mov	r8, r1
  402568:	f7ff fede 	bl	402328 <__sfp_lock_acquire>
  40256c:	f504 7438 	add.w	r4, r4, #736	; 0x2e0
  402570:	2600      	movs	r6, #0
  402572:	b18c      	cbz	r4, 402598 <_fwalk+0x38>
  402574:	68a5      	ldr	r5, [r4, #8]
  402576:	6867      	ldr	r7, [r4, #4]
  402578:	3f01      	subs	r7, #1
  40257a:	d40b      	bmi.n	402594 <_fwalk+0x34>
  40257c:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
  402580:	b133      	cbz	r3, 402590 <_fwalk+0x30>
  402582:	f9b5 000e 	ldrsh.w	r0, [r5, #14]
  402586:	1c43      	adds	r3, r0, #1
  402588:	d002      	beq.n	402590 <_fwalk+0x30>
  40258a:	4628      	mov	r0, r5
  40258c:	47c0      	blx	r8
  40258e:	4306      	orrs	r6, r0
  402590:	3568      	adds	r5, #104	; 0x68
  402592:	e7f1      	b.n	402578 <_fwalk+0x18>
  402594:	6824      	ldr	r4, [r4, #0]
  402596:	e7ec      	b.n	402572 <_fwalk+0x12>
  402598:	f7ff fec7 	bl	40232a <__sfp_lock_release>
  40259c:	4630      	mov	r0, r6
  40259e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

004025a2 <_fwalk_reent>:
  4025a2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4025a6:	4680      	mov	r8, r0
  4025a8:	4689      	mov	r9, r1
  4025aa:	f7ff febd 	bl	402328 <__sfp_lock_acquire>
  4025ae:	f508 7438 	add.w	r4, r8, #736	; 0x2e0
  4025b2:	2600      	movs	r6, #0
  4025b4:	b194      	cbz	r4, 4025dc <_fwalk_reent+0x3a>
  4025b6:	68a5      	ldr	r5, [r4, #8]
  4025b8:	6867      	ldr	r7, [r4, #4]
  4025ba:	3f01      	subs	r7, #1
  4025bc:	d40c      	bmi.n	4025d8 <_fwalk_reent+0x36>
  4025be:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
  4025c2:	b13b      	cbz	r3, 4025d4 <_fwalk_reent+0x32>
  4025c4:	f9b5 000e 	ldrsh.w	r0, [r5, #14]
  4025c8:	1c43      	adds	r3, r0, #1
  4025ca:	d003      	beq.n	4025d4 <_fwalk_reent+0x32>
  4025cc:	4640      	mov	r0, r8
  4025ce:	4629      	mov	r1, r5
  4025d0:	47c8      	blx	r9
  4025d2:	4306      	orrs	r6, r0
  4025d4:	3568      	adds	r5, #104	; 0x68
  4025d6:	e7f0      	b.n	4025ba <_fwalk_reent+0x18>
  4025d8:	6824      	ldr	r4, [r4, #0]
  4025da:	e7eb      	b.n	4025b4 <_fwalk_reent+0x12>
  4025dc:	f7ff fea5 	bl	40232a <__sfp_lock_release>
  4025e0:	4630      	mov	r0, r6
  4025e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

004025e8 <malloc>:
  4025e8:	4b02      	ldr	r3, [pc, #8]	; (4025f4 <malloc+0xc>)
  4025ea:	4601      	mov	r1, r0
  4025ec:	6818      	ldr	r0, [r3, #0]
  4025ee:	f000 b80b 	b.w	402608 <_malloc_r>
  4025f2:	bf00      	nop
  4025f4:	20000008 	.word	0x20000008

004025f8 <free>:
  4025f8:	4b02      	ldr	r3, [pc, #8]	; (402604 <free+0xc>)
  4025fa:	4601      	mov	r1, r0
  4025fc:	6818      	ldr	r0, [r3, #0]
  4025fe:	f7ff bef9 	b.w	4023f4 <_free_r>
  402602:	bf00      	nop
  402604:	20000008 	.word	0x20000008

00402608 <_malloc_r>:
  402608:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40260c:	f101 040b 	add.w	r4, r1, #11
  402610:	2c16      	cmp	r4, #22
  402612:	4606      	mov	r6, r0
  402614:	d903      	bls.n	40261e <_malloc_r+0x16>
  402616:	f034 0407 	bics.w	r4, r4, #7
  40261a:	d501      	bpl.n	402620 <_malloc_r+0x18>
  40261c:	e002      	b.n	402624 <_malloc_r+0x1c>
  40261e:	2410      	movs	r4, #16
  402620:	428c      	cmp	r4, r1
  402622:	d202      	bcs.n	40262a <_malloc_r+0x22>
  402624:	250c      	movs	r5, #12
  402626:	6035      	str	r5, [r6, #0]
  402628:	e1d9      	b.n	4029de <_malloc_r+0x3d6>
  40262a:	4630      	mov	r0, r6
  40262c:	f000 f9ee 	bl	402a0c <__malloc_lock>
  402630:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
  402634:	d214      	bcs.n	402660 <_malloc_r+0x58>
  402636:	4da0      	ldr	r5, [pc, #640]	; (4028b8 <_malloc_r+0x2b0>)
  402638:	08e1      	lsrs	r1, r4, #3
  40263a:	eb05 00c1 	add.w	r0, r5, r1, lsl #3
  40263e:	68c5      	ldr	r5, [r0, #12]
  402640:	4285      	cmp	r5, r0
  402642:	d105      	bne.n	402650 <_malloc_r+0x48>
  402644:	f105 0308 	add.w	r3, r5, #8
  402648:	696d      	ldr	r5, [r5, #20]
  40264a:	1c8a      	adds	r2, r1, #2
  40264c:	429d      	cmp	r5, r3
  40264e:	d044      	beq.n	4026da <_malloc_r+0xd2>
  402650:	68e8      	ldr	r0, [r5, #12]
  402652:	68a9      	ldr	r1, [r5, #8]
  402654:	686a      	ldr	r2, [r5, #4]
  402656:	60c8      	str	r0, [r1, #12]
  402658:	f022 0303 	bic.w	r3, r2, #3
  40265c:	6081      	str	r1, [r0, #8]
  40265e:	e059      	b.n	402714 <_malloc_r+0x10c>
  402660:	0a62      	lsrs	r2, r4, #9
  402662:	d101      	bne.n	402668 <_malloc_r+0x60>
  402664:	08e2      	lsrs	r2, r4, #3
  402666:	e01b      	b.n	4026a0 <_malloc_r+0x98>
  402668:	2a04      	cmp	r2, #4
  40266a:	d802      	bhi.n	402672 <_malloc_r+0x6a>
  40266c:	09a2      	lsrs	r2, r4, #6
  40266e:	3238      	adds	r2, #56	; 0x38
  402670:	e016      	b.n	4026a0 <_malloc_r+0x98>
  402672:	2a14      	cmp	r2, #20
  402674:	d801      	bhi.n	40267a <_malloc_r+0x72>
  402676:	325b      	adds	r2, #91	; 0x5b
  402678:	e012      	b.n	4026a0 <_malloc_r+0x98>
  40267a:	2a54      	cmp	r2, #84	; 0x54
  40267c:	d802      	bhi.n	402684 <_malloc_r+0x7c>
  40267e:	0b22      	lsrs	r2, r4, #12
  402680:	326e      	adds	r2, #110	; 0x6e
  402682:	e00d      	b.n	4026a0 <_malloc_r+0x98>
  402684:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  402688:	d802      	bhi.n	402690 <_malloc_r+0x88>
  40268a:	0be2      	lsrs	r2, r4, #15
  40268c:	3277      	adds	r2, #119	; 0x77
  40268e:	e007      	b.n	4026a0 <_malloc_r+0x98>
  402690:	f240 5354 	movw	r3, #1364	; 0x554
  402694:	429a      	cmp	r2, r3
  402696:	d802      	bhi.n	40269e <_malloc_r+0x96>
  402698:	0ca2      	lsrs	r2, r4, #18
  40269a:	327c      	adds	r2, #124	; 0x7c
  40269c:	e000      	b.n	4026a0 <_malloc_r+0x98>
  40269e:	227e      	movs	r2, #126	; 0x7e
  4026a0:	4885      	ldr	r0, [pc, #532]	; (4028b8 <_malloc_r+0x2b0>)
  4026a2:	eb00 03c2 	add.w	r3, r0, r2, lsl #3
  4026a6:	68dd      	ldr	r5, [r3, #12]
  4026a8:	429d      	cmp	r5, r3
  4026aa:	d015      	beq.n	4026d8 <_malloc_r+0xd0>
  4026ac:	6869      	ldr	r1, [r5, #4]
  4026ae:	f021 0103 	bic.w	r1, r1, #3
  4026b2:	1b08      	subs	r0, r1, r4
  4026b4:	280f      	cmp	r0, #15
  4026b6:	dd01      	ble.n	4026bc <_malloc_r+0xb4>
  4026b8:	3a01      	subs	r2, #1
  4026ba:	e00d      	b.n	4026d8 <_malloc_r+0xd0>
  4026bc:	2800      	cmp	r0, #0
  4026be:	db09      	blt.n	4026d4 <_malloc_r+0xcc>
  4026c0:	68eb      	ldr	r3, [r5, #12]
  4026c2:	68aa      	ldr	r2, [r5, #8]
  4026c4:	60d3      	str	r3, [r2, #12]
  4026c6:	609a      	str	r2, [r3, #8]
  4026c8:	186b      	adds	r3, r5, r1
  4026ca:	685a      	ldr	r2, [r3, #4]
  4026cc:	f042 0001 	orr.w	r0, r2, #1
  4026d0:	6058      	str	r0, [r3, #4]
  4026d2:	e190      	b.n	4029f6 <_malloc_r+0x3ee>
  4026d4:	68ed      	ldr	r5, [r5, #12]
  4026d6:	e7e7      	b.n	4026a8 <_malloc_r+0xa0>
  4026d8:	3201      	adds	r2, #1
  4026da:	4977      	ldr	r1, [pc, #476]	; (4028b8 <_malloc_r+0x2b0>)
  4026dc:	690d      	ldr	r5, [r1, #16]
  4026de:	f101 0708 	add.w	r7, r1, #8
  4026e2:	42bd      	cmp	r5, r7
  4026e4:	d068      	beq.n	4027b8 <_malloc_r+0x1b0>
  4026e6:	6868      	ldr	r0, [r5, #4]
  4026e8:	f020 0303 	bic.w	r3, r0, #3
  4026ec:	1b18      	subs	r0, r3, r4
  4026ee:	280f      	cmp	r0, #15
  4026f0:	dd0c      	ble.n	40270c <_malloc_r+0x104>
  4026f2:	192b      	adds	r3, r5, r4
  4026f4:	614b      	str	r3, [r1, #20]
  4026f6:	610b      	str	r3, [r1, #16]
  4026f8:	f044 0401 	orr.w	r4, r4, #1
  4026fc:	f040 0101 	orr.w	r1, r0, #1
  402700:	606c      	str	r4, [r5, #4]
  402702:	60df      	str	r7, [r3, #12]
  402704:	609f      	str	r7, [r3, #8]
  402706:	6059      	str	r1, [r3, #4]
  402708:	5018      	str	r0, [r3, r0]
  40270a:	e174      	b.n	4029f6 <_malloc_r+0x3ee>
  40270c:	2800      	cmp	r0, #0
  40270e:	614f      	str	r7, [r1, #20]
  402710:	610f      	str	r7, [r1, #16]
  402712:	db01      	blt.n	402718 <_malloc_r+0x110>
  402714:	18eb      	adds	r3, r5, r3
  402716:	e7d8      	b.n	4026ca <_malloc_r+0xc2>
  402718:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40271c:	d20f      	bcs.n	40273e <_malloc_r+0x136>
  40271e:	08db      	lsrs	r3, r3, #3
  402720:	1098      	asrs	r0, r3, #2
  402722:	2701      	movs	r7, #1
  402724:	fa07 f700 	lsl.w	r7, r7, r0
  402728:	6848      	ldr	r0, [r1, #4]
  40272a:	4307      	orrs	r7, r0
  40272c:	604f      	str	r7, [r1, #4]
  40272e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
  402732:	60e9      	str	r1, [r5, #12]
  402734:	688b      	ldr	r3, [r1, #8]
  402736:	60ab      	str	r3, [r5, #8]
  402738:	60dd      	str	r5, [r3, #12]
  40273a:	608d      	str	r5, [r1, #8]
  40273c:	e03c      	b.n	4027b8 <_malloc_r+0x1b0>
  40273e:	0a58      	lsrs	r0, r3, #9
  402740:	2804      	cmp	r0, #4
  402742:	d802      	bhi.n	40274a <_malloc_r+0x142>
  402744:	0998      	lsrs	r0, r3, #6
  402746:	3038      	adds	r0, #56	; 0x38
  402748:	e016      	b.n	402778 <_malloc_r+0x170>
  40274a:	2814      	cmp	r0, #20
  40274c:	d801      	bhi.n	402752 <_malloc_r+0x14a>
  40274e:	305b      	adds	r0, #91	; 0x5b
  402750:	e012      	b.n	402778 <_malloc_r+0x170>
  402752:	2854      	cmp	r0, #84	; 0x54
  402754:	d802      	bhi.n	40275c <_malloc_r+0x154>
  402756:	0b18      	lsrs	r0, r3, #12
  402758:	306e      	adds	r0, #110	; 0x6e
  40275a:	e00d      	b.n	402778 <_malloc_r+0x170>
  40275c:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
  402760:	d802      	bhi.n	402768 <_malloc_r+0x160>
  402762:	0bd8      	lsrs	r0, r3, #15
  402764:	3077      	adds	r0, #119	; 0x77
  402766:	e007      	b.n	402778 <_malloc_r+0x170>
  402768:	f240 5754 	movw	r7, #1364	; 0x554
  40276c:	42b8      	cmp	r0, r7
  40276e:	d802      	bhi.n	402776 <_malloc_r+0x16e>
  402770:	0c98      	lsrs	r0, r3, #18
  402772:	307c      	adds	r0, #124	; 0x7c
  402774:	e000      	b.n	402778 <_malloc_r+0x170>
  402776:	207e      	movs	r0, #126	; 0x7e
  402778:	f8df e13c 	ldr.w	lr, [pc, #316]	; 4028b8 <_malloc_r+0x2b0>
  40277c:	eb0e 07c0 	add.w	r7, lr, r0, lsl #3
  402780:	68b9      	ldr	r1, [r7, #8]
  402782:	42b9      	cmp	r1, r7
  402784:	d10e      	bne.n	4027a4 <_malloc_r+0x19c>
  402786:	1087      	asrs	r7, r0, #2
  402788:	2301      	movs	r3, #1
  40278a:	fa03 f007 	lsl.w	r0, r3, r7
  40278e:	f8de 7004 	ldr.w	r7, [lr, #4]
  402792:	ea40 0307 	orr.w	r3, r0, r7
  402796:	f8ce 3004 	str.w	r3, [lr, #4]
  40279a:	4608      	mov	r0, r1
  40279c:	e008      	b.n	4027b0 <_malloc_r+0x1a8>
  40279e:	6889      	ldr	r1, [r1, #8]
  4027a0:	42b9      	cmp	r1, r7
  4027a2:	d004      	beq.n	4027ae <_malloc_r+0x1a6>
  4027a4:	6848      	ldr	r0, [r1, #4]
  4027a6:	f020 0003 	bic.w	r0, r0, #3
  4027aa:	4283      	cmp	r3, r0
  4027ac:	d3f7      	bcc.n	40279e <_malloc_r+0x196>
  4027ae:	68c8      	ldr	r0, [r1, #12]
  4027b0:	60e8      	str	r0, [r5, #12]
  4027b2:	60a9      	str	r1, [r5, #8]
  4027b4:	60cd      	str	r5, [r1, #12]
  4027b6:	6085      	str	r5, [r0, #8]
  4027b8:	4f3f      	ldr	r7, [pc, #252]	; (4028b8 <_malloc_r+0x2b0>)
  4027ba:	1095      	asrs	r5, r2, #2
  4027bc:	2001      	movs	r0, #1
  4027be:	6879      	ldr	r1, [r7, #4]
  4027c0:	fa00 f305 	lsl.w	r3, r0, r5
  4027c4:	428b      	cmp	r3, r1
  4027c6:	d85d      	bhi.n	402884 <_malloc_r+0x27c>
  4027c8:	420b      	tst	r3, r1
  4027ca:	d105      	bne.n	4027d8 <_malloc_r+0x1d0>
  4027cc:	f022 0203 	bic.w	r2, r2, #3
  4027d0:	005b      	lsls	r3, r3, #1
  4027d2:	3204      	adds	r2, #4
  4027d4:	420b      	tst	r3, r1
  4027d6:	d0fb      	beq.n	4027d0 <_malloc_r+0x1c8>
  4027d8:	4d37      	ldr	r5, [pc, #220]	; (4028b8 <_malloc_r+0x2b0>)
  4027da:	eb05 0ec2 	add.w	lr, r5, r2, lsl #3
  4027de:	4677      	mov	r7, lr
  4027e0:	4610      	mov	r0, r2
  4027e2:	68fd      	ldr	r5, [r7, #12]
  4027e4:	42bd      	cmp	r5, r7
  4027e6:	d02d      	beq.n	402844 <_malloc_r+0x23c>
  4027e8:	6869      	ldr	r1, [r5, #4]
  4027ea:	f021 0c03 	bic.w	ip, r1, #3
  4027ee:	ebc4 010c 	rsb	r1, r4, ip
  4027f2:	290f      	cmp	r1, #15
  4027f4:	dd13      	ble.n	40281e <_malloc_r+0x216>
  4027f6:	192b      	adds	r3, r5, r4
  4027f8:	f044 0401 	orr.w	r4, r4, #1
  4027fc:	68ea      	ldr	r2, [r5, #12]
  4027fe:	606c      	str	r4, [r5, #4]
  402800:	f855 0f08 	ldr.w	r0, [r5, #8]!
  402804:	5059      	str	r1, [r3, r1]
  402806:	60c2      	str	r2, [r0, #12]
  402808:	6090      	str	r0, [r2, #8]
  40280a:	4a2b      	ldr	r2, [pc, #172]	; (4028b8 <_malloc_r+0x2b0>)
  40280c:	f041 0001 	orr.w	r0, r1, #1
  402810:	6153      	str	r3, [r2, #20]
  402812:	6113      	str	r3, [r2, #16]
  402814:	3208      	adds	r2, #8
  402816:	60da      	str	r2, [r3, #12]
  402818:	609a      	str	r2, [r3, #8]
  40281a:	6058      	str	r0, [r3, #4]
  40281c:	e00c      	b.n	402838 <_malloc_r+0x230>
  40281e:	2900      	cmp	r1, #0
  402820:	db0e      	blt.n	402840 <_malloc_r+0x238>
  402822:	eb05 000c 	add.w	r0, r5, ip
  402826:	68e9      	ldr	r1, [r5, #12]
  402828:	6842      	ldr	r2, [r0, #4]
  40282a:	f042 0301 	orr.w	r3, r2, #1
  40282e:	6043      	str	r3, [r0, #4]
  402830:	f855 0f08 	ldr.w	r0, [r5, #8]!
  402834:	60c1      	str	r1, [r0, #12]
  402836:	6088      	str	r0, [r1, #8]
  402838:	4630      	mov	r0, r6
  40283a:	f000 f8e8 	bl	402a0e <__malloc_unlock>
  40283e:	e0de      	b.n	4029fe <_malloc_r+0x3f6>
  402840:	68ed      	ldr	r5, [r5, #12]
  402842:	e7cf      	b.n	4027e4 <_malloc_r+0x1dc>
  402844:	3001      	adds	r0, #1
  402846:	0781      	lsls	r1, r0, #30
  402848:	f105 0708 	add.w	r7, r5, #8
  40284c:	d1c9      	bne.n	4027e2 <_malloc_r+0x1da>
  40284e:	4671      	mov	r1, lr
  402850:	0795      	lsls	r5, r2, #30
  402852:	d105      	bne.n	402860 <_malloc_r+0x258>
  402854:	4a18      	ldr	r2, [pc, #96]	; (4028b8 <_malloc_r+0x2b0>)
  402856:	6855      	ldr	r5, [r2, #4]
  402858:	ea25 0503 	bic.w	r5, r5, r3
  40285c:	6055      	str	r5, [r2, #4]
  40285e:	e005      	b.n	40286c <_malloc_r+0x264>
  402860:	f1a1 0708 	sub.w	r7, r1, #8
  402864:	6809      	ldr	r1, [r1, #0]
  402866:	3a01      	subs	r2, #1
  402868:	42b9      	cmp	r1, r7
  40286a:	d0f1      	beq.n	402850 <_malloc_r+0x248>
  40286c:	4f12      	ldr	r7, [pc, #72]	; (4028b8 <_malloc_r+0x2b0>)
  40286e:	687f      	ldr	r7, [r7, #4]
  402870:	005b      	lsls	r3, r3, #1
  402872:	42bb      	cmp	r3, r7
  402874:	d806      	bhi.n	402884 <_malloc_r+0x27c>
  402876:	b12b      	cbz	r3, 402884 <_malloc_r+0x27c>
  402878:	4602      	mov	r2, r0
  40287a:	423b      	tst	r3, r7
  40287c:	d1ac      	bne.n	4027d8 <_malloc_r+0x1d0>
  40287e:	3204      	adds	r2, #4
  402880:	005b      	lsls	r3, r3, #1
  402882:	e7fa      	b.n	40287a <_malloc_r+0x272>
  402884:	4b0c      	ldr	r3, [pc, #48]	; (4028b8 <_malloc_r+0x2b0>)
  402886:	689f      	ldr	r7, [r3, #8]
  402888:	6878      	ldr	r0, [r7, #4]
  40288a:	f020 0903 	bic.w	r9, r0, #3
  40288e:	45a1      	cmp	r9, r4
  402890:	4619      	mov	r1, r3
  402892:	d304      	bcc.n	40289e <_malloc_r+0x296>
  402894:	ebc4 0009 	rsb	r0, r4, r9
  402898:	280f      	cmp	r0, #15
  40289a:	f300 80a2 	bgt.w	4029e2 <_malloc_r+0x3da>
  40289e:	4a07      	ldr	r2, [pc, #28]	; (4028bc <_malloc_r+0x2b4>)
  4028a0:	f8d1 3408 	ldr.w	r3, [r1, #1032]	; 0x408
  4028a4:	6815      	ldr	r5, [r2, #0]
  4028a6:	3301      	adds	r3, #1
  4028a8:	eb07 0a09 	add.w	sl, r7, r9
  4028ac:	eb04 0805 	add.w	r8, r4, r5
  4028b0:	d106      	bne.n	4028c0 <_malloc_r+0x2b8>
  4028b2:	f108 0810 	add.w	r8, r8, #16
  4028b6:	e00b      	b.n	4028d0 <_malloc_r+0x2c8>
  4028b8:	20000438 	.word	0x20000438
  4028bc:	20000c9c 	.word	0x20000c9c
  4028c0:	f508 5080 	add.w	r0, r8, #4096	; 0x1000
  4028c4:	f100 010f 	add.w	r1, r0, #15
  4028c8:	f421 627f 	bic.w	r2, r1, #4080	; 0xff0
  4028cc:	f022 080f 	bic.w	r8, r2, #15
  4028d0:	4630      	mov	r0, r6
  4028d2:	4641      	mov	r1, r8
  4028d4:	f000 f89c 	bl	402a10 <_sbrk_r>
  4028d8:	1c42      	adds	r2, r0, #1
  4028da:	4605      	mov	r5, r0
  4028dc:	d071      	beq.n	4029c2 <_malloc_r+0x3ba>
  4028de:	4550      	cmp	r0, sl
  4028e0:	d202      	bcs.n	4028e8 <_malloc_r+0x2e0>
  4028e2:	4b48      	ldr	r3, [pc, #288]	; (402a04 <_malloc_r+0x3fc>)
  4028e4:	429f      	cmp	r7, r3
  4028e6:	d16c      	bne.n	4029c2 <_malloc_r+0x3ba>
  4028e8:	4847      	ldr	r0, [pc, #284]	; (402a08 <_malloc_r+0x400>)
  4028ea:	4a46      	ldr	r2, [pc, #280]	; (402a04 <_malloc_r+0x3fc>)
  4028ec:	6841      	ldr	r1, [r0, #4]
  4028ee:	4555      	cmp	r5, sl
  4028f0:	eb08 0301 	add.w	r3, r8, r1
  4028f4:	6043      	str	r3, [r0, #4]
  4028f6:	d107      	bne.n	402908 <_malloc_r+0x300>
  4028f8:	0529      	lsls	r1, r5, #20
  4028fa:	d105      	bne.n	402908 <_malloc_r+0x300>
  4028fc:	6895      	ldr	r5, [r2, #8]
  4028fe:	44c8      	add	r8, r9
  402900:	f048 0001 	orr.w	r0, r8, #1
  402904:	6068      	str	r0, [r5, #4]
  402906:	e051      	b.n	4029ac <_malloc_r+0x3a4>
  402908:	f8d2 0408 	ldr.w	r0, [r2, #1032]	; 0x408
  40290c:	1c42      	adds	r2, r0, #1
  40290e:	d103      	bne.n	402918 <_malloc_r+0x310>
  402910:	4a3c      	ldr	r2, [pc, #240]	; (402a04 <_malloc_r+0x3fc>)
  402912:	f8c2 5408 	str.w	r5, [r2, #1032]	; 0x408
  402916:	e005      	b.n	402924 <_malloc_r+0x31c>
  402918:	ebca 0a05 	rsb	sl, sl, r5
  40291c:	eb03 010a 	add.w	r1, r3, sl
  402920:	4b39      	ldr	r3, [pc, #228]	; (402a08 <_malloc_r+0x400>)
  402922:	6059      	str	r1, [r3, #4]
  402924:	f015 0007 	ands.w	r0, r5, #7
  402928:	bf1c      	itt	ne
  40292a:	f1c0 0008 	rsbne	r0, r0, #8
  40292e:	182d      	addne	r5, r5, r0
  402930:	eb05 0c08 	add.w	ip, r5, r8
  402934:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
  402938:	ea4f 5e0c 	mov.w	lr, ip, lsl #20
  40293c:	eba1 581e 	sub.w	r8, r1, lr, lsr #20
  402940:	4641      	mov	r1, r8
  402942:	4630      	mov	r0, r6
  402944:	f000 f864 	bl	402a10 <_sbrk_r>
  402948:	4a2f      	ldr	r2, [pc, #188]	; (402a08 <_malloc_r+0x400>)
  40294a:	1c43      	adds	r3, r0, #1
  40294c:	6853      	ldr	r3, [r2, #4]
  40294e:	bf08      	it	eq
  402950:	f04f 0800 	moveq.w	r8, #0
  402954:	eb08 0103 	add.w	r1, r8, r3
  402958:	bf08      	it	eq
  40295a:	4628      	moveq	r0, r5
  40295c:	6051      	str	r1, [r2, #4]
  40295e:	1b40      	subs	r0, r0, r5
  402960:	4a28      	ldr	r2, [pc, #160]	; (402a04 <_malloc_r+0x3fc>)
  402962:	eb00 0308 	add.w	r3, r0, r8
  402966:	f043 0101 	orr.w	r1, r3, #1
  40296a:	4297      	cmp	r7, r2
  40296c:	6095      	str	r5, [r2, #8]
  40296e:	6069      	str	r1, [r5, #4]
  402970:	d01c      	beq.n	4029ac <_malloc_r+0x3a4>
  402972:	f1b9 0f0f 	cmp.w	r9, #15
  402976:	d802      	bhi.n	40297e <_malloc_r+0x376>
  402978:	2201      	movs	r2, #1
  40297a:	606a      	str	r2, [r5, #4]
  40297c:	e021      	b.n	4029c2 <_malloc_r+0x3ba>
  40297e:	687d      	ldr	r5, [r7, #4]
  402980:	f1a9 090c 	sub.w	r9, r9, #12
  402984:	f029 0907 	bic.w	r9, r9, #7
  402988:	eb07 0309 	add.w	r3, r7, r9
  40298c:	f005 0201 	and.w	r2, r5, #1
  402990:	2105      	movs	r1, #5
  402992:	ea49 0002 	orr.w	r0, r9, r2
  402996:	f1b9 0f0f 	cmp.w	r9, #15
  40299a:	6078      	str	r0, [r7, #4]
  40299c:	6059      	str	r1, [r3, #4]
  40299e:	6099      	str	r1, [r3, #8]
  4029a0:	d904      	bls.n	4029ac <_malloc_r+0x3a4>
  4029a2:	4630      	mov	r0, r6
  4029a4:	f107 0108 	add.w	r1, r7, #8
  4029a8:	f7ff fd24 	bl	4023f4 <_free_r>
  4029ac:	4a16      	ldr	r2, [pc, #88]	; (402a08 <_malloc_r+0x400>)
  4029ae:	6853      	ldr	r3, [r2, #4]
  4029b0:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  4029b2:	6b15      	ldr	r5, [r2, #48]	; 0x30
  4029b4:	428b      	cmp	r3, r1
  4029b6:	bf88      	it	hi
  4029b8:	62d3      	strhi	r3, [r2, #44]	; 0x2c
  4029ba:	42ab      	cmp	r3, r5
  4029bc:	bf84      	itt	hi
  4029be:	4d12      	ldrhi	r5, [pc, #72]	; (402a08 <_malloc_r+0x400>)
  4029c0:	632b      	strhi	r3, [r5, #48]	; 0x30
  4029c2:	4810      	ldr	r0, [pc, #64]	; (402a04 <_malloc_r+0x3fc>)
  4029c4:	6882      	ldr	r2, [r0, #8]
  4029c6:	6853      	ldr	r3, [r2, #4]
  4029c8:	f023 0103 	bic.w	r1, r3, #3
  4029cc:	42a1      	cmp	r1, r4
  4029ce:	ebc4 0001 	rsb	r0, r4, r1
  4029d2:	d301      	bcc.n	4029d8 <_malloc_r+0x3d0>
  4029d4:	280f      	cmp	r0, #15
  4029d6:	dc04      	bgt.n	4029e2 <_malloc_r+0x3da>
  4029d8:	4630      	mov	r0, r6
  4029da:	f000 f818 	bl	402a0e <__malloc_unlock>
  4029de:	2500      	movs	r5, #0
  4029e0:	e00d      	b.n	4029fe <_malloc_r+0x3f6>
  4029e2:	4a08      	ldr	r2, [pc, #32]	; (402a04 <_malloc_r+0x3fc>)
  4029e4:	6895      	ldr	r5, [r2, #8]
  4029e6:	f044 0301 	orr.w	r3, r4, #1
  4029ea:	192c      	adds	r4, r5, r4
  4029ec:	f040 0101 	orr.w	r1, r0, #1
  4029f0:	606b      	str	r3, [r5, #4]
  4029f2:	6094      	str	r4, [r2, #8]
  4029f4:	6061      	str	r1, [r4, #4]
  4029f6:	4630      	mov	r0, r6
  4029f8:	f000 f809 	bl	402a0e <__malloc_unlock>
  4029fc:	3508      	adds	r5, #8
  4029fe:	4628      	mov	r0, r5
  402a00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402a04:	20000438 	.word	0x20000438
  402a08:	20000c9c 	.word	0x20000c9c

00402a0c <__malloc_lock>:
  402a0c:	4770      	bx	lr

00402a0e <__malloc_unlock>:
  402a0e:	4770      	bx	lr

00402a10 <_sbrk_r>:
  402a10:	b538      	push	{r3, r4, r5, lr}
  402a12:	4c06      	ldr	r4, [pc, #24]	; (402a2c <_sbrk_r+0x1c>)
  402a14:	2300      	movs	r3, #0
  402a16:	4605      	mov	r5, r0
  402a18:	4608      	mov	r0, r1
  402a1a:	6023      	str	r3, [r4, #0]
  402a1c:	f7ff f824 	bl	401a68 <_sbrk>
  402a20:	1c43      	adds	r3, r0, #1
  402a22:	d102      	bne.n	402a2a <_sbrk_r+0x1a>
  402a24:	6821      	ldr	r1, [r4, #0]
  402a26:	b101      	cbz	r1, 402a2a <_sbrk_r+0x1a>
  402a28:	6029      	str	r1, [r5, #0]
  402a2a:	bd38      	pop	{r3, r4, r5, pc}
  402a2c:	20000cf0 	.word	0x20000cf0

00402a30 <__sread>:
  402a30:	b510      	push	{r4, lr}
  402a32:	460c      	mov	r4, r1
  402a34:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402a38:	f000 f8c0 	bl	402bbc <_read_r>
  402a3c:	2800      	cmp	r0, #0
  402a3e:	db03      	blt.n	402a48 <__sread+0x18>
  402a40:	6d22      	ldr	r2, [r4, #80]	; 0x50
  402a42:	1813      	adds	r3, r2, r0
  402a44:	6523      	str	r3, [r4, #80]	; 0x50
  402a46:	bd10      	pop	{r4, pc}
  402a48:	89a3      	ldrh	r3, [r4, #12]
  402a4a:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
  402a4e:	81a1      	strh	r1, [r4, #12]
  402a50:	bd10      	pop	{r4, pc}

00402a52 <__seofread>:
  402a52:	2000      	movs	r0, #0
  402a54:	4770      	bx	lr

00402a56 <__swrite>:
  402a56:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402a5a:	461d      	mov	r5, r3
  402a5c:	898b      	ldrh	r3, [r1, #12]
  402a5e:	460c      	mov	r4, r1
  402a60:	f403 7180 	and.w	r1, r3, #256	; 0x100
  402a64:	4616      	mov	r6, r2
  402a66:	b20a      	sxth	r2, r1
  402a68:	4607      	mov	r7, r0
  402a6a:	b12a      	cbz	r2, 402a78 <__swrite+0x22>
  402a6c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  402a70:	2200      	movs	r2, #0
  402a72:	2302      	movs	r3, #2
  402a74:	f000 f890 	bl	402b98 <_lseek_r>
  402a78:	89a0      	ldrh	r0, [r4, #12]
  402a7a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  402a7e:	f420 5380 	bic.w	r3, r0, #4096	; 0x1000
  402a82:	81a3      	strh	r3, [r4, #12]
  402a84:	4638      	mov	r0, r7
  402a86:	4632      	mov	r2, r6
  402a88:	462b      	mov	r3, r5
  402a8a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  402a8e:	f000 b817 	b.w	402ac0 <_write_r>

00402a92 <__sseek>:
  402a92:	b510      	push	{r4, lr}
  402a94:	460c      	mov	r4, r1
  402a96:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402a9a:	f000 f87d 	bl	402b98 <_lseek_r>
  402a9e:	1c43      	adds	r3, r0, #1
  402aa0:	89a3      	ldrh	r3, [r4, #12]
  402aa2:	d103      	bne.n	402aac <__sseek+0x1a>
  402aa4:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
  402aa8:	81a2      	strh	r2, [r4, #12]
  402aaa:	bd10      	pop	{r4, pc}
  402aac:	f443 5180 	orr.w	r1, r3, #4096	; 0x1000
  402ab0:	81a1      	strh	r1, [r4, #12]
  402ab2:	6520      	str	r0, [r4, #80]	; 0x50
  402ab4:	bd10      	pop	{r4, pc}

00402ab6 <__sclose>:
  402ab6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402aba:	f000 b813 	b.w	402ae4 <_close_r>
	...

00402ac0 <_write_r>:
  402ac0:	b538      	push	{r3, r4, r5, lr}
  402ac2:	4c07      	ldr	r4, [pc, #28]	; (402ae0 <_write_r+0x20>)
  402ac4:	4605      	mov	r5, r0
  402ac6:	2000      	movs	r0, #0
  402ac8:	6020      	str	r0, [r4, #0]
  402aca:	4608      	mov	r0, r1
  402acc:	4611      	mov	r1, r2
  402ace:	461a      	mov	r2, r3
  402ad0:	f7fd fbd4 	bl	40027c <_write>
  402ad4:	1c43      	adds	r3, r0, #1
  402ad6:	d102      	bne.n	402ade <_write_r+0x1e>
  402ad8:	6823      	ldr	r3, [r4, #0]
  402ada:	b103      	cbz	r3, 402ade <_write_r+0x1e>
  402adc:	602b      	str	r3, [r5, #0]
  402ade:	bd38      	pop	{r3, r4, r5, pc}
  402ae0:	20000cf0 	.word	0x20000cf0

00402ae4 <_close_r>:
  402ae4:	b538      	push	{r3, r4, r5, lr}
  402ae6:	4c06      	ldr	r4, [pc, #24]	; (402b00 <_close_r+0x1c>)
  402ae8:	2300      	movs	r3, #0
  402aea:	4605      	mov	r5, r0
  402aec:	4608      	mov	r0, r1
  402aee:	6023      	str	r3, [r4, #0]
  402af0:	f7fe ffe0 	bl	401ab4 <_close>
  402af4:	1c43      	adds	r3, r0, #1
  402af6:	d102      	bne.n	402afe <_close_r+0x1a>
  402af8:	6821      	ldr	r1, [r4, #0]
  402afa:	b101      	cbz	r1, 402afe <_close_r+0x1a>
  402afc:	6029      	str	r1, [r5, #0]
  402afe:	bd38      	pop	{r3, r4, r5, pc}
  402b00:	20000cf0 	.word	0x20000cf0

00402b04 <_fclose_r>:
  402b04:	b570      	push	{r4, r5, r6, lr}
  402b06:	4605      	mov	r5, r0
  402b08:	460c      	mov	r4, r1
  402b0a:	2900      	cmp	r1, #0
  402b0c:	d039      	beq.n	402b82 <_fclose_r+0x7e>
  402b0e:	f7ff fc0b 	bl	402328 <__sfp_lock_acquire>
  402b12:	b125      	cbz	r5, 402b1e <_fclose_r+0x1a>
  402b14:	6bab      	ldr	r3, [r5, #56]	; 0x38
  402b16:	b913      	cbnz	r3, 402b1e <_fclose_r+0x1a>
  402b18:	4628      	mov	r0, r5
  402b1a:	f7ff fba1 	bl	402260 <__sinit>
  402b1e:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
  402b22:	b35e      	cbz	r6, 402b7c <_fclose_r+0x78>
  402b24:	4628      	mov	r0, r5
  402b26:	4621      	mov	r1, r4
  402b28:	f7ff faa6 	bl	402078 <_fflush_r>
  402b2c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  402b2e:	4606      	mov	r6, r0
  402b30:	b13a      	cbz	r2, 402b42 <_fclose_r+0x3e>
  402b32:	4628      	mov	r0, r5
  402b34:	69e1      	ldr	r1, [r4, #28]
  402b36:	4790      	blx	r2
  402b38:	ea36 0620 	bics.w	r6, r6, r0, asr #32
  402b3c:	bf28      	it	cs
  402b3e:	f04f 36ff 	movcs.w	r6, #4294967295
  402b42:	89a0      	ldrh	r0, [r4, #12]
  402b44:	f000 0180 	and.w	r1, r0, #128	; 0x80
  402b48:	b20b      	sxth	r3, r1
  402b4a:	b11b      	cbz	r3, 402b54 <_fclose_r+0x50>
  402b4c:	4628      	mov	r0, r5
  402b4e:	6921      	ldr	r1, [r4, #16]
  402b50:	f7ff fc50 	bl	4023f4 <_free_r>
  402b54:	6b21      	ldr	r1, [r4, #48]	; 0x30
  402b56:	b141      	cbz	r1, 402b6a <_fclose_r+0x66>
  402b58:	f104 0240 	add.w	r2, r4, #64	; 0x40
  402b5c:	4291      	cmp	r1, r2
  402b5e:	d002      	beq.n	402b66 <_fclose_r+0x62>
  402b60:	4628      	mov	r0, r5
  402b62:	f7ff fc47 	bl	4023f4 <_free_r>
  402b66:	2000      	movs	r0, #0
  402b68:	6320      	str	r0, [r4, #48]	; 0x30
  402b6a:	6c61      	ldr	r1, [r4, #68]	; 0x44
  402b6c:	b121      	cbz	r1, 402b78 <_fclose_r+0x74>
  402b6e:	4628      	mov	r0, r5
  402b70:	f7ff fc40 	bl	4023f4 <_free_r>
  402b74:	2100      	movs	r1, #0
  402b76:	6461      	str	r1, [r4, #68]	; 0x44
  402b78:	2300      	movs	r3, #0
  402b7a:	81a3      	strh	r3, [r4, #12]
  402b7c:	f7ff fbd5 	bl	40232a <__sfp_lock_release>
  402b80:	e000      	b.n	402b84 <_fclose_r+0x80>
  402b82:	460e      	mov	r6, r1
  402b84:	4630      	mov	r0, r6
  402b86:	bd70      	pop	{r4, r5, r6, pc}

00402b88 <fclose>:
  402b88:	4b02      	ldr	r3, [pc, #8]	; (402b94 <fclose+0xc>)
  402b8a:	4601      	mov	r1, r0
  402b8c:	6818      	ldr	r0, [r3, #0]
  402b8e:	f7ff bfb9 	b.w	402b04 <_fclose_r>
  402b92:	bf00      	nop
  402b94:	20000008 	.word	0x20000008

00402b98 <_lseek_r>:
  402b98:	b538      	push	{r3, r4, r5, lr}
  402b9a:	4c07      	ldr	r4, [pc, #28]	; (402bb8 <_lseek_r+0x20>)
  402b9c:	4605      	mov	r5, r0
  402b9e:	2000      	movs	r0, #0
  402ba0:	6020      	str	r0, [r4, #0]
  402ba2:	4608      	mov	r0, r1
  402ba4:	4611      	mov	r1, r2
  402ba6:	461a      	mov	r2, r3
  402ba8:	f7fe ff88 	bl	401abc <_lseek>
  402bac:	1c43      	adds	r3, r0, #1
  402bae:	d102      	bne.n	402bb6 <_lseek_r+0x1e>
  402bb0:	6823      	ldr	r3, [r4, #0]
  402bb2:	b103      	cbz	r3, 402bb6 <_lseek_r+0x1e>
  402bb4:	602b      	str	r3, [r5, #0]
  402bb6:	bd38      	pop	{r3, r4, r5, pc}
  402bb8:	20000cf0 	.word	0x20000cf0

00402bbc <_read_r>:
  402bbc:	b538      	push	{r3, r4, r5, lr}
  402bbe:	4c07      	ldr	r4, [pc, #28]	; (402bdc <_read_r+0x20>)
  402bc0:	4605      	mov	r5, r0
  402bc2:	2000      	movs	r0, #0
  402bc4:	6020      	str	r0, [r4, #0]
  402bc6:	4608      	mov	r0, r1
  402bc8:	4611      	mov	r1, r2
  402bca:	461a      	mov	r2, r3
  402bcc:	f7fd fb12 	bl	4001f4 <_read>
  402bd0:	1c43      	adds	r3, r0, #1
  402bd2:	d102      	bne.n	402bda <_read_r+0x1e>
  402bd4:	6823      	ldr	r3, [r4, #0]
  402bd6:	b103      	cbz	r3, 402bda <_read_r+0x1e>
  402bd8:	602b      	str	r3, [r5, #0]
  402bda:	bd38      	pop	{r3, r4, r5, pc}
  402bdc:	20000cf0 	.word	0x20000cf0

00402be0 <p_uc_charset10x14>:
	...
  402bfc:	ccffccff 00000000 00000000 00000000     ................
  402c0c:	00f000f0 00000000 00f000f0 00000000     ................
  402c1c:	c00cc00c fcfffcff c00cc00c fcfffcff     ................
  402c2c:	c00cc00c 701e600c 3033303f fcfffcff     .....`.p?030....
  402c3c:	f0333033 c018e039 0cf00060 f0603cf0     303.9...`....<`.
  402c4c:	000fc003 3cf0183c 18003cc0 f87ff03c     ....<..<.<..<...
  402c5c:	8cc71cc3 ecdccccf 30307878 cc00fc00     ........xx00....
  402c6c:	00000000 00440000 00f800ec 00000070     ......D.....p...
	...
  402c84:	f03fc00f 18607878 0cc00cc0 00000000     ..?.xx`.........
  402c94:	00000000 0cc00cc0 78781860 c00ff03f     ........`.xx?...
  402ca4:	00000000 e00e600c 8003c007 f83ff83f     .....`......?.?.
  402cb4:	c0078003 600ce00e 00030003 00030003     .......`........
  402cc4:	f03ff03f 00030003 00030003 ec004400     ?.?..........D..
  402cd4:	7000f800 00000000 00000000 00000000     ...p............
  402ce4:	00030003 00030003 00030003 00030003     ................
  402cf4:	00030003 3c001800 18003c00 00000000     .......<.<......
	...
  402d0c:	0c000000 f0003c00 000fc003 00f0003c     .....<......<...
  402d1c:	000000c0 f87ff03f ccc1fce0 0cc78cc3     ....?...........
  402d2c:	1cfc0cce f03ff87f 00000000 0c700c30     ......?.....0.p.
  402d3c:	fcfffcff 0c000c00 00000000 1c700c30     ............0.p.
  402d4c:	7cc03ce0 ccc1ecc0 0ce78cc3 0c3c0c7e     .<.|........~.<.
  402d5c:	38703030 0cc01ce0 0cc30cc0 1ce30cc3     00p8............
  402d6c:	f03cf87f c007c003 c01cc00e c070c038     ..<.........8.p.
  402d7c:	fcfffcff c000c000 38fc30fc 0ccc1ccc     .........0.8....
  402d8c:	0ccc0ccc 1cce0ccc f0c3f8c7 f87ff03f     ............?...
  402d9c:	0cc31ce3 0cc30cc3 9ce30cc3 f030f871     ............q.0.
  402dac:	00c000c0 00c000c0 fcc7fcc3 00dc00ce     ................
  402dbc:	00f000f8 f87ff03c 0cc39ce7 0cc30cc3     ....<...........
  402dcc:	9ce70cc3 f03cf87f 007e003c 0cc30ce7     ......<.<.~.....
  402ddc:	38c31cc3 e0e770c3 803fc07f 00000000     ...8.p....?.....
  402dec:	60180000 f03cf03c 00006018 00000000     ...`<.<..`......
  402dfc:	00000000 44180000 f83cec3c 00007018     .......D<.<..p..
  402e0c:	00000000 00030000 c00f8007 7038e01c     ..............8p
  402e1c:	1ce03870 00000cc0 c00cc00c c00cc00c     p8..............
  402e2c:	c00cc00c c00cc00c c00cc00c 0cc00000     ................
  402e3c:	38701ce0 e01c7038 8007c00f 00000003     ..p88p..........
  402e4c:	00700030 00c000e0 ecc3ecc1 00e600c3     0.p.............
  402e5c:	003c007e f871f030 0cc39ce3 fcc3fcc3     ~.<.0.q.........
  402e6c:	1ce00cc0 f03ff87f fc7ffc3f c0c0c0e0     ......?.?.......
  402e7c:	c0c0c0c0 c0e0c0c0 fc3ffc7f fcfffcff     ..........?.....
  402e8c:	0cc30cc3 0cc30cc3 9ce70cc3 f03cf87f     ..............<.
  402e9c:	f87ff03f 0cc01ce0 0cc00cc0 1ce00cc0     ?...............
  402eac:	30303870 fcfffcff 0cc00cc0 0cc00cc0     p800............
  402ebc:	1ce00cc0 f03ff87f fcfffcff 0cc30cc3     ......?.........
  402ecc:	0cc30cc3 0cc30cc3 0cc00cc0 fcfffcff     ................
  402edc:	00c300c3 00c300c3 00c300c3 00c000c0     ................
  402eec:	f87ff03f 0cc01ce0 0cc30cc0 1ce30cc3     ?...............
  402efc:	f033f873 fcfffcff 00030003 00030003     s.3.............
  402f0c:	00030003 fcfffcff 00000000 0cc00cc0     ................
  402f1c:	fcfffcff 0cc00cc0 00000000 38003000     .............0.8
  402f2c:	0cc01cc0 1cc00cc0 f0fff8ff 00c000c0     ................
  402f3c:	fcfffcff 80078007 e01cc00f 38707038     ............8pp8
  402f4c:	0cc01ce0 fcfffcff 0c000c00 0c000c00     ................
  402f5c:	0c000c00 0c000c00 fcfffcff 00380070     ............p.8.
  402f6c:	001f001f 00700038 fcfffcff fcfffcff     ....8.p.........
  402f7c:	000e001c 80030007 e000c001 fcfffcff     ................
  402f8c:	f87ff03f 0cc01ce0 0cc00cc0 1ce00cc0     ?...............
  402f9c:	f03ff87f fcfffcff 00c300c3 00c300c3     ..?.............
  402fac:	00e700c3 003c007e f87ff03f 0cc01ce0     ....~.<.?.......
  402fbc:	ecc0ccc0 38e07cc0 ec3ffc7f fcfffcff     .....|.8..?.....
  402fcc:	80c300c3 c0c380c3 70e7c0c3 1c3c3c7e     ...........p~<<.
  402fdc:	1c7e183c 0cc30ce7 0cc30cc3 9cc30cc3     <.~.............
  402fec:	f060f8e1 00c000c0 00c000c0 fcfffcff     ..`.............
  402ffc:	00c000c0 00c000c0 f8fff0ff 0c001c00     ................
  40300c:	0c000c00 1c000c00 f0fff8ff e0ffc0ff     ................
  40301c:	38007000 1c001c00 70003800 c0ffe0ff     .p.8.....8.p....
  40302c:	f8fff0ff 3c001c00 f800f800 1c003c00     .......<.....<..
  40303c:	f0fff8ff 7cf83cf0 c00fe01c 80078007     .....<.|........
  40304c:	e01cc00f 3cf07cf8 00fe00fc 80030007     .....|.<........
  40305c:	fc01fc01 00078003 00fc00fe 7cc03cc0     .............<.|
  40306c:	ccc1ecc0 0cc78cc3 0cdc0cce 0cf00cf8     ................
  40307c:	00000000 fcfffcff 0cc00cc0 00000cc0     ................
  40308c:	00000000 00300030 000c000c 00030003     ....0.0.........
  40309c:	c000c000 30003000 00000000 0cc00cc0     .....0.0........
  4030ac:	fcff0cc0 0000fcff 00000000 001c000c     ................
  4030bc:	00700038 00e000e0 00380070 000c001c     8.p.....p.8.....
  4030cc:	0c000c00 0c000c00 0c000c00 0c000c00     ................
  4030dc:	0c000c00 00000000 00e000c0 00380070     ............p.8.
  4030ec:	00000018 00000000 78063000 cc0cfc0e     .........0.x....
  4030fc:	cc0ccc0c cc0ecc0c f803fc07 fcfffcff     ................
  40310c:	0c030c03 0c030c03 9c030c03 f000f801     ................
  40311c:	f807f003 0c0c1c0e 0c0c0c0c 1c0e0c0c     ................
  40312c:	30033807 f801f000 0c039c03 0c030c03     .8.0............
  40313c:	0c030c03 fcfffcff f807f003 cc0cdc0e     ................
  40314c:	cc0ccc0c dc0ecc0c 9003d807 00030000     ................
  40315c:	fc7ffc3f 00e300e3 00300070 00000000     ?.......p.0.....
  40316c:	9c071803 cc0ccc0f cc0ccc0c dc0ccc0c     ................
  40317c:	f007f80f fcfffcff 00030003 00030003     ................
  40318c:	fc018003 0000fc00 00000000 00000000     ................
  40319c:	fc1bfc1b 00000000 00000000 30000000     ...............0
  4031ac:	1c003800 0c000c00 f8cf1c00 0000f0cf     .8..............
  4031bc:	fcff0000 e000fcff f003e001 1c0e3807     .............8..
  4031cc:	00000c0c 00000000 0cc00cc0 fcfffcff     ................
  4031dc:	0c000c00 00000000 fc0ffc0f 0007000e     ................
  4031ec:	c003c003 000e0007 fc0ffc0f fc0ffc0f     ................
  4031fc:	00070003 000c000e 000e000c fc03fc07     ................
  40320c:	f807f003 0c0c1c0e 0c0c0c0c 1c0e0c0c     ................
  40321c:	f003f807 fc0ffc0f c00cc00c c00cc00c     ................
  40322c:	c00fc00c 00038007 80070003 c00cc00f     ................
  40323c:	c00cc00c c00cc00c fc0ffc0f fc0ffc0f     ................
  40324c:	00078003 000c000e 000e000c 00030007     ................
  40325c:	9c071803 cc0ccc0f cc0ccc0c fc0ccc0c     ................
  40326c:	3006780e 000c0000 f0ff000c 1c0cf8ff     .x.0............
  40327c:	380c1c0c 0000300c f80ff00f 0c001c00     ...8.0..........
  40328c:	0c000c00 1c000c00 f00ff80f e00fc00f     ................
  40329c:	38007000 1c001c00 70003800 c00fe00f     .p.8.....8.p....
  4032ac:	f80ff00f 1c001c00 f800f800 1c001c00     ................
  4032bc:	f00ff80f 1c0e0c0c f0033807 e001e001     .........8......
  4032cc:	3807f003 0c0c1c0e 000e000c 9c030c07     ...8............
  4032dc:	f001f801 00078003 000c000e 1c0c0c0c     ................
  4032ec:	7c0c3c0c cc0dec0c 0c0f8c0f 0c0c0c0e     .<.|............
  4032fc:	00030000 f03f8007 1ce0f87c 0cc00cc0     ......?.|.......
  40330c:	00000cc0 0c030c03 fc7ffc3f 0cc30ce3     ........?.......
  40331c:	0ce00cc0 0c300c70 0cc00000 0cc00cc0     ....p.0.........
  40332c:	f87c1ce0 8007f03f 00000003 00c000c0     ..|.?...........
  40333c:	00c000c0 00c000c0 00c000c0 00c000c0     ................
  40334c:	fcfffcff fcfffcff fcfffcff fcfffcff     ................
  40335c:	fcfffcff 39696c69 5f353233 2064636c     ....ili9325_lcd 
  40336c:	6d617865 00656c70                       example.

00403374 <_global_impure_ptr>:
  403374:	20000010 00000043                       ... C...

0040337c <_init>:
  40337c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40337e:	bf00      	nop
  403380:	bcf8      	pop	{r3, r4, r5, r6, r7}
  403382:	bc08      	pop	{r3}
  403384:	469e      	mov	lr, r3
  403386:	4770      	bx	lr

00403388 <__init_array_start>:
  403388:	00402059 	.word	0x00402059

0040338c <__frame_dummy_init_array_entry>:
  40338c:	00400145                                E.@.

00403390 <_fini>:
  403390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  403392:	bf00      	nop
  403394:	bcf8      	pop	{r3, r4, r5, r6, r7}
  403396:	bc08      	pop	{r3}
  403398:	469e      	mov	lr, r3
  40339a:	4770      	bx	lr

0040339c <__fini_array_start>:
  40339c:	0040011d 	.word	0x0040011d
